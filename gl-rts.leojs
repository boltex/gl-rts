{
  "leoHeader": {
    "fileFormat": 2
  },
  "vnodes": [
    {
      "gnx": "felix.20241217200720.1",
      "vh": "introduction"
    },
    {
      "gnx": "felix.20241227202430.1",
      "vh": "@clean src/main.ts",
      "children": [
        {
          "gnx": "felix.20241227202519.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20241227213048.1",
          "vh": "Create Game"
        }
      ]
    },
    {
      "gnx": "felix.20250131210259.1",
      "vh": "@clean src/game.ts",
      "children": [
        {
          "gnx": "felix.20250131211056.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20241227213056.1",
          "vh": "class Game",
          "children": [
            {
              "gnx": "felix.20241227213841.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250202181151.1",
              "vh": "dispose"
            },
            {
              "gnx": "felix.20241227213217.1",
              "vh": "handleCanvasResize"
            },
            {
              "gnx": "felix.20241228191055.1",
              "vh": "resizeCanvasToDisplaySize"
            },
            {
              "gnx": "felix.20241229230016.1",
              "vh": "startGame"
            },
            {
              "gnx": "felix.20250105213621.1",
              "vh": "initGameStates"
            },
            {
              "gnx": "felix.20241230215224.1",
              "vh": "procGame"
            },
            {
              "gnx": "felix.20241227213236.1",
              "vh": "update"
            },
            {
              "gnx": "felix.20241229162229.1",
              "vh": "checkUpdate"
            },
            {
              "gnx": "felix.20241230215229.1",
              "vh": "tick"
            },
            {
              "gnx": "felix.20241229214656.1",
              "vh": "loop"
            },
            {
              "gnx": "felix.20241230215401.1",
              "vh": "defaultAction"
            },
            {
              "gnx": "felix.20241230215406.1",
              "vh": "selectUnits"
            },
            {
              "gnx": "felix.20250208202349.1",
              "vh": "setTileAt"
            },
            {
              "gnx": "felix.20250208205929.1",
              "vh": "getTileAt"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210715.1",
      "vh": "@clean src/input-manager.ts",
      "children": [
        {
          "gnx": "felix.20250131211201.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250107221804.1",
          "vh": "class InputManager",
          "children": [
            {
              "gnx": "felix.20250107221855.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250107232140.1",
              "vh": "getters"
            },
            {
              "gnx": "felix.20250107230733.1",
              "vh": "init"
            },
            {
              "gnx": "felix.20250202204636.1",
              "vh": "dispose"
            },
            {
              "gnx": "felix.20250107230755.1",
              "vh": "handleKeyDown"
            },
            {
              "gnx": "felix.20250107230802.1",
              "vh": "handleKeyUp"
            },
            {
              "gnx": "felix.20250107230806.1",
              "vh": "handleMouseMove"
            },
            {
              "gnx": "felix.20250107230811.1",
              "vh": "handleMouseDown"
            },
            {
              "gnx": "felix.20250107230817.1",
              "vh": "handleMouseUp"
            },
            {
              "gnx": "felix.20250107230822.1",
              "vh": "handleMouseWheel"
            },
            {
              "gnx": "felix.20250107230828.1",
              "vh": "setCursorPos"
            },
            {
              "gnx": "felix.20250107230906.1",
              "vh": "processInputs"
            },
            {
              "gnx": "felix.20250107230936.1",
              "vh": "isSelecting"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003719.1",
      "vh": "@clean src/renderer-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201003821.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250201171432.1",
          "vh": "class RendererManager",
          "children": [
            {
              "gnx": "felix.20250201171528.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250205232454.1",
              "vh": "initUboBindings"
            },
            {
              "gnx": "felix.20250201171626.1",
              "vh": "setUboWorldTransforms"
            },
            {
              "gnx": "felix.20250201171643.1",
              "vh": "render"
            },
            {
              "gnx": "felix.20250201171639.1",
              "vh": "dispose"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003723.1",
      "vh": "@clean src/ui-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201205415.1",
          "vh": "class UIManager",
          "children": [
            {
              "gnx": "felix.20250201205647.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250201205642.1",
              "vh": "mainMenu"
            },
            {
              "gnx": "felix.20250201205637.1",
              "vh": "setCursor"
            },
            {
              "gnx": "felix.20250201205632.1",
              "vh": "toggleGameMenu"
            },
            {
              "gnx": "felix.20250201205627.1",
              "vh": "animateCursor"
            },
            {
              "gnx": "felix.20250201205615.1",
              "vh": "getStartButtonElement"
            },
            {
              "gnx": "felix.20250201205555.1",
              "vh": "getResolutionSelectElement"
            },
            {
              "gnx": "felix.20250208194821.1",
              "vh": "toggleMapEditor"
            },
            {
              "gnx": "felix.20250208194831.1",
              "vh": "isMapEditorVisible"
            },
            {
              "gnx": "felix.20250208194839.1",
              "vh": "getSelectedTileIndex"
            },
            {
              "gnx": "felix.20250208194845.1",
              "vh": "buildMapEditor"
            },
            {
              "gnx": "felix.20250208204757.1",
              "vh": "addDragElement"
            },
            {
              "gnx": "felix.20250208194855.1",
              "vh": "updateTilePreview"
            },
            {
              "gnx": "felix.20250208231505.1",
              "vh": "setTileSelectIndex"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003723.2",
      "vh": "@clean src/camera-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201003827.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250201233259.1",
          "vh": "class CameraManager",
          "children": [
            {
              "gnx": "felix.20250201233355.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250201234908.1",
              "vh": "scroll"
            },
            {
              "gnx": "felix.20250202002655.1",
              "vh": "setResolution"
            },
            {
              "gnx": "felix.20250201233351.1",
              "vh": "updateProperties"
            },
            {
              "gnx": "felix.20250201233346.1",
              "vh": "setZoom"
            },
            {
              "gnx": "felix.20250204221504.1",
              "vh": "zoomIn"
            },
            {
              "gnx": "felix.20250204221510.1",
              "vh": "zoomOut"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003723.3",
      "vh": "@clean src/time-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201003825.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250202011725.1",
          "vh": "class TimeManager",
          "children": [
            {
              "gnx": "felix.20250202135345.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250202135338.1",
              "vh": "update"
            },
            {
              "gnx": "felix.20250202135334.1",
              "vh": "shouldAnimUpdate"
            },
            {
              "gnx": "felix.20250202135329.1",
              "vh": "shouldTickUpdate"
            },
            {
              "gnx": "felix.20250202135324.1",
              "vh": "updateFps"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210755.1",
      "vh": "@clean src/entities.ts",
      "children": [
        {
          "gnx": "felix.20250131211133.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250105212000.1",
          "vh": "class Entities",
          "children": [
            {
              "gnx": "felix.20250105212000.2",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250105212000.3",
              "vh": "spawn"
            },
            {
              "gnx": "felix.20250105212000.4",
              "vh": "remove"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210816.1",
      "vh": "@clean src/behaviors.ts",
      "children": [
        {
          "gnx": "felix.20250131211212.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250105212047.1",
          "vh": "class Behaviors",
          "children": [
            {
              "gnx": "felix.20250105212047.2",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250105212047.3",
              "vh": "process"
            },
            {
              "gnx": "felix.20250105212047.4",
              "vh": "alien"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210828.1",
      "vh": "@clean src/renderers.ts",
      "children": [
        {
          "gnx": "felix.20250131211216.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250126174340.1",
          "vh": "class BaseRenderer"
        },
        {
          "gnx": "felix.20250126193731.1",
          "vh": "class TileRenderer"
        },
        {
          "gnx": "felix.20250207201240.1",
          "vh": "class WidgetRenderer"
        },
        {
          "gnx": "felix.20250127234240.1",
          "vh": "class SpriteRenderer"
        },
        {
          "gnx": "felix.20250128200945.1",
          "vh": "class RectangleRenderer"
        }
      ]
    },
    {
      "gnx": "felix.20241220002054.1",
      "vh": "@clean src/types.ts",
      "children": [
        {
          "gnx": "felix.20241220002054.3",
          "vh": "types"
        }
      ]
    },
    {
      "gnx": "felix.20241224183015.1",
      "vh": "@clean src/utils.ts",
      "children": [
        {
          "gnx": "felix.20250122233854.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20241224183525.1",
          "vh": "fullScreen"
        },
        {
          "gnx": "felix.20250120234029.1",
          "vh": "interpolate"
        },
        {
          "gnx": "felix.20241228192145.1",
          "vh": "loadImage"
        },
        {
          "gnx": "felix.20250202200500.1",
          "vh": "getDisplaySize"
        },
        {
          "gnx": "felix.20250202202711.1",
          "vh": "debounce"
        }
      ]
    },
    {
      "gnx": "felix.20250107011547.1",
      "vh": "@clean src/config.ts"
    },
    {
      "gnx": "felix.20250125002553.1",
      "vh": "@clean src/shaders.ts"
    }
  ],
  "tnodes": {
    "felix.20241217200720.1": "Basic WebGL RTS game engine\n\nBased on the following tutorials:\n\n- Main features use WebGL concepts such as VAO (Vertex Array Objects), UBO (Uniform Buffer Objects), draw instances, and shaders from the Andrew Adamson WebGL tutorials at https://www.youtube.com/watch?v=-T6EbWCq99c&list=PLPbmjY2NVO_X1U1JzLxLDdRn4NmtxyQQo\n\n- Window resize detection and handling for canvas from https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n\n- Game class setup inspired by [James Byrde](https://github.com/jamesrehabstudio) tutorials at [https://www.youtube.com/@jamesbyrde3798](https://www.youtube.com/@jamesbyrde3798)\n\n- Timing inspired from the [Glenn Fiedler](https://github.com/gafferongames) tutorial at [https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/)\n\n",
    "felix.20241227202430.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20241227202519.1": "import { Game } from \"./game\";\nimport * as utils from \"./utils\";\n\n",
    "felix.20241227213048.1": "document.addEventListener('DOMContentLoaded', (event) => {\n\n    const loadingText = document.createElement('div');\n    loadingText.classList.add(\"loading-text\");\n    loadingText.textContent = 'Loading...';\n    document.body.appendChild(loadingText);\n\n    const creaturesPromise = utils.loadImage('images/alien.png');\n    const tilesPromise = utils.loadImage('images/plancher-vertical.png');\n    const widgetsPromise = utils.loadImage('images/animated-widget.png');\n\n    Promise.all([creaturesPromise, tilesPromise, widgetsPromise]).then((images) => {\n        document.body.removeChild(loadingText);\n        if (!window.game) {\n            window.game = new Game(images[0], images[1], images[2]);\n\n            // Clean up on unload\n            window.addEventListener('unload', () => {\n                window.game.dispose();\n            });\n        } else {\n            console.error('Game instance already started');\n        }\n    });\n});\n\n",
    "felix.20250131210259.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211056.1": "import { RendererManager } from \"./renderer-manager\";\nimport { UIManager } from \"./ui-manager\";\nimport { InputManager } from \"./input-manager\";\nimport { Behaviors } from \"./behaviors\";\nimport { Entities } from \"./entities\";\nimport { CONFIG } from './config';\nimport { EntityType, TRectangle, TSelectAnim } from \"./types\";\nimport { CameraManager } from \"./camera-manager\";\nimport { TimeManager } from \"./time-manager\";\nimport * as utils from \"./utils\";\n\n",
    "felix.20241227213056.1": "export class Game {\n\n    // Manager classes\n    inputManager: InputManager;\n    rendererManager: RendererManager;\n    uiManager: UIManager;\n    cameraManager: CameraManager;\n    timeManager: TimeManager;\n\n    // Canvas Properties\n    lastDisplayWidth = 0;\n    lastDisplayHeight = 0;\n    canvasElement: HTMLCanvasElement;\n    canvasBoundingRect: DOMRect;\n    gl: WebGL2RenderingContext;\n\n    // Game state Properties\n    gamemap: number[] = [];\n    gameMapChanged = false;\n    started = false;\n    gameAction = 0;    // 0 = none\n    entities!: Entities;\n    entityBehaviors!: Behaviors;\n    selectAnim: [TSelectAnim] = [{\n        x: 0,\n        y: 0,\n        orientation: 0,\n        frameIndex: 0,\n        active: false\n    }];\n    lastScrollX = -1; // initialized at -1 so that we can detect first frame.\n    lastScrollY = -1;\n    lastScreenX = -1;\n    lastScreenY = -1;\n\n    private startGameHandler = this.startGame.bind(this);\n    private handleContextMenu = (event: MouseEvent) => event.preventDefault();\n    private resizeObserver: ResizeObserver;\n\n    @others\n\n}\n\n",
    "felix.20241227213841.1": "constructor(sprites: HTMLImageElement, tiles: HTMLImageElement, widgets: HTMLImageElement) {\n\n    this.canvasElement = document.createElement('canvas');\n    document.body.appendChild(this.canvasElement);\n\n    this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();\n\n    const gl = this.canvasElement.getContext('webgl2');\n    if (gl) {\n        this.gl = gl; // ok, we have a WebGL2 context\n    } else {\n        throw new Error('WebGL2 not supported in this browser'); // Error handling\n    }\n\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n    this.gl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\n    // Prevent right-click context menu\n    this.canvasElement.addEventListener('contextmenu', this.handleContextMenu);\n\n    // Canvas has style width: 100vw; and style height: 100vh; so we need to handle resizes!\n    const debouncedResize = utils.debounce(this.handleCanvasResize.bind(this), 250);\n    this.resizeObserver = new ResizeObserver(debouncedResize);\n    this.resizeObserver.observe(this.canvasElement, { box: 'content-box' });\n\n    this.timeManager = new TimeManager(\n        CONFIG.GAME.TIMING.TICK_RATE,\n        CONFIG.GAME.TIMING.ANIM_RATE,\n        CONFIG.GAME.TIMING.FPS_UPDATE_INTERVAL\n    );\n    this.cameraManager = new CameraManager(this);\n    this.rendererManager = new RendererManager(this.gl, tiles, sprites, widgets);\n    this.inputManager = new InputManager(this);\n    this.resizeCanvasToDisplaySize(this.canvasElement);\n    this.uiManager = new UIManager();\n    this.uiManager.mainMenu();\n    this.uiManager.getStartButtonElement().addEventListener(\"click\", this.startGameHandler);\n}\n\n",
    "felix.20250202181151.1": "dispose(): void {\n    this.rendererManager.dispose();\n    this.canvasElement.removeEventListener('contextmenu', this.handleContextMenu);\n    this.uiManager.getStartButtonElement().removeEventListener(\"click\", this.startGameHandler);\n    this.resizeObserver.unobserve(this.canvasElement);\n    this.resizeObserver.disconnect();\n    this.inputManager.dispose();\n}\n\n",
    "felix.20241227213217.1": "handleCanvasResize(entries: ResizeObserverEntry[]): void {\n    for (const entry of entries) {\n        const { width: displayWidth, height: displayHeight } = utils.getDisplaySize(entry);\n        this.lastDisplayWidth = displayWidth;\n        this.lastDisplayHeight = displayHeight;\n        this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();\n        this.cameraManager.updateProperties(this.canvasBoundingRect);\n    }\n}\n\n",
    "felix.20241228191055.1": "resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {\n    const displayWidth = this.lastDisplayWidth;\n    const displayHeight = this.lastDisplayHeight;\n\n    const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n    if (needResize) {\n        // Set the canvas dimensions to the display size\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n\n        // Set the viewport to fill the canvas\n        this.gl.viewport(0, 0, canvas.width, canvas.height); // This will also clear the canvas  \n        if (this.rendererManager && this.rendererManager.worldBuffer) {\n            this.rendererManager.setUboWorldTransforms(this.cameraManager.gameScreenWidth, this.cameraManager.gameScreenHeight);\n        }\n    }\n    return needResize;\n}\n\n",
    "felix.20241229230016.1": "startGame(): void {\n    this.cameraManager.setResolution(CONFIG.DISPLAY.RESOLUTIONS[this.uiManager.getResolutionSelectElement().selectedIndex]);\n    this.cameraManager.updateProperties(this.canvasBoundingRect);\n    this.rendererManager.setUboWorldTransforms(this.cameraManager.gameScreenWidth, this.cameraManager.gameScreenHeight);\n\n    this.uiManager.setCursor(\"cur-pointer\");\n    this.inputManager.init();\n\n    this.uiManager.getStartButtonElement().style.display = 'none';\n    this.uiManager.getResolutionSelectElement().style.display = 'none';\n\n    this.initGameStates();\n    this.started = true;\n    this.timeManager.lastTime = performance.now();\n    setInterval(() => { this.checkUpdate(); }, 500); // Setup timer in case RAF Skipped when minimized\n    this.loop(0);\n}\n\n",
    "felix.20250105213621.1": "initGameStates(): void {\n    this.entities = new Entities(100);\n    this.entityBehaviors = new Behaviors(this);\n\n    // Fill Entities pool\n    // EXPERIMENTAL TEST: Create 3 test Aliens\n    const alien1 = this.entities.spawn();\n    alien1.type = EntityType.ALIEN;\n    alien1.hitPoints = 100;\n    alien1.x = 1100;\n    alien1.y = 1100;\n    alien1.frameIndex = 33;\n    alien1.orientation = 6;\n\n    const alien2 = this.entities.spawn();\n    alien2.type = EntityType.ALIEN;\n    alien2.hitPoints = 100;\n    alien2.x = 0;\n    alien2.y = 0;\n    alien2.frameIndex = 212;\n    alien2.orientation = 5;\n\n    const alien3 = this.entities.spawn();\n    alien3.type = EntityType.ALIEN;\n    alien3.hitPoints = 100;\n    alien3.x = 455;\n    alien3.y = 455;\n    alien3.frameIndex = 122;\n    alien3.orientation = 14;\n\n    // Build Map (Will later be bigger maps loaded from file)\n    // Use Config.GAME.MAP.WIDTH and Config.GAME.MAP.HEIGHT\n    // For now, just fill with random tiles\n    this.gamemap = []; // AS a linear array of size Config.GAME.MAP.WIDTH * Config.GAME.MAP.HEIGHT\n    for (let i = 0; i < CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.MAP.HEIGHT; i++) {\n        this.gamemap.push(Math.floor(Math.random() * 16));\n    }\n}\n\n",
    "felix.20241230215224.1": "procGame(): void {\n\n    // procgame processes a game frame, animating each RAF.\n    // Note: This is not a game-states tick, at timePerTick intervals.\n\n    if (this.gameAction) {\n\n        switch (this.gameAction) {\n            case CONFIG.GAME.ACTIONS.DEFAULT:\n                this.defaultAction();\n                break;\n            case CONFIG.GAME.ACTIONS.RELEASESEL:\n                this.selectUnits();\n                break;\n\n            default:\n                break;\n        }\n\n    }\n\n    this.gameAction = 0; // -------------- no more game actions to do\n\n    this.inputManager.processInputs(); // So far this scrolls the map only\n\n}\n\n",
    "felix.20241227213236.1": "update(timestamp: number, skipRender?: boolean): void {\n\n    // TODO : This mixes rendering and logic. Consider separating these concerns more clearly.\n\n    // 1. Update time\n    const deltaTime = this.timeManager.update(timestamp);\n\n    // 2. Process immediate inputs/actions\n    this.procGame();\n\n    // 3. Update animations if needed\n    if (this.timeManager.shouldAnimUpdate()) {\n        this.uiManager.animateCursor();\n    }\n\n    // 4. Update game logic if needed\n    if (this.timeManager.shouldTickUpdate()) {\n        this.tick();\n    }\n\n    // 5. Render\n    if (!skipRender) {\n        // Before rendering, resize canvas to display size. (in case of changing window size)\n        this.resizeCanvasToDisplaySize(this.canvasElement)\n\n        const visibleTiles: [number, number, number][] = []; // X, Y and Tile Index\n        // If camera did not move nor zoom, we can reuse the last visible tiles by leaving visibleTiles empty.\n        if (\n            this.gameMapChanged ||\n            this.cameraManager.scrollX !== this.lastScrollX ||\n            this.cameraManager.scrollY !== this.lastScrollY ||\n            this.cameraManager.gameScreenWidth !== this.lastScreenX ||\n            this.cameraManager.gameScreenHeight !== this.lastScreenY\n        ) {\n            // Save for next frame to check if camera moved.\n            this.lastScreenX = this.cameraManager.gameScreenWidth;\n            this.lastScreenY = this.cameraManager.gameScreenHeight;\n            this.lastScrollX = this.cameraManager.scrollX;\n            this.lastScrollY = this.cameraManager.scrollY;\n            this.gameMapChanged = false;\n            const tilesize = CONFIG.GAME.TILE.SIZE;\n            const tileoffx = Math.floor(this.lastScrollX / tilesize);\n            const tileoffy = Math.floor(this.lastScrollY / tilesize);\n            let rangex = (this.lastScreenX / tilesize) + 1;\n            let rangey = (this.lastScreenY / tilesize) + 1;\n            if (this.lastScrollX % tilesize > tilesize - (this.lastScreenX % tilesize)) {\n                rangex += 1;\n            }\n            if (this.lastScrollY % tilesize > tilesize - (this.lastScreenY % tilesize)) {\n                rangey += 1;\n            }\n            for (let y = 0; y < rangey; y++) {\n                for (let x = 0; x < rangex; x++) {\n                    const a = this.gamemap[(tileoffx + x) + ((tileoffy + y) * (CONFIG.GAME.MAP.WIDTH))];\n                    visibleTiles.push(\n                        [x * tilesize - (this.lastScrollX % tilesize),\n                        y * tilesize - (this.lastScrollY % tilesize),\n                            a]\n                    );\n\n                }\n            }\n        }\n\n        // Selection lines with four thin rectangles, if user is selecting.\n        const cursor: TRectangle[] = [];\n        if (this.inputManager.isSelecting) {\n            // Draw selection rectangle with lines\n            const cx1 = Math.min(this.inputManager.selX, this.inputManager.mouseX);\n            const cx2 = Math.max(this.inputManager.selX, this.inputManager.mouseX);\n            const cy1 = Math.min(this.inputManager.selY, this.inputManager.mouseY);\n            const cy2 = Math.max(this.inputManager.selY, this.inputManager.mouseY);\n            const thicknes = 2 / this.cameraManager.zoom; // Divide by zoom to keep thickness constant\n            cursor.push(\n                // Top, bottom, left, right lines\n                { x: cx1, y: cy1, width: cx2 - cx1, height: thicknes, r: 0, g: 1, b: 0, },\n                { x: cx1, y: cy2, width: cx2 - cx1, height: thicknes, r: 0, g: 1, b: 0, },\n                { x: cx1, y: cy1, width: thicknes, height: cy2 - cy1, r: 0, g: 1, b: 0, },\n                { x: cx2, y: cy1, width: thicknes, height: cy2 - cy1, r: 0, g: 1, b: 0, }\n            );\n        }\n\n        // Animated selection widget, if any. Uses same renderer and texture as sprites.\n        const visibleWidgets: [number, number, number, number][] = []; // X, Y and Tile Index\n        if (this.uiManager.widgetAnim > 0) {\n            visibleWidgets.push([\n                this.uiManager.widgetAnimX - this.cameraManager.scrollX,\n                this.uiManager.widgetAnimY - this.cameraManager.scrollY,\n                this.uiManager.widgetAnim + 3, // 0-3 are other, animate 6 frames from 4 to 9.\n                CONFIG.GAME.WIDGETS.SIZE / this.cameraManager.zoom\n            ]);\n        } else {\n            // this.selectAnim[0].active = false;\n        }\n\n        this.rendererManager.render(\n            visibleTiles,\n            this.entities.pool,\n            cursor,\n            visibleWidgets,\n            this.cameraManager,\n            this.timeManager.getInterpolation()\n        );\n    }\n\n    // 6. FPS\n    this.timeManager.updateFps(timestamp, deltaTime);\n}\n\n",
    "felix.20241229162229.1": "checkUpdate(): void {\n    // Checks for needed ticks to be computed if game is minimized\n    const timestamp = performance.now();\n    if (this.timeManager.needCatchUp(timestamp)) {\n        this.update(timestamp, true);\n    }\n}\n\n",
    "felix.20241230215229.1": "tick(): void {\n    // Advance game states in pool from currentTick count, to the next one.\n    let processed = 0;\n    let entity;\n    for (let i = 0; processed < this.entities.active || i < this.entities.total; i++) {\n        entity = this.entities.pool[i];\n        if (entity.active) {\n            processed += 1;\n            this.entityBehaviors.process(entity);\n        }\n    }\n}\n\n",
    "felix.20241229214656.1": "loop(timestamp: number): void {\n    this.update(timestamp);\n    requestAnimationFrame(this.loop.bind(this));\n}\n\n",
    "felix.20241230215401.1": "defaultAction(): void {\n    const gamePosition = this.inputManager.gamePosition;\n\n    // TODO : Replace test cursor animation with the real default action\n    // FOR NOW: START WIDGET ANIMATION ON DEFAULT ACTION\n    this.uiManager.widgetAnim = 1;\n    this.uiManager.widgetAnimX = gamePosition.x - (32 / this.cameraManager.zoom);\n    this.uiManager.widgetAnimY = gamePosition.y - (32 / this.cameraManager.zoom);\n}\n\n",
    "felix.20241230215406.1": "selectUnits(): void {\n\n    // Called from procGame\n    const selectionStart = this.inputManager.selectionStart;\n    const selectionEnd = this.inputManager.selectionEnd;\n\n    console.log('select', selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);\n    // TODO : Add selection logic here\n\n}\n\n",
    "felix.20250208202349.1": "setTileAt(gameMouseX: number, gameMouseY: number, tileIndex: number): void {\n    // Replace tile in gameMap at gameMouseX, gameMouseY with tileIndex\n    // First, convert the gameMouseX, gameMouseY to tile index in the gameMap array, its a single linear array.\n    // So we need to know the tile size, and the scroll position.\n    const tilesize = CONFIG.GAME.TILE.SIZE;\n    const tileoffx = Math.floor(this.cameraManager.scrollX / tilesize);\n    const tileoffy = Math.floor(this.cameraManager.scrollY / tilesize);\n    const x = Math.floor((gameMouseX + this.cameraManager.scrollX) / tilesize) - tileoffx;\n    const y = Math.floor((gameMouseY + this.cameraManager.scrollY) / tilesize) - tileoffy;\n    const index = x + (y * CONFIG.GAME.MAP.WIDTH);\n    this.gamemap[index] = tileIndex;\n    this.gameMapChanged = true;\n}\n\n",
    "felix.20250208205929.1": "sampleTileAt(gameMouseX: number, gameMouseY: number): void {\n    // This is the opposite of setTileAt, it samples the tile at gameMouseX, gameMouseY\n    // and sets the UI to the selected tile.\n    const tilesize = CONFIG.GAME.TILE.SIZE;\n    const tileoffx = Math.floor(this.cameraManager.scrollX / tilesize);\n    const tileoffy = Math.floor(this.cameraManager.scrollY / tilesize);\n    const x = Math.floor((gameMouseX + this.cameraManager.scrollX) / tilesize) - tileoffx;\n    const y = Math.floor((gameMouseY + this.cameraManager.scrollY) / tilesize) - tileoffy;\n    const index = x + (y * CONFIG.GAME.MAP.WIDTH);\n    this.uiManager.setTileSelectIndex(this.gamemap[index]);\n}\n\n",
    "felix.20250131210715.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211201.1": "import { Game } from \"./game\";\nimport { CONFIG } from './config';\n\n",
    "felix.20250107221804.1": "export class InputManager {\n    private game: Game;\n    private keysPressed: Record<string, boolean> = {};\n    private selecting: boolean = false;\n    public mouseX = 0;\n    public mouseY = 0;\n    private gameMouseX = 0;\n    private gameMouseY = 0;\n    public selX = 0;\n    public selY = 0;\n    private gameSelStartX = 0;\n    private gameSelStartY = 0;\n    private gameSelEndX = 0;\n    private gameSelEndY = 0;\n    private scrollNowX = 0;\n    private scrollNowY = 0;\n\n    private keyboardUp = false;\n    private keyboardDown = false;\n    private keyboardLeft = false;\n    private keyboardRight = false;\n\n    private keyDownHandler = this.handleKeyDown.bind(this);\n    private keyUpHandler = this.handleKeyUp.bind(this);\n    private mouseMoveHandler = this.handleMouseMove.bind(this);\n    private mouseDownHandler = this.handleMouseDown.bind(this);\n    private mouseUpHandler = this.handleMouseUp.bind(this);\n    private mouseWheelHandler = this.handleMouseWheel.bind(this);\n\n    @others\n\n}\n\n",
    "felix.20250107221855.1": "constructor(game: Game) {\n    this.game = game;\n}\n\n",
    "felix.20250107232140.1": "get gamePosition(): { x: number, y: number } {\n    return { x: this.gameMouseX, y: this.gameMouseY };\n}\n\nget selectionStart(): { x: number, y: number } {\n    return { x: this.gameSelStartX, y: this.gameSelStartY };\n}\n\nget selectionEnd(): { x: number, y: number } {\n    return { x: this.gameSelEndX, y: this.gameSelEndY };\n}\n\nget scrollVelocity(): { dx: number, dy: number } {\n    return { dx: this.scrollNowX, dy: this.scrollNowY };\n}\n\n",
    "felix.20250107230733.1": "init(): void {\n    window.addEventListener(\"keydown\", this.keyDownHandler);\n    window.addEventListener(\"keyup\", this.keyUpHandler);\n    window.addEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.addEventListener(\"mousedown\", this.mouseDownHandler);\n    window.addEventListener(\"mouseup\", this.mouseUpHandler);\n    window.addEventListener(\"wheel\", this.mouseWheelHandler, { passive: false });\n}\n\n",
    "felix.20250202204636.1": "dispose(): void {\n    window.removeEventListener(\"keydown\", this.keyDownHandler);\n    window.removeEventListener(\"keyup\", this.keyUpHandler);\n    window.removeEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.removeEventListener(\"mousedown\", this.mouseDownHandler);\n    window.removeEventListener(\"mouseup\", this.mouseUpHandler);\n    window.removeEventListener(\"wheel\", this.mouseWheelHandler);\n}\n\n",
    "felix.20250107230755.1": "private handleKeyDown(e: KeyboardEvent): void {\n    this.keysPressed[e.key] = true;\n    if (e.key === 'F10') {\n        e.preventDefault();\n        // For now, open the map editor instead of the options menu.\n        this.game.uiManager.toggleMapEditor();\n        // this.game.uiManager.toggleGameMenu();\n        return\n    }\n    if (e.ctrlKey && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '_')) {\n        e.preventDefault();\n    }\n}\n\n",
    "felix.20250107230802.1": "private handleKeyUp(e: KeyboardEvent): void {\n    this.keysPressed[e.key] = false;\n}\n\n",
    "felix.20250107230806.1": "private handleMouseMove(event?: MouseEvent): void {\n    if (event) {\n        this.setCursorPos(event);\n    }\n    this.scrollNowX = 0;\n    this.scrollNowY = 0;\n\n    if (this.mouseX > this.game.cameraManager.scrollEdgeX) {\n        this.scrollNowX = CONFIG.DISPLAY.SCROLL.SPEED;\n    }\n    if (this.mouseY > this.game.cameraManager.scrollEdgeY) {\n        this.scrollNowY = CONFIG.DISPLAY.SCROLL.SPEED;\n    }\n    if (this.mouseX < CONFIG.DISPLAY.SCROLL.BORDER) {\n        this.scrollNowX = -CONFIG.DISPLAY.SCROLL.SPEED;\n    }\n    if (this.mouseY < CONFIG.DISPLAY.SCROLL.BORDER) {\n        this.scrollNowY = -CONFIG.DISPLAY.SCROLL.SPEED;\n    }\n}\n\n",
    "felix.20250107230811.1": "private handleMouseDown(event: MouseEvent): void {\n    this.setCursorPos(event);\n    if (this.game.uiManager.isMapEditorVisible()) {\n\n        if (event.button === 0) {\n            // left\n            // Replace the clicked tile on the map with the selected tile in the map editor.\n            const tileIndex = this.game.uiManager.getSelectedTileIndex();\n            this.game.setTileAt(this.gameMouseX, this.gameMouseY, tileIndex);\n        }\n        if (event.button === 2) {\n            // right mouse is like the eyedropper tool.\n            // Sample the tile index at the clicked position to select it in the map editor.\n            this.game.sampleTileAt(this.gameMouseX, this.gameMouseY);\n        }\n        return;\n    }\n    if (!this.selecting) {\n        if (event.button === 0) {\n            this.selecting = true;\n            this.selX = this.mouseX;\n            this.selY = this.mouseY;\n            this.gameSelStartX = this.selX + this.game.cameraManager.scrollX;\n            this.gameSelStartY = this.selY + this.game.cameraManager.scrollY;\n            this.game.uiManager.setCursor('cur-target');\n        }\n        if (event.button === 2) {\n            this.game.gameAction = CONFIG.GAME.ACTIONS.DEFAULT;\n        }\n    }\n}\n\n",
    "felix.20250107230817.1": "private handleMouseUp(event: MouseEvent): void {\n    this.setCursorPos(event);\n    if (this.game.uiManager.isMapEditorVisible()) {\n        // Specific to when the map editor is visible.\n        return;\n    }\n    if (event.button === 0) {\n        this.gameSelEndX = this.mouseX + this.game.cameraManager.scrollX;\n        this.gameSelEndY = this.mouseY + this.game.cameraManager.scrollY;\n        this.selecting = false;\n        this.game.gameAction = CONFIG.GAME.ACTIONS.RELEASESEL;\n        this.game.uiManager.setCursor('cur-pointer');\n    }\n}\n\n",
    "felix.20250107230822.1": "private handleMouseWheel(event: WheelEvent): void {\n    if (event.ctrlKey) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    if (this.selecting) {\n        return; // Do not zoom while selecting\n    }\n    if (event.deltaY < 0) {\n        this.game.cameraManager.zoomIn(this.mouseX, this.mouseY);\n    } else if (event.deltaY > 0) {\n        this.game.cameraManager.zoomOut(this.mouseX, this.mouseY);\n    }\n}\n\n",
    "felix.20250107230828.1": "private setCursorPos(event: MouseEvent): void {\n    this.mouseX = event.clientX * (this.game.cameraManager.gameScreenWidth / this.game.canvasBoundingRect.width);\n    this.mouseY = event.clientY * (this.game.cameraManager.gameScreenHeight / this.game.canvasBoundingRect.height);\n    this.gameMouseX = this.mouseX + this.game.cameraManager.scrollX;\n    this.gameMouseY = this.mouseY + this.game.cameraManager.scrollY;\n}\n\n",
    "felix.20250107230906.1": "processInputs(): void {\n    if (this.keysPressed['ArrowUp'] || this.keysPressed['w']) {\n        this.scrollNowY = -CONFIG.DISPLAY.SCROLL.SPEED;\n        this.keyboardUp = true\n    } else if (this.keyboardUp) {\n        this.keyboardUp = false;\n        this.scrollNowY = 0;\n        this.handleMouseMove();\n    }\n    if (this.keysPressed['ArrowDown'] || this.keysPressed['s']) {\n        this.scrollNowY = CONFIG.DISPLAY.SCROLL.SPEED;\n        this.keyboardDown = true\n    } else if (this.keyboardDown) {\n        this.keyboardDown = false;\n        this.scrollNowY = 0;\n        this.handleMouseMove();\n    }\n    if (this.keysPressed['ArrowLeft'] || this.keysPressed['a']) {\n        this.scrollNowX = -CONFIG.DISPLAY.SCROLL.SPEED;\n        this.keyboardLeft = true\n    } else if (this.keyboardLeft) {\n        this.keyboardLeft = false;\n        this.scrollNowX = 0;\n        this.handleMouseMove();\n    }\n    if (this.keysPressed['ArrowRight'] || this.keysPressed['d']) {\n        this.scrollNowX = CONFIG.DISPLAY.SCROLL.SPEED;\n        this.keyboardRight = true\n    } else if (this.keyboardRight) {\n        this.keyboardRight = false;\n        this.scrollNowX = 0;\n        this.handleMouseMove();\n    }\n\n    // Scroll if not currently dragging a selection.\n    if (!this.selecting) {\n        this.game.cameraManager.scroll(this.scrollVelocity);\n    }\n}\n\n",
    "felix.20250107230936.1": "get isSelecting(): boolean {\n    return this.selecting;\n}\n\n",
    "felix.20250201003719.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250201003821.1": "import { TileRenderer, SpriteRenderer, RectangleRenderer, WidgetRenderer } from \"./renderers\";\nimport { CONFIG } from \"./config\";\nimport { TEntity, TRectangle, TSelectAnim } from \"./types\";\nimport { CameraManager } from \"./camera-manager\";\n\n",
    "felix.20250201171432.1": "export class RendererManager {\n\n    worldBuffer: WebGLBuffer;\n\n    private gl: WebGL2RenderingContext;\n    private tileRenderer: TileRenderer;\n    private widgetRenderer: WidgetRenderer;\n    private spriteRenderer: SpriteRenderer;\n    private rectangleRenderer: RectangleRenderer;\n    private static readonly WORLD_BINDING_POINT = 0;\n\n    @others\n\n}\n\n",
    "felix.20250201171528.1": "constructor(gl: WebGL2RenderingContext, tilesImage: HTMLImageElement, creaturesImage: HTMLImageElement, widgetsImage: HTMLImageElement) {\n    this.gl = gl;\n    this.tileRenderer = new TileRenderer(this.gl, tilesImage, CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.MAP.HEIGHT);\n    this.widgetRenderer = new WidgetRenderer(this.gl, widgetsImage, CONFIG.GAME.WIDGETS.MAX);\n    this.spriteRenderer = new SpriteRenderer(this.gl, creaturesImage, CONFIG.GAME.ENTITY.INITIAL_POOL_SIZE);\n    this.rectangleRenderer = new RectangleRenderer(this.gl, CONFIG.GAME.RECTANGLES.MAX);\n    this.worldBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, this.worldBuffer);\n    this.gl.bufferData(this.gl.UNIFORM_BUFFER, 2 * Float32Array.BYTES_PER_ELEMENT, this.gl.DYNAMIC_DRAW);\n    this.initUboBindings();\n}\n\n",
    "felix.20250205232454.1": "private initUboBindings(): void {\n    // Bind all shaders to the same binding point\n    const programs = [\n        this.tileRenderer.program,\n        this.widgetRenderer.program,\n        this.spriteRenderer.program,\n        this.rectangleRenderer.program\n    ].filter((p): p is WebGLProgram => p != null);\n\n    for (const program of programs) {\n        const blockIndex = this.gl.getUniformBlockIndex(program, 'World');\n        this.gl.uniformBlockBinding(program, blockIndex, RendererManager.WORLD_BINDING_POINT);\n    }\n\n    // Bind the buffer once\n    this.gl.bindBufferBase(\n        this.gl.UNIFORM_BUFFER,\n        RendererManager.WORLD_BINDING_POINT,\n        this.worldBuffer\n    );\n}\n\n",
    "felix.20250201171626.1": "setUboWorldTransforms(gameScreenWidth: number, gameScreenHeight: number): void {\n    // Update the uniform buffer with current world transform values.\n    const worldData = new Float32Array([2 / gameScreenWidth, 2 / -gameScreenHeight]);\n    this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, this.worldBuffer);\n    this.gl.bufferSubData(this.gl.UNIFORM_BUFFER, 0, worldData);\n}\n\n",
    "felix.20250201171643.1": "render(\n    visibleTiles: [number, number, number][],\n    entitiesPool: TEntity[],\n    selectionRectangles: TRectangle[],\n    visibleWidgets: [number, number, number, number][],\n    camera: CameraManager,\n    interpolation: number\n): void {\n\n    // TODO : Use interpolation for smooth rendering.\n\n    // Clear canvas before rendering.\n    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Render tile layer.\n    if (visibleTiles.length) {\n        // Update tile transform data if needed.\n        this.tileRenderer.updateTransformData(visibleTiles);\n    }\n    this.tileRenderer.render(); // Do render the last frame's tiles if no tiles are visible.\n\n    // Render sprites.\n    this.spriteRenderer.updateTransformData(entitiesPool, camera);\n    this.spriteRenderer.render();\n\n    // Render fog of war, if any.\n    // TODO: Implement Fog of War at some point :)\n\n    // Render selection rectangles, if any.\n    if (selectionRectangles.length) {\n        this.rectangleRenderer.updateTransformData(selectionRectangles);\n        this.rectangleRenderer.render();\n    }\n\n    // Render selection animations, if any.\n    if (visibleWidgets.length) {\n        // Update tile transform data if needed.\n        this.widgetRenderer.updateTransformData(visibleWidgets);\n        this.widgetRenderer.render();\n    }\n\n    this.gl.flush();\n}\n\n",
    "felix.20250201171639.1": "dispose(): void {\n    this.tileRenderer.dispose();\n    this.spriteRenderer.dispose();\n    this.rectangleRenderer.dispose();\n    this.widgetRenderer.dispose();\n}\n",
    "felix.20250201003723.1": "@others\n@nowrap\n",
    "felix.20250201205415.1": "import { CONFIG } from \"./config\";\n\nexport class UIManager {\n\n    // Command Acknowledged Widget Animation Properties\n    widgetAnim: number = 0;\n    widgetAnimTotal: number = 6;\n    widgetAnimX: number = 0;\n    widgetAnimY: number = 0;\n\n    private startButtonElement: HTMLButtonElement;\n    private resolutionSelectElement: HTMLSelectElement;\n    private documentElementClassList: DOMTokenList; // Css rules rely on this to change cursor.\n    private currentCursorClass: string = \"\"; // Mouse Cursor: cur-pointer, cur-target..\n\n    // Map Editor properties\n    private mapEditorElement: HTMLDivElement | null = null;\n    private tilePreview: HTMLDivElement | null = null;\n    private tileInput: HTMLInputElement | null = null;\n    private currentTileIndex: number = 0; // between 0 and 63\n\n    @others\n\n}\n\n",
    "felix.20250201205647.1": "constructor() {\n    this.documentElementClassList = document.documentElement.classList;\n    this.startButtonElement = document.createElement(\"button\");\n    this.resolutionSelectElement = document.createElement(\"select\");\n}\n\n",
    "felix.20250201205642.1": "mainMenu(): void {\n    // Create the start button\n    this.startButtonElement.textContent = \"Start Game\";\n    this.startButtonElement.classList.add(\"btn-start\");\n    document.body.appendChild(this.startButtonElement);\n\n    // Create the dropdown for screen resolution\n    this.resolutionSelectElement.classList.add(\"resolution-select\");\n\n    // Populate the dropdown with options\n    for (const { label, width, height } of CONFIG.DISPLAY.RESOLUTIONS) {\n        const option = document.createElement(\"option\");\n        option.value = `${width}x${height}`;\n        option.textContent = label;\n        this.resolutionSelectElement.appendChild(option);\n    }\n    document.body.appendChild(this.resolutionSelectElement);\n}\n\n",
    "felix.20250201205637.1": "setCursor(newClass: string): void {\n    if (this.currentCursorClass !== newClass) {\n        if (this.currentCursorClass) {\n            this.documentElementClassList.remove(this.currentCursorClass);\n        }\n        this.documentElementClassList.add(newClass);\n        this.currentCursorClass = newClass;\n    }\n}\n\n",
    "felix.20250201205632.1": "toggleGameMenu(): void {\n    console.log('Toggle Options Menu');\n    // Further implementation for an in-game options menu.\n}\n\n",
    "felix.20250201205627.1": "animateCursor(): void {\n    if (this.widgetAnim) {\n        this.widgetAnim += 1;\n        if (this.widgetAnim > this.widgetAnimTotal) {\n            this.widgetAnim = 0;\n        }\n    }\n}\n\n",
    "felix.20250201205615.1": "getStartButtonElement(): HTMLButtonElement {\n    return this.startButtonElement;\n}\n\n",
    "felix.20250201205555.1": "getResolutionSelectElement(): HTMLSelectElement {\n    return this.resolutionSelectElement;\n}\n\n",
    "felix.20250208194821.1": "toggleMapEditor(): void {\n    if (!this.mapEditorElement) {\n        this.buildMapEditor();\n    } else {\n        // Toggle visibility\n        if (this.mapEditorElement.style.display === \"none\" || this.mapEditorElement.style.display === \"\") {\n            this.mapEditorElement.style.display = \"block\";\n        } else {\n            this.mapEditorElement.style.display = \"none\";\n        }\n    }\n}\n\n",
    "felix.20250208194831.1": "isMapEditorVisible(): boolean {\n    return this.mapEditorElement !== null &&\n        (this.mapEditorElement.style.display === \"block\");\n}\n\n",
    "felix.20250208194839.1": "getSelectedTileIndex(): number {\n    return this.currentTileIndex;\n}\n\n",
    "felix.20250208194845.1": "private buildMapEditor(): void {\n    // Create the map editor container\n    this.mapEditorElement = document.createElement(\"div\");\n    this.mapEditorElement.id = \"map-editor\";\n    Object.assign(this.mapEditorElement.style, {\n        position: \"absolute\",\n        top: \"10px\",\n        right: \"10px\",\n        width: \"130px\",\n        height: \"160px\",\n        textAlign: \"center\",\n        backgroundColor: \"#ccc\",\n        border: \"1px solid #333\",\n        padding: \"10px\",\n        zIndex: \"10\",\n        cursor: \"move\",\n        display: \"block\",\n    });\n\n    // Create tile preview element using the atlas (using background positioning)\n    this.tilePreview = document.createElement(\"div\");\n    Object.assign(this.tilePreview.style, {\n        width: \"128px\",\n        height: \"128px\",\n        backgroundImage: \"url('images/plancher-vertical.png')\",\n        backgroundRepeat: \"no-repeat\",\n        cursor: \"default\",\n        marginBottom: \"10px\",\n        border: \"1px solid #333\",\n    });\n    this.updateTilePreview();\n\n    // Create Up and Down buttons\n    const upButton = document.createElement(\"button\");\n    upButton.textContent = \"▲\";\n    upButton.addEventListener(\"click\", () => {\n        this.currentTileIndex = (this.currentTileIndex + 1) % 64;\n        this.updateTilePreview();\n        if (this.tileInput) {\n            this.tileInput.value = this.currentTileIndex.toString();  // sync with input\n        }\n    });\n\n    const downButton = document.createElement(\"button\");\n    downButton.textContent = \"▼\";\n    downButton.addEventListener(\"click\", () => {\n        this.currentTileIndex = (this.currentTileIndex - 1 + 64) % 64;\n        this.updateTilePreview();\n        if (this.tileInput) {\n            this.tileInput.value = this.currentTileIndex.toString();  // sync with input\n        }\n    });\n\n    // Create number input to manually select tile index\n    this.tileInput = document.createElement(\"input\");\n    this.tileInput.type = \"number\";\n    this.tileInput.min = \"0\";\n    this.tileInput.max = \"63\";\n    this.tileInput.value = this.currentTileIndex.toString();\n    this.tileInput.addEventListener(\"change\", () => {\n        if (this.tileInput) {\n            console.log('digit changed', this.tileInput.value);\n            const newValue = parseInt(this.tileInput.value, 10);\n            if (!isNaN(newValue) && newValue >= 0 && newValue < 64) {\n                this.currentTileIndex = newValue;\n                this.updateTilePreview();\n            }\n        }\n    });\n\n    // Append elements to map editor container\n    this.mapEditorElement.appendChild(this.tilePreview);\n    this.mapEditorElement.appendChild(upButton);\n    this.mapEditorElement.appendChild(downButton);\n    this.mapEditorElement.appendChild(this.tileInput);\n\n    // Append the map editor container to the document body\n    document.body.appendChild(this.mapEditorElement);\n\n    // Make the map editor draggable\n    this.addDragElement(this.mapEditorElement);\n}\n\n",
    "felix.20250208204757.1": "private addDragElement(elm: HTMLElement): void {\n    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n\n    elm.addEventListener(\"mousedown\", dragMouseDown);\n\n    const self = this; // if needed for future reference\n\n    function dragMouseDown(e: MouseEvent): void {\n        // Only drad if mouse event is directly on the mapEditorElement, not on the buttons or input.\n        if (e.target !== elm) {\n            return;\n        }\n\n\n        e.preventDefault();\n        // get the mouse cursor position at startup:\n        pos3 = e.clientX;\n        pos4 = e.clientY;\n        document.addEventListener(\"mouseup\", closeDragElement);\n        document.addEventListener(\"mousemove\", elementDrag);\n    }\n\n    function elementDrag(e: MouseEvent): void {\n        e.preventDefault();\n        // calculate the new cursor position:\n        pos1 = pos3 - e.clientX;\n        pos2 = pos4 - e.clientY;\n        pos3 = e.clientX;\n        pos4 = e.clientY;\n        // set the element's new position:\n        elm.style.top = (elm.offsetTop - pos2) + \"px\";\n        elm.style.left = (elm.offsetLeft - pos1) + \"px\";\n    }\n\n    function closeDragElement(): void {\n        // stop moving when mouse button is released:\n        document.removeEventListener(\"mouseup\", closeDragElement);\n        document.removeEventListener(\"mousemove\", elementDrag);\n    }\n}\n",
    "felix.20250208194855.1": "private updateTilePreview(): void {\n    if (this.tilePreview) {\n        // Calculate background position so that the preview shows only the selected tile.\n        // Assuming vertical stacking: the Y offset is negative (tileIndex * 128)\n        this.tilePreview.style.backgroundPosition = `0px -${this.currentTileIndex * 128}px`;\n        // Optionally adjust background size if your atlas image size differs.\n        this.tilePreview.style.backgroundSize = \"128px 8192px\";\n    }\n}\n",
    "felix.20250208231505.1": "setTileSelectIndex(index: number): void {\n    this.currentTileIndex = index;\n\n    this.updateTilePreview();\n}\n\n",
    "felix.20250201003723.2": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250201003827.1": "import { CONFIG } from './config';\nimport { Game } from './game';\n\n",
    "felix.20250201233259.1": "export class CameraManager {\n    resolution: { label: string; width: number; height: number };\n    aspectRatio: number;\n    gameScreenWidth: number;\n    gameScreenHeight: number;\n    scrollEdgeX: number;\n    scrollEdgeY: number;\n    zoom: number;\n    gameWidthRatio: number;\n    gameHeightRatio: number;\n    initRangeX: number;\n    initRangeY: number;\n    game: Game;\n\n    scrollX = 0;\n    scrollY = 0;\n    maxScrollX: number;\n    maxScrollY: number;\n    minZoom = 0.5;\n    maxZoom = 2;\n    readonly maxMapX = (CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.TILE.SIZE) - 1;\n    readonly maxMapY = (CONFIG.GAME.MAP.HEIGHT * CONFIG.GAME.TILE.SIZE) - 1;\n\n    @others\n\n}\n",
    "felix.20250201233355.1": "constructor(game: Game) {\n    this.game = game;\n    this.resolution = CONFIG.DISPLAY.RESOLUTIONS[0];\n    this.zoom = 1;\n    this.aspectRatio = this.resolution.width / this.resolution.height;\n    this.gameScreenWidth = this.resolution.width / this.zoom;\n    this.gameScreenHeight = this.resolution.height / this.zoom;\n    this.initRangeX = (this.gameScreenWidth / CONFIG.GAME.TILE.SIZE) + 1;\n    this.initRangeY = (this.gameScreenHeight / CONFIG.GAME.TILE.SIZE) + 1;\n    this.scrollEdgeX = 0;\n    this.scrollEdgeY = 0;\n    this.gameWidthRatio = 0;\n    this.gameHeightRatio = 0;\n    this.maxScrollX = 0;\n    this.maxScrollY = 0;\n}\n\n",
    "felix.20250201234908.1": "scroll(scrollVelocity: { dx: number, dy: number }): void {\n    this.scrollX += scrollVelocity.dx;\n    this.scrollY += scrollVelocity.dy;\n    if (this.scrollX < 0) { this.scrollX = 0 };\n    if (this.scrollY < 0) { this.scrollY = 0 };\n    if (this.scrollX > this.maxScrollX) { this.scrollX = this.maxScrollX };\n    if (this.scrollY > this.maxScrollY) { this.scrollY = this.maxScrollY };\n}\n\n",
    "felix.20250202002655.1": "setResolution(resolution: { label: string; width: number; height: number }): void {\n    this.resolution = resolution;\n    this.aspectRatio = this.resolution.width / this.resolution.height;\n}\n\n",
    "felix.20250201233351.1": "updateProperties(canvasBoundingRect: DOMRect): void {\n    // Called when the mouse-wheel zoomed in or out, or when the game is started.\n    this.gameScreenWidth = this.resolution.width / this.zoom;\n    this.gameScreenHeight = this.resolution.height / this.zoom;\n    this.scrollEdgeX = this.gameScreenWidth - CONFIG.DISPLAY.SCROLL.BORDER;\n    this.scrollEdgeY = this.gameScreenHeight - CONFIG.DISPLAY.SCROLL.BORDER;\n    this.initRangeX = (this.gameScreenWidth / CONFIG.GAME.TILE.SIZE) + 1;\n    this.initRangeY = (this.gameScreenHeight / CONFIG.GAME.TILE.SIZE) + 1;\n    this.maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;\n    this.maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;\n    this.gameWidthRatio = this.gameScreenWidth / canvasBoundingRect.width;\n    this.gameHeightRatio = this.gameScreenHeight / canvasBoundingRect.height;\n}\n\n",
    "felix.20250201233346.1": "setZoom(zoomLevel: number): void {\n    this.zoom = zoomLevel;\n    this.updateProperties(this.game.canvasBoundingRect); // Updates maxScrollX and maxScrollY\n    this.scroll({ dx: 0, dy: 0 }); // This scroll of 0,0 just limits the scroll values to the maxScroll.\n    this.game.rendererManager.setUboWorldTransforms(this.gameScreenWidth, this.gameScreenHeight); // update world coords\n}\n\n",
    "felix.20250204221504.1": "zoomIn(mouseX: number, mouseY: number) {\n    const oldZoom = this.zoom;\n    const newZoom = Math.min(this.maxZoom, oldZoom * 1.1);\n\n    // Adjust scroll so that the world coordinate under the mouse remains constant.\n    this.scrollX = this.scrollX + (mouseX / oldZoom) - (mouseX / newZoom);\n    this.scrollY = this.scrollY + (mouseY / oldZoom) - (mouseY / newZoom);\n\n    this.zoom = newZoom;\n    this.updateProperties(this.game.canvasBoundingRect); // Updates maxScrollX and maxScrollY\n    this.scroll({ dx: 0, dy: 0 }); // This 'null' scroll just limits the scroll values to the maxScroll.\n    this.game.rendererManager.setUboWorldTransforms(this.gameScreenWidth, this.gameScreenHeight); // update world coords\n}\n\n",
    "felix.20250204221510.1": "zoomOut(mouseX: number, mouseY: number) {\n    const oldZoom = this.zoom;\n    const newZoom = Math.max(this.minZoom, oldZoom / 1.1);\n\n    // Adjust scroll so that the world coordinate under the mouse remains constant.\n    this.scrollX = this.scrollX + (mouseX / oldZoom) - (mouseX / newZoom);\n    this.scrollY = this.scrollY + (mouseY / oldZoom) - (mouseY / newZoom);\n\n    this.zoom = newZoom;\n    this.updateProperties(this.game.canvasBoundingRect); // Updates maxScrollX and maxScrollY\n    this.scroll({ dx: 0, dy: 0 }); // This scroll of 0,0 just limits the scroll values to the maxScroll.\n    this.game.rendererManager.setUboWorldTransforms(this.gameScreenWidth, this.gameScreenHeight); // update world coords\n}\n\n",
    "felix.20250201003723.3": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250201003825.1": "import { CONFIG } from './config';\n\n",
    "felix.20250202011725.1": "export class TimeManager {\n\n    // Ticking\n    tickAccumulator = 0; //\n    currentTick = 0;\n    timePerTick: number;\n    timerTriggerAccum: number;\n\n    // Animations\n    animAccumulator = 0;\n    currentAnim = 0;\n    timePerAnim: number;\n\n    // FPS tracking\n    lastTime = 0; // Initialized by the game at the start of a proper game loop.\n    fps = 0;\n    fpsInterval: number;\n    fpsLastTime = 0;\n\n    @others\n\n    getInterpolation(): number {\n        return this.tickAccumulator / this.timePerTick;\n    }\n\n    needCatchUp(timestamp: number): boolean {\n        const deltaTime = timestamp - this.lastTime;\n        if ((this.tickAccumulator + deltaTime) < this.timerTriggerAccum) {\n            return false;\n        }\n        return true;\n    }\n\n}\n\n",
    "felix.20250202135345.1": "constructor(tickRate: number, animRate: number, fpsInterval: number) {\n    this.timePerTick = 1000 / tickRate;\n    this.timerTriggerAccum = this.timePerTick * 3;\n    this.timePerAnim = 1000 / animRate;\n    this.fpsInterval = fpsInterval;\n}\n\n",
    "felix.20250202135338.1": "update(timestamp: number) {\n    // Check for the very first frame,\n    const deltaTime = timestamp - this.lastTime;\n    this.lastTime = timestamp;\n    this.tickAccumulator += deltaTime;\n    this.animAccumulator += deltaTime;\n    return deltaTime;\n}\n\n",
    "felix.20250202135334.1": "shouldAnimUpdate() {\n    if (this.animAccumulator >= this.timePerAnim) {\n        this.animAccumulator -= this.timePerAnim;\n        this.currentAnim++;\n        return true;\n    }\n    return false;\n}\n\n",
    "felix.20250202135329.1": "shouldTickUpdate() {\n    if (this.tickAccumulator >= this.timePerTick) {\n        this.tickAccumulator -= this.timePerTick;\n        this.currentTick++;\n        return true;\n    }\n    return false;\n}\n\n",
    "felix.20250202135324.1": "updateFps(timestamp: number, deltaTime: number) {\n    if (timestamp - this.fpsLastTime > this.fpsInterval) {\n        this.fps = Math.round(1000 / deltaTime);\n        this.fpsLastTime = timestamp;\n        // console.log('RAF FPS ', this.fps);\n    }\n}\n",
    "felix.20250131210755.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211133.1": "import { TEntity } from \"./types\";\n\n",
    "felix.20250105212000.1": "/**\n * Singleton Entities Object Pool\n */\nexport class Entities {\n\n    total: number;\n    active: number = 0;\n    pool: Array<TEntity> = [];\n\n    private lastId = 0;\n\n    @others\n\n}\n\n",
    "felix.20250105212000.2": "constructor(initialPoolSize: number) {\n    this.total = initialPoolSize;\n    for (let i = 0; i < initialPoolSize; i++) {\n        this.pool.push({\n            id: 0,\n            type: 0,\n            hitPoints: 0,\n            state: 0,\n            x: 0,\n            y: 0,\n            oldX: 0,\n            oldY: 0,\n            orderQty: 0,\n            orderIndex: 0,\n            orderPool: [\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n            ],\n            orientation: 0,\n            frameIndex: 0,\n            active: false,\n        });\n    }\n\n}\n\n",
    "felix.20250105212000.3": "spawn(): TEntity {\n    if (this.active === this.total) {\n        throw new Error(\"Pool Full\");\n    }\n    const entity = this.pool.find(e => !e.active);\n    if (entity) {\n        entity.active = true;\n        entity.id = ++this.lastId;\n        this.active++;\n        return entity;\n    } else {\n        throw new Error(\"Pool Full\");\n    }\n}\n\n",
    "felix.20250105212000.4": "remove(entity: TEntity): void {\n    this.active--;\n    entity.active = false;\n}\n\n",
    "felix.20250131210816.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211212.1": "import { EntityType, TEntity } from \"./types\";\nimport { Game } from \"./game\";\n\n",
    "felix.20250105212047.1": "export class Behaviors {\n\n    game: Game;\n\n    @others\n\n}\n\n",
    "felix.20250105212047.2": "constructor(game: Game) {\n    this.game = game;\n}\n\n",
    "felix.20250105212047.3": "process(entity: TEntity): void {\n    switch (entity.type) {\n        case EntityType.ALIEN:\n            this.alien(entity);\n            break;\n\n        default:\n            break;\n    }\n}\n\n",
    "felix.20250105212047.4": "private alien(entity: TEntity): void {\n    // test by just incrementing forward in animations\n    // 249 is the number of frames in the sprite sheet\n    entity.frameIndex = (entity.frameIndex + 1) % 249;\n    // TODO : Add real behaviors!\n}\n\n",
    "felix.20250131210828.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211216.1": "import { TEntity, GLResources, ShaderType, TRectangle, TSelectAnim } from \"./types\";\nimport { CONFIG } from './config';\nimport { SHADERS } from './shaders';\nimport { CameraManager } from \"./camera-manager\";\n\n",
    "felix.20250126174340.1": "abstract class BaseRenderer {\n\n    program: WebGLProgram;\n\n    protected gl: WebGL2RenderingContext;\n    protected vao: WebGLVertexArrayObject;\n    protected dirtyTransforms: boolean; // Flag to update bufferData from transformData in the render method.\n    protected resources: GLResources = {\n        buffers: [],\n        textures: [],\n        shaders: []\n    };\n\n    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {\n        this.gl = gl;\n        this.program = this.createProgram(vertexShader, fragmentShader);\n        this.gl.useProgram(this.program);\n        this.vao = this.gl.createVertexArray()!;\n        this.dirtyTransforms = false;\n    }\n\n    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {\n        const program = this.gl.createProgram()!;\n        let errorLog = '';\n\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);\n        if (!vertexShader || !fragmentShader) {\n            errorLog += '\\nFailed to create shaders';\n        }\n\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n\n        // Error checking\n        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n            errorLog += `\\nProgram linking failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n        this.gl.validateProgram(program);\n        if (!this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)) {\n            errorLog += `\\nProgram validation failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n        const activeAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);\n        const activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n        if (activeAttributes === 0 && activeUniforms === 0) {\n            errorLog += '\\nWarning: Program has no active attributes or uniforms';\n        }\n        if (errorLog) {\n            throw new Error(`WebGL Program creation failed: ${errorLog}`);\n        }\n\n        return program;\n    }\n\n    protected createShader(type: ShaderType, source: string): WebGLShader {\n        const shader = this.gl.createShader(type);\n        if (!shader) {\n            throw new Error('Failed to create shader');\n        }\n        this.resources.shaders.push(shader);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            throw new Error('Shader compilation failed');\n        }\n        return shader;\n    }\n\n    protected setupBufferWithAttributes(\n        buffer: WebGLBuffer,\n        data: BufferSource,\n        usage: number,\n        attributes: Array<[number, number, number, number, number?]>\n    ): void {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, data, usage);\n        attributes.forEach(([location, size, stride, offset, divisor = 0]) => {\n            this.setupAttribute(location, size, stride, offset, divisor);\n        });\n    }\n\n    protected createBuffer(): WebGLBuffer {\n        const buffer = this.gl.createBuffer()!;\n        this.resources.buffers.push(buffer);\n        return buffer;\n    }\n\n    protected createTexture(): WebGLTexture {\n        const texture = this.gl.createTexture()!;\n        this.resources.textures.push(texture);\n        return texture;\n    }\n\n    protected setupAttribute(\n        location: number,\n        size: number,\n        stride: number,\n        offset: number,\n        divisor: number = 0\n    ): void {\n        this.gl.vertexAttribPointer(location, size, this.gl.FLOAT, false, stride, offset);\n        this.gl.enableVertexAttribArray(location);\n        this.gl.vertexAttribDivisor(location, divisor);\n    }\n\n    abstract updateTransformData(data: any[], camera?: CameraManager): void; // This will also set dirtyTransforms to true.\n\n    abstract render(): void; // Before rendering, update bufferData from transformData if dirtyTransforms is true.\n\n    dispose(): void {\n        // Delete all resources in reverse order\n        this.resources.textures.forEach(texture => this.gl.deleteTexture(texture));\n        this.resources.buffers.forEach(buffer => this.gl.deleteBuffer(buffer));\n        this.resources.shaders.forEach(shader => this.gl.deleteShader(shader));\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteVertexArray(this.vao);\n\n        // Clear arrays\n        this.resources.textures = [];\n        this.resources.buffers = [];\n        this.resources.shaders = [];\n    }\n}\n\n",
    "felix.20250126193731.1": "export class TileRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.TILE_VERTEX_SHADER, SHADERS.TILE_FRAGMENT_SHADER);\n\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n        this.transformData = new Float32Array(size * 7); // Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.GAME.TILE.SIZE, CONFIG.GAME.TILE.SIZE, CONFIG.GAME.TILE.DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 28, 0, 1],\n            [3, 1, 28, 8, 1],\n            [4, 3, 28, 12, 1],\n            [5, 1, 28, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: [number, number, number][] = []): void {\n        // data is Array of X, Y and Tile Index triplets\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i][0];\n            this.transformData[offset + 1] = data[i][1];\n            this.transformData[offset + 2] = CONFIG.GAME.TILE.SIZE;\n            this.transformData[offset + 3] = 1;\n            this.transformData[offset + 4] = 1;\n            this.transformData[offset + 5] = 1;\n            this.transformData[offset + 6] = data[i][2];\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 7 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250207201240.1": "export class WidgetRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.TILE_VERTEX_SHADER, SHADERS.TILE_FRAGMENT_SHADER);\n\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n        this.transformData = new Float32Array(size * 7); // Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.GAME.WIDGETS.SIZE, CONFIG.GAME.WIDGETS.SIZE, CONFIG.GAME.WIDGETS.DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 28, 0, 1],\n            [3, 1, 28, 8, 1],\n            [4, 3, 28, 12, 1],\n            [5, 1, 28, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: [number, number, number, number][] = []): void {\n        // data is Array of X, Y and Tile Index triplets\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i][0];\n            this.transformData[offset + 1] = data[i][1];\n            this.transformData[offset + 2] = data[i][3];\n            this.transformData[offset + 3] = 1;\n            this.transformData[offset + 4] = 1;\n            this.transformData[offset + 5] = 1;\n            this.transformData[offset + 6] = data[i][2];\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 7 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250127234240.1": "export class SpriteRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.SPRITE_VERTEX_SHADER, SHADERS.SPRITE_FRAGMENT_SHADER);\n        this.image = image;\n        this.texture = this.createTexture()!;\n        this.modelBuffer = this.createBuffer()!; // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(size * 8); // 8 floats per sprite, Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, CONFIG.GAME.SPRITES.BITMAP_SIZE, CONFIG.GAME.SPRITES.BITMAP_SIZE, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 32, 0, 1],\n            [3, 1, 32, 8, 1],\n            [4, 3, 32, 12, 1],\n            [5, 2, 32, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: Array<TEntity | TSelectAnim>, camera: CameraManager): void {\n        const scrollX = camera.scrollX;\n        const scrollY = camera.scrollY;\n        const screenWidth = camera.gameScreenWidth;\n        const screenHeight = camera.gameScreenHeight;\n        let index = 0;\n\n        // Inline u and v functions to avoid repeated function calls\n        for (let i = 0, len = data.length; i < len; i++) {\n            const item = data[i];\n            if (!item.active) {\n                continue;\n            };\n            const x = item.x;\n            const y = item.y;\n\n            // Early exclusion using precomputed camera bounds\n            if ((x + 128) < scrollX || x > (scrollX + screenWidth) ||\n                (y + 128) < scrollY || y > (scrollY + screenHeight)) {\n                continue;\n            }\n\n            const offset = index * 8;\n            // Pre-calculate sprite and orientation values\n            const sprite = item.frameIndex;\n            const orientation = item.orientation;\n            const u = ((sprite % 16) * 0.015625) + ((orientation % 4) * 0.25);\n            const v = (Math.floor(sprite / 16) * 0.015625) + (Math.floor(orientation / 4) * 0.25);\n\n            // Adjust position with camera scroll (addition order adjusted)\n            this.transformData[offset] = x - scrollX;\n            this.transformData[offset + 1] = y - scrollY;\n            this.transformData[offset + 2] = 128; // default entity size\n            this.transformData[offset + 3] = 1;   // default color\n            this.transformData[offset + 4] = 1;   // default color\n            this.transformData[offset + 5] = 1;   // default color\n            this.transformData[offset + 6] = u;\n            this.transformData[offset + 7] = v;\n            index++;\n        }\n        this.renderMax = index;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 8 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250128200945.1": "export class RectangleRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, size: number) {\n        super(gl, SHADERS.RECTANGLE_VERTEX_SHADER, SHADERS.RECTANGLE_FRAGMENT_SHADER);\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(size * 7); // Init with 0s\n        this.setupVAO();\n    }\n\n    updateTransformData(data: TRectangle[]): void {\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i].x;\n            this.transformData[offset + 1] = data[i].y;\n            this.transformData[offset + 2] = data[i].width;\n            this.transformData[offset + 3] = data[i].height;\n            this.transformData[offset + 4] = data[i].r;\n            this.transformData[offset + 5] = data[i].g;\n            this.transformData[offset + 6] = data[i].b;\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.RECTANGLE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 8, 0]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [1, 2, 28, 0, 1],\n            [2, 1, 28, 8, 1],\n            [3, 1, 28, 12, 1],\n            [4, 3, 28, 16, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 7 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax); // Draw the model of 6 vertex that form 2 triangles, 3 times\n    }\n\n}\n\n",
    "felix.20241220002054.1": "@others\n",
    "felix.20241220002054.3": "export type Vec2 = { x: number, y: number };\n\nexport type TCommand = {\n    order: number;\n    x: number;\n    y: number;\n    entityId: number;\n}\n\nexport type TEntity = {\n    id: number;\n    // states\n    type: number;\n    hitPoints: number;\n    state: number;\n    x: number;\n    y: number;\n    oldX: number; // For interpolation. Meaning that the entity is moving from oldX, oldY to x, y\n    oldY: number;\n    orientation: number;\n    frameIndex: number;\n    // Ten queuable commands\n    orderQty: number;\n    orderIndex: number;\n    orderPool: [\n        TCommand, TCommand, TCommand, TCommand, TCommand,\n        TCommand, TCommand, TCommand, TCommand, TCommand\n    ];\n    active: boolean;\n}\n\nexport type TSelectAnim = {\n    x: number;\n    y: number;\n    orientation: number;\n    frameIndex: number;\n    active: boolean;\n}\n\nexport type TRectangle = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    r: number;\n    g: number;\n    b: number;\n}\n\nexport type TParameters =\n    | {\n        uniform: true;\n        location: WebGLUniformLocation;\n        type: number;\n    }\n    | {\n        uniform: false;\n        location: number;\n        type: number;\n    };\n\n\nexport interface GLResources {\n    buffers: WebGLBuffer[];\n    textures: WebGLTexture[];\n    shaders: WebGLShader[];\n}\n\nexport enum ShaderType {\n    VERTEX = WebGL2RenderingContext.VERTEX_SHADER,\n    FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER\n}\n\nexport type WebGLError = {\n    type: 'shader' | 'program' | 'buffer' | 'texture';\n    message: string;\n    details?: string;\n}\n\nexport enum EntityType {\n    ALIEN = 1,\n    // ...\n}\n",
    "felix.20241224183015.1": "<< imports >>\n@others\n",
    "felix.20250122233854.1": "import { Vec2 } from \"./types\";\n\n",
    "felix.20241224183525.1": "/**\n * Tries to put browser into fullscreen mode.\n * @param element The element to put into fullscreen mode.\n * @returns A promise that resolves when the browser is in fullscreen mode.\n */\nexport function fullScreen(element: Element): Promise<void> {\n    if (document.fullscreenElement !== null) {\n        return Promise.resolve();  // already fullscreen\n    }\n    if (element.requestFullscreen) {\n        const requestFullscreen = element.requestFullscreen || (element as any).webkitRequestFullscreen || (element as any).mozRequestFullScreen || (element as any).msRequestFullscreen;\n        if (requestFullscreen) {\n            return requestFullscreen.call(element).catch((err) => {\n                console.error(\n                    `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`,\n                );\n            });\n        } else {\n            return Promise.resolve();\n        }\n    } else {\n        return Promise.resolve();\n    }\n}\n\n",
    "felix.20250120234029.1": "export function interpolate(min: Vec2, max: Vec2, fract: number): Vec2 {\n    return { x: max.x + (min.x - max.x) * fract, y: max.y + (min.y - max.y) * fract };\n}\n\n",
    "felix.20241228192145.1": "export function loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250202200500.1": "export function getDisplaySize(entry: ResizeObserverEntry): { width: number, height: number } {\n    let width: number, height: number;\n    let dpr = window.devicePixelRatio;\n    if (entry.devicePixelContentBoxSize) {\n        // NOTE: Only this path gives the correct answer\n        // The other 2 paths are an imperfect fallback\n        // for browsers that don't provide anyway to do this\n        [width, height] = [entry.devicePixelContentBoxSize[0].inlineSize, entry.devicePixelContentBoxSize[0].blockSize];\n        dpr = 1; // Already in device pixels\n    } else if (entry.contentBoxSize) {\n        if (entry.contentBoxSize[0]) {\n            [width, height] = [entry.contentBoxSize[0].inlineSize, entry.contentBoxSize[0].blockSize];\n        } else {\n            // @ts-expect-error legacy API\n            [width, height] = [entry.contentBoxSize.inlineSize, entry.contentBoxSize.blockSize];\n        }\n    } else {\n        // Legacy API\n        [width, height] = [entry.contentRect.width, entry.contentRect.height];\n    }\n    return { width: Math.round(width * dpr), height: Math.round(height * dpr) };\n}\n\n",
    "felix.20250202202711.1": "export function debounce<T extends (...args: any[]) => void>(func: T, delay: number): T {\n    let timer: number;\n    return ((...args: any[]) => {\n        if (timer) clearTimeout(timer);\n        timer = window.setTimeout(() => func(...args), delay);\n    }) as T;\n}\n",
    "felix.20250107011547.1": "const DISPLAY = {\n    RESOLUTIONS: [\n        {\n            label: \"16:9 (1920x1080)\",\n            width: 1920,\n            height: 1080\n        },\n        {\n            label: \"16:10 (1920x1200)\",\n            width: 1920,\n            height: 1200\n        },\n        {\n            label: \"4:3 (1440x1080)\",\n            width: 1440,\n            height: 1080\n        },\n    ],\n    SCROLL: {\n        SPEED: 50, // speed in pixels for scrolling\n        BORDER: 10 // pixels from screen to trigger scrolling\n    }\n} as const;\n\nconst GAME = {\n    ACTIONS: {\n        DEFAULT: 1,\n        RELEASESEL: 2\n    },\n    TILE: {\n        SIZE: 128, // size of an individual square TILE \n        DEPTH: 64, // Total number of tiles in the bitmap\n    },\n    WIDGETS: {\n        SIZE: 64, // size of an individual square TILE \n        DEPTH: 10, // Total number of tiles in the bitmap\n        MAX: 100 // Maximum number of widgets\n    },\n    RECTANGLES: {\n        MAX: 256 // Maximum number of rectangles\n    },\n    SPRITES: {\n        BITMAP_SIZE: 4096, // size of the square bitmap of alien sprites\n        SIZE: 64, // size of an individual square alien sprite \n    },\n    MAP: {\n        WIDTH: 64, // game map width in TILES \n        HEIGHT: 64 // game map height in TILES \n    },\n    TIMING: {\n        TICK_RATE: 8, // 8 fps for game logic\n        ANIM_RATE: 15, // 15 fps for animations\n        FPS_UPDATE_INTERVAL: 1000 // Update FPS display every second\n    },\n    ENTITY: {\n        INITIAL_POOL_SIZE: 100\n    }\n} as const;\n\nconst TEXTURE_MODEL_DATA = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\nconst RECTANGLE_MODEL_DATA = new Float32Array([\n    // XY Coords\n    1, 0,\n    0, 1,\n    1, 1,\n    1, 0,\n    0, 0,\n    0, 1,\n]);\n\n// Export all configs from a single point\nexport const CONFIG = {\n    TEXTURE_MODEL_DATA,\n    RECTANGLE_MODEL_DATA,\n    DISPLAY,\n    GAME\n} as const;\n",
    "felix.20250125002553.1": "// BACKGROUND MAP VERTEX SHADER\nconst TILE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    \n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// BACKGROUND MAP FRAGMENT SHADER\nconst TILE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// ALIEN CREATURE SPRITE VERTEX SHADER\nconst SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// ALIEN CREATURE SPRITE FRAGMENT SHADER\nconst SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\n// SELECTION LINE VERTEX SHADER\nconst RECTANGLE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScaleX;\nlayout(location=3) in float aScaleY;\nlayout(location=4) in vec4 aColor;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    vec3 pos = aPosition.xyz * vec3(aScaleX, aScaleY, 1.0) + aOffset;\n    \n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// SELECTION LINE SPRITE FRAGMENT SHADER\nconst RECTANGLE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\n// Export all configs from a single point\nexport const SHADERS = {\n    TILE_VERTEX_SHADER,\n    TILE_FRAGMENT_SHADER,\n    SPRITE_VERTEX_SHADER,\n    SPRITE_FRAGMENT_SHADER,\n    RECTANGLE_VERTEX_SHADER,\n    RECTANGLE_FRAGMENT_SHADER,\n} as const;\n"
  }
}