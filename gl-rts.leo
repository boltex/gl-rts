<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20241217200720.1"><vh>introduction</vh></v>
<v t="felix.20241217201352.1"><vh>@@clean src/main.ts</vh>
<v t="felix.20241220001536.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241217225754.1"><vh>shaders</vh></v>
<v t="felix.20241217225604.1"><vh>loadImage</vh></v>
<v t="felix.20241217225540.1"><vh>Asynchronous IIFE</vh>
<v t="felix.20241217230346.1"><vh>Startup</vh></v>
</v>
<v t="felix.20241217230454.1"><vh>class Game</vh>
<v t="felix.20241220000920.1"><vh>constructor</vh></v>
<v t="felix.20241217230518.1"><vh>resize</vh></v>
<v t="felix.20241220001712.1"><vh>toggleGameMenu</vh></v>
<v t="felix.20241220001715.1"><vh>setCursor</vh></v>
<v t="felix.20241224223317.1"><vh>checkKeys</vh></v>
<v t="felix.20241220001738.1"><vh>mouseDown</vh></v>
<v t="felix.20241220001741.1"><vh>mouseUp</vh></v>
<v t="felix.20241220001745.1"><vh>mouseMove</vh></v>
<v t="felix.20241220001755.1"><vh>setCursorPos</vh></v>
<v t="felix.20241224222932.1"><vh>procGame</vh></v>
<v t="felix.20241217230522.1"><vh>update</vh></v>
<v t="felix.20241220001814.1"><vh>checkUpdate</vh></v>
<v t="felix.20241224222952.1"><vh>tick</vh></v>
<v t="felix.20241224223038.1"><vh>animateCursor</vh></v>
<v t="felix.20241224223235.1"><vh>trydefault</vh></v>
<v t="felix.20241224223239.1"><vh>tryselect</vh></v>
</v>
<v t="felix.20241220001453.1"><vh>class Entities</vh>
<v t="felix.20241220001453.2"><vh>constructor</vh></v>
<v t="felix.20241220001453.3"><vh>spawn</vh></v>
<v t="felix.20241220001453.4"><vh>remove</vh></v>
</v>
</v>
<v t="felix.20241227202430.1"><vh>@clean src/main.ts</vh>
<v t="felix.20241227202519.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241227213048.1"><vh>Create Game</vh></v>
<v t="felix.20241227213056.1"><vh>class Game</vh>
<v t="felix.20241227213841.1"><vh>constructor</vh></v>
<v t="felix.20241227213217.1"><vh>handleCanvasResize</vh></v>
<v t="felix.20250101222813.1"><vh>setDimensionsVars</vh></v>
<v t="felix.20241228191055.1"><vh>resizeCanvasToDisplaySize</vh></v>
<v t="felix.20241227213236.1"><vh>update</vh></v>
<v t="felix.20250101211507.1"><vh>setCursor</vh></v>
<v t="felix.20241231225835.1"><vh>animateCursor</vh></v>
<v t="felix.20241231222558.1"><vh>interpolate</vh></v>
<v t="felix.20241231221007.1"><vh>render</vh></v>
<v t="felix.20241228193009.1"><vh>mainMenu</vh></v>
<v t="felix.20241229230016.1"><vh>startGame</vh></v>
<v t="felix.20241229163326.1"><vh>addGameEventListeners</vh></v>
<v t="felix.20241229162002.1"><vh>toggleGameMenu</vh></v>
<v t="felix.20241229190851.1"><vh>handleKeyDown</vh></v>
<v t="felix.20241229190855.1"><vh>handleKeyUp</vh></v>
<v t="felix.20241230214840.1"><vh>processKeyInputs</vh></v>
<v t="felix.20241229162110.1"><vh>handleMouseMove</vh></v>
<v t="felix.20241229162200.1"><vh>handleMouseDown</vh></v>
<v t="felix.20241229162201.1"><vh>handleMouseUp</vh></v>
<v t="felix.20241229180756.1"><vh>handleMouseWheel</vh></v>
<v t="felix.20250101212200.1"><vh>setCursorPos</vh></v>
<v t="felix.20241230215224.1"><vh>procGame</vh></v>
<v t="felix.20241229162229.1"><vh>checkUpdate</vh></v>
<v t="felix.20241230215229.1"><vh>tick</vh></v>
<v t="felix.20241229214656.1"><vh>loop</vh></v>
<v t="felix.20241230215401.1"><vh>trydefault</vh></v>
<v t="felix.20241230215406.1"><vh>tryselect</vh></v>
</v>
</v>
<v t="felix.20241220001515.1"><vh>@clean src/maths.ts</vh>
<v t="felix.20241220001515.2"><vh>class Point</vh>
<v t="felix.20241220001515.3"><vh>constructor</vh></v>
</v>
<v t="felix.20241220001515.4"><vh>class M3x3</vh>
<v t="felix.20241220001515.5"><vh>constructor</vh></v>
<v t="felix.20241220001515.6"><vh>multiply</vh></v>
<v t="felix.20241220001515.7"><vh>translation</vh></v>
<v t="felix.20241220001515.8"><vh>scale</vh></v>
<v t="felix.20241220001515.9"><vh>getFloatArray</vh></v>
</v>
</v>
<v t="felix.20241220002054.1"><vh>@clean src/type.ts</vh>
<v t="felix.20241220002054.2"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241220002054.3"><vh>types</vh></v>
</v>
<v t="felix.20241224183015.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20241224223142.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241224183532.1"><vh>createProgram</vh></v>
<v t="felix.20241224183525.1"><vh>fullScreen</vh></v>
<v t="felix.20241224223104.1"><vh>interpolate</vh></v>
<v t="felix.20241228192145.1"><vh>loadImage</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="felix.20241217200720.1">Basic WebGL RTS game engine

Based on the following tutorials:

- Main features use WebGL concepts such as VAO (Vertex Array Objects), UBO (Uniform Buffer Objects), draw instances, and shaders from the Andrew Adamson WebGL tutorials at https://www.youtube.com/watch?v=-T6EbWCq99c&amp;list=PLPbmjY2NVO_X1U1JzLxLDdRn4NmtxyQQo

- Window resize detection and handling for canvas from https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

- Game class setup inspired by [James Byrde](https://github.com/jamesrehabstudio) tutorials at [https://www.youtube.com/@jamesbyrde3798](https://www.youtube.com/@jamesbyrde3798)

- Timing inspired from the [Glenn Fiedler](https://github.com/gafferongames) tutorial at [https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/)

</t>
<t tx="felix.20241217201352.1">@language typescript
&lt;&lt; imports &gt;&gt;
@others

</t>
<t tx="felix.20241217225540.1">(async () =&gt; {

    console.log('Hello World!');

    const canvas = document.querySelector('canvas')!;
    const gl = canvas.getContext('webgl2')!;

    const program = gl.createProgram()!;

    const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    gl.attachShader(program, vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log(gl.getShaderInfoLog(vertexShader));
        console.log(gl.getShaderInfoLog(fragmentShader));
        console.log(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // * Start Program *

    const image = await loadImage('images/alien.png');

    let lastDisplayWidth = 0;
    let lastDisplayHeight = 0;

    const resizeObserver = new ResizeObserver(onResize);
    resizeObserver.observe(canvas, { box: 'content-box' });

    /**
     * Call before rendering in draw loop to resize canvas to display size. (in case of changing window size)
     * @param canvas 
     */
    function resizeCanvasToDisplaySize(canvas: HTMLCanvasElement) {
        // Get the size the browser is displaying the canvas in device pixels.
        const [displayWidth, displayHeight] = [lastDisplayWidth, lastDisplayHeight];

        // Check if the canvas is not the same size.
        const needResize = canvas.width !== displayWidth ||
            canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;
        }

        return needResize;
    }

    function onResize(entries: any) {

        for (const entry of entries) {
            let width;
            let height;
            let dpr = window.devicePixelRatio;
            if (entry.devicePixelContentBoxSize) {
                // NOTE: Only this path gives the correct answer
                // The other 2 paths are an imperfect fallback
                // for browsers that don't provide anyway to do this
                width = entry.devicePixelContentBoxSize[0].inlineSize;
                height = entry.devicePixelContentBoxSize[0].blockSize;
                dpr = 1; // it's already in width and height
            } else if (entry.contentBoxSize) {
                if (entry.contentBoxSize[0]) {
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // legacy
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // legacy
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }
            const displayWidth = Math.round(width * dpr);
            const displayHeight = Math.round(height * dpr);
            [lastDisplayWidth, lastDisplayHeight] = [displayWidth, displayHeight];
        }
        console.log(lastDisplayWidth, lastDisplayHeight);
    }

    @others

})();

</t>
<t tx="felix.20241217225604.1">function loadImage(src: string): Promise&lt;HTMLImageElement&gt; {
    return new Promise((resolve, reject) =&gt; {
        const image = new Image();
        image.onload = () =&gt; resolve(image);
        image.src = src;
    });
}

</t>
<t tx="felix.20241217225754.1">// VERTEX SHADER
const vertexShaderSource = /*glsl*/ `#version 300 es

layout(location=0) in vec4 aPosition;
layout(location=1) in vec2 aTexCoord;
layout(location=2) in vec3 aOffset;
layout(location=3) in float aScale;
layout(location=4) in vec2 aUV;

out vec2 vTexCoord;

void main()
{
    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;
    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);
}`;

// FRAGMENT SHADER
const fragmentShaderSource = /*glsl*/ `#version 300 es

precision mediump float;

uniform mediump sampler2D uSampler;

in vec2 vTexCoord;

out vec4 fragColor;

void main()
{
    fragColor = texture(uSampler, vTexCoord);
}`;

</t>
<t tx="felix.20241217230346.1">document.addEventListener('DOMContentLoaded', (event) =&gt; {
    if (!window.game) {
        window.game = new Game();
        window.game.resize(
            window.innerWidth,
            window.innerHeight,
            true // First resize not debounced.
        );
    } else {
        console.log('Game instance already started');
    }
});

window.addEventListener('resize', (event) =&gt; {
    if (window.game) {
        window.game.resize(
            window.innerWidth,
            window.innerHeight
        );
    }
});

function loop(timestamp: number): void {
    window.game.update(timestamp);
    requestAnimationFrame(loop);
}

</t>
<t tx="felix.20241217230454.1">export class Game {

    public started = false;
    public canvasRect: DOMRect;
    public optionsVisible = false;
    public menu: HTMLElement;


    public canvasElement: HTMLCanvasElement;
    public gl!: WebGL2RenderingContext;

    public worldSpaceMatrix: M3x3;

    // Game States
    public entities!: Entities;

    // Key press state
    public keysPressed: Record&lt;string, any&gt; = {};

    // Game Map
    public gamemap: number[] = [];

    // Screen States
    public screenx = 1920;
    public screeny = 1080;

    public selecting: boolean = false;
    public selx = 0; // Started selection at specific coords
    public sely = 0;

    public scrollx = 0; // Current scroll position 
    public scrolly = 0;

    public SCROLLSPEED = 50;   // speed in pixels for scrolling
    public SCROLLBORDER = 10; // 5;   // pixels from screen to trigger scrolling
    public xscr_e = this.screenx - this.SCROLLBORDER; // constants for finding trigger zone
    public yscr_e = this.screeny - this.SCROLLBORDER;


    public tilebmpsize = 1024;  // size of a bitmap of tiles
    public tilesize = 128;      // size of an individual square TILE 
    public tileratio = this.tilebmpsize / this.tilesize;
    public initrangex = (this.screenx / this.tilesize) + 1;
    public initrangey = (this.screeny / this.tilesize) + 1;

    public gamemapw = 9; // game map width in TILES 
    public gamemaph = 9;
    public maxmapx = (this.gamemapw * this.tilesize) - 1;
    public maxmapy = (this.gamemaph * this.tilesize) - 1;
    public maxscrollx = 1 + this.maxmapx - this.screenx;
    public maxscrolly = 1 + this.maxmapy - this.screeny;

    public scrollnowx = 0; // Scroll amount to be applied to scroll when processing
    public scrollnowy = 0;



    public htmlClassList: DOMTokenList;
    public curClass = ""; //"cur-pointer", "cur-target", "cur-select" ...

    public curx = 0 // Current mouse position
    public cury = 0

    public gamestate = 0   // 0=SPLASH
    // 1=Lobby (main menu)
    // 2=game Lobby
    // 3=play Loop
    // 4=Game over/stats
    // 5=EDITION ANIMS
    // 6=EDITION MAP
    // 7=OPTIONS

    public gameaction = 0    // 0=none
    public DEFAULTACTION = 1 // game actions CONSTANTS, zero means none
    public RELEASESEL = 2

    public gamecurx = 0
    public gamecury = 0
    public gameselx = 0
    public gamesely = 0

    // Test Cursor vatiables
    public curanim = 0
    public curanimtotal = 6
    public curanimx = 0
    public curanimy = 0

    // Test Orientation vatiable
    public testSpriteOrientation = 0;

    // FPS counter
    public lastTime = 0;
    public fps = 0;
    public fpsInterval = 1000; // Update FPS every 1 second
    public fpsLastTime = 0;

    // GAME-STATE TICKS AT 8 FPS
    public tickAccumulator = 0; // What remained in deltaTime after last update 
    public currentTick = 0;
    public timePerTick = 125; // dt in ms (125 is 8 per second)
    public timerTriggerAccum = this.timePerTick * 3; // 3 times the timePerTick

    // ANIMATIONS AT 15 FPS
    public animAccumulator = 0; // What remained in deltaTime after last update 
    public currentAnim = 0;
    public timePerAnim = 67; // dt in ms (66.66 is 15 per second)



    @others

}

</t>
<t tx="felix.20241217230518.1">resize(w: number, h: number, noDebounce?: boolean): void {
    // if (noDebounce) {
    //     this.calculateResize(w, h);
    // } else {
    //     if (this._resizeTimer) {
    //         clearTimeout(this._resizeTimer);
    //     }
    //     this._resizeTimer = setTimeout(() =&gt; {
    //         this.calculateResize(w, h); // Debounced
    //     }, 100);
    // }
}

</t>
<t tx="felix.20241217230522.1">update(timestamp: number, skipRender?: boolean): void {
    // 
}

</t>
<t tx="felix.20241220000920.1">constructor() {
    console.log('Init WebGL2 Game !');
    console.log('initrangex', this.initrangex);
    console.log('initrangey', this.initrangey);
    console.log('tileratio', this.tileratio);

    this.menu = document.getElementById('game-menu')!;

    this.htmlClassList = document.documentElement.classList;
    this.setCursor("cur-pointer");
    // this.canvasElement = document.createElement("canvas");

    this.canvasElement = document.querySelector('canvas')!;
    this.canvasElement.width = this.screenx;
    this.canvasElement.height = this.screeny;
    this.canvasRect = this.canvasElement.getBoundingClientRect();

    this.worldSpaceMatrix = new M3x3();

    this.gl = this.canvasElement.getContext('webgl2', {
        // antialias: false,
        // alpha: false,
        // depth: false,
    })!;
    // this.gl.enable(this.gl.BLEND);  // TODO: Check if needed

    // document.body.appendChild(this.canvasElement);

    // Prevent right-click context menu
    this.canvasElement.addEventListener('contextmenu', (event) =&gt; {
        event.preventDefault();
    });


    console.log('Starting the game!');

    document.addEventListener('keydown', (e) =&gt; {
        this.keysPressed[e.key] = true;
        if (e.key === 'F10') {
            e.preventDefault();  // Prevent default F10 behavior
            this.toggleGameMenu();
        }
        if (e.ctrlKey &amp;&amp; (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '_')) {
            e.preventDefault();
        }
        // 107 Num Key  +
        // 109 Num Key  -
        // 173 Min Key  hyphen/underscore key
        // 61 Plus key  +/= key

    });
    document.addEventListener('keyup', (e) =&gt; {
        this.keysPressed[e.key] = false;
    });

    const resumeButton = document.getElementById('resume-btn');

    resumeButton!.addEventListener('click', () =&gt; {
        this.toggleGameMenu();  // Close the menu and resume the game
    });

    window.addEventListener("mousemove", (event) =&gt; {
        this.mouseMove(event);
    });
    window.addEventListener("mousedown", (event) =&gt; {
        this.mouseDown(event);
    });
    window.addEventListener("mouseup", (event) =&gt; {
        this.mouseUp(event);
    });

    window.addEventListener("wheel DOMMouseScroll", (event: any) =&gt; {
        if (event.ctrlKey) {
            event.preventDefault(); // Prevents the default zoom behavior
            // Use the event's deltaY property to detect scroll direction
            // if (event.deltaY &lt; 0) {
            //     console.log("CTRL+Scroll Up"); // You could trigger a specific game action here
            // } else if (event.deltaY &gt; 0) {
            //     console.log("CTRL+Scroll Down");
            // }
        }
    }, { passive: false });

    // startButton.style.display = 'none';
    // resolutionSelect.style.display = 'none';
    // document.body.style.cursor = 'none'; // ! HIDE NATIVE CURSOR !
    this.started = true;
    // Setup timer in case RAF Skipped when not in foreground or minimized.
    setInterval(() =&gt; { this.checkUpdate(); }, 500);

    // TODO START ! 
    // loop(0); 

}

</t>
<t tx="felix.20241220001453.1">

/**
 * Singleton Entities Object Pool
 */
export class Entities {

    public total: number;
    public active: number = 0;
    public pool: Array&lt;TEntity&gt; = [];
    private lastId = 0;

    @others

}
</t>
<t tx="felix.20241220001453.2">constructor(initialPoolSize: number) {
    this.total = initialPoolSize;
    for (let i = 0; i &lt; initialPoolSize; i++) {
        this.pool.push({
            id: 0,
            type: 0,
            hitPoints: 0,
            state: 0,
            x: 0,
            y: 0,
            orderQty: 0,
            orderIndex: 0,
            orderPool: [
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
            ],
            orientation: 0,
            frameIndex: 0,
            active: false,
        });
    }

}

</t>
<t tx="felix.20241220001453.3">spawn(): TEntity {
    if (this.active === this.total) {
        throw new Error("Pool Full");
    }
    const entity = this.pool.find(e =&gt; !e.active);
    if (entity) {
        entity.active = true;
        entity.id = ++this.lastId;
        this.active++;
        return entity;
    } else {
        throw new Error("Pool Full");
    }
}

</t>
<t tx="felix.20241220001453.4">remove(entity: TEntity): void {
    this.active--;
    entity.active = false;
}

</t>
<t tx="felix.20241220001515.1">@others
</t>
<t tx="felix.20241220001515.2">export class Point {

    public x: number;
    public y: number;

    @others
}
</t>
<t tx="felix.20241220001515.3">constructor(x = 0.0, y = 0.0) {
    this.x = x;
    this.y = y;
}

</t>
<t tx="felix.20241220001515.4">export class M3x3 {

    public static M00 = 0;
    public static M01 = 1;
    public static M02 = 2;
    public static M10 = 3;
    public static M11 = 4;
    public static M12 = 5;
    public static M20 = 6;
    public static M21 = 7;
    public static M22 = 8;

    public matrix: [
        number, number, number,
        number, number, number,
        number, number, number,
    ];

    @others

}

</t>
<t tx="felix.20241220001515.5">constructor() {
    this.matrix = [
        1, 0, 0,
        0, 1, 0,
        0, 0, 1
    ];
}

</t>
<t tx="felix.20241220001515.6">multiply(m: M3x3): M3x3 {
    const output = new M3x3();
    output.matrix = [
        this.matrix[M3x3.M00] * m.matrix[M3x3.M00] + this.matrix[M3x3.M10] * m.matrix[M3x3.M01] + this.matrix[M3x3.M20] * m.matrix[M3x3.M02],
        this.matrix[M3x3.M01] * m.matrix[M3x3.M00] + this.matrix[M3x3.M11] * m.matrix[M3x3.M01] + this.matrix[M3x3.M21] * m.matrix[M3x3.M02],
        this.matrix[M3x3.M02] * m.matrix[M3x3.M00] + this.matrix[M3x3.M12] * m.matrix[M3x3.M01] + this.matrix[M3x3.M22] * m.matrix[M3x3.M02],

        this.matrix[M3x3.M00] * m.matrix[M3x3.M10] + this.matrix[M3x3.M10] * m.matrix[M3x3.M11] + this.matrix[M3x3.M20] * m.matrix[M3x3.M12],
        this.matrix[M3x3.M01] * m.matrix[M3x3.M10] + this.matrix[M3x3.M11] * m.matrix[M3x3.M11] + this.matrix[M3x3.M21] * m.matrix[M3x3.M12],
        this.matrix[M3x3.M02] * m.matrix[M3x3.M10] + this.matrix[M3x3.M12] * m.matrix[M3x3.M11] + this.matrix[M3x3.M22] * m.matrix[M3x3.M12],

        this.matrix[M3x3.M00] * m.matrix[M3x3.M20] + this.matrix[M3x3.M10] * m.matrix[M3x3.M21] + this.matrix[M3x3.M20] * m.matrix[M3x3.M22],
        this.matrix[M3x3.M01] * m.matrix[M3x3.M20] + this.matrix[M3x3.M11] * m.matrix[M3x3.M21] + this.matrix[M3x3.M21] * m.matrix[M3x3.M22],
        this.matrix[M3x3.M02] * m.matrix[M3x3.M20] + this.matrix[M3x3.M12] * m.matrix[M3x3.M21] + this.matrix[M3x3.M22] * m.matrix[M3x3.M22]
    ];
    return output;
}

</t>
<t tx="felix.20241220001515.7">translation(x: number, y: number): M3x3 {
    const output = new M3x3();
    output.matrix = [
        this.matrix[M3x3.M00],
        this.matrix[M3x3.M01],
        this.matrix[M3x3.M02],
        this.matrix[M3x3.M10],
        this.matrix[M3x3.M11],
        this.matrix[M3x3.M12],

        x * this.matrix[M3x3.M00] + y * this.matrix[M3x3.M10] + this.matrix[M3x3.M20],
        x * this.matrix[M3x3.M01] + y * this.matrix[M3x3.M11] + this.matrix[M3x3.M21],
        x * this.matrix[M3x3.M02] + y * this.matrix[M3x3.M12] + this.matrix[M3x3.M22]
    ];
    return output;
}

</t>
<t tx="felix.20241220001515.8">scale(x: number, y: number): M3x3 {
    const output = new M3x3();
    output.matrix = [
        this.matrix[M3x3.M00] * x,
        this.matrix[M3x3.M01] * x,
        this.matrix[M3x3.M02] * x,

        this.matrix[M3x3.M10] * y,
        this.matrix[M3x3.M11] * y,
        this.matrix[M3x3.M12] * y,

        this.matrix[M3x3.M20],
        this.matrix[M3x3.M21],
        this.matrix[M3x3.M22]
    ];
    return output;
}

</t>
<t tx="felix.20241220001515.9">getFloatArray(): Float32Array {
    return new Float32Array(this.matrix);
}

</t>
<t tx="felix.20241220001536.1">// import * as Constants from "./constants";
// import * as utils from "./utils";
import { Point, M3x3 } from "./maths";
import { TEntity, } from "./type";

</t>
<t tx="felix.20241220001712.1">public toggleGameMenu(): void {

    if (this.menu.style.display === 'none') {
        this.menu.style.display = 'flex';  // Show the menu
        // Pause game logic here (if needed)
    } else {
        this.menu.style.display = 'none';  // Hide the menu
        // Resume game logic here (if needed)
    }
}

</t>
<t tx="felix.20241220001715.1">setCursor(newClass: string) {
    if (this.curClass !== newClass) {
        if (this.curClass) {
            this.htmlClassList.remove(this.curClass); // Remove from html
        }
        this.htmlClassList.add(newClass); // Add to html
        this.curClass = newClass; // Update the tracked cursor class
    }
}
</t>
<t tx="felix.20241220001738.1">public mouseDown(event: MouseEvent): void {
    this.setCursorPos(event);
    this.gamecurx = this.curx + this.scrollx;
    this.gamecury = this.cury + this.scrolly;
    if (!this.selecting) {
        if (event.button == 0) {
            this.selecting = true;
            this.setCursor("cur-target");
            this.selx = this.curx;
            this.sely = this.cury;
        }
        if (event.button == 2) {
            this.gameaction = this.DEFAULTACTION;
        }
    }
}

</t>
<t tx="felix.20241220001741.1">public mouseUp(event: MouseEvent): void {
    this.setCursorPos(event);
    this.gameselx = this.selx + this.scrollx;
    this.gamesely = this.sely + this.scrolly;
    this.gamecurx = this.curx + this.scrollx;
    this.gamecury = this.cury + this.scrolly;
    if (event.button == 0) {
        this.selecting = false;
        this.setCursor("cur-pointer");
        this.gameaction = this.RELEASESEL;
    }
}

</t>
<t tx="felix.20241220001745.1">public mouseMove(event: MouseEvent): void {
    this.setCursorPos(event);
    this.scrollnowx = 0;
    this.scrollnowy = 0;
    if (this.curx &gt; this.xscr_e) {
        this.scrollnowx = this.SCROLLSPEED;
    }
    if (this.cury &gt; this.yscr_e) {
        this.scrollnowy = this.SCROLLSPEED;
    }
    if (this.curx &lt; this.SCROLLBORDER) {
        this.scrollnowx = -this.SCROLLSPEED;
    }
    if (this.cury &lt; this.SCROLLBORDER) {
        this.scrollnowy = -this.SCROLLSPEED;
    }
}

</t>
<t tx="felix.20241220001755.1">public setCursorPos(event: MouseEvent): void {
    this.curx = (event.clientX - this.canvasRect.left) * (this.screenx / this.canvasRect.width);
    this.cury = (event.clientY - this.canvasRect.top) * (this.screeny / this.canvasRect.height);
}

</t>
<t tx="felix.20241220001814.1">public checkUpdate(): void {
    // Checks for needed ticks to be computed if game is minimized
    const timestamp = performance.now();
    const deltaTime = timestamp - this.lastTime;
    if ((this.tickAccumulator + deltaTime) &lt; this.timerTriggerAccum) {
        return;
    }
    // It's been a while, game is minimized: update without rendering.
    this.update(timestamp, true);
}

</t>
<t tx="felix.20241220002054.1">&lt;&lt; imports &gt;&gt;
@others</t>
<t tx="felix.20241220002054.2">import { Point } from "./maths";
</t>
<t tx="felix.20241220002054.3">export type TCommand = {
    order: number;
    x: number;
    y: number;
    entityId: number;
}

export type TEntity = {
    id: number;
    // states
    type: number;
    hitPoints: number;
    state: number;
    x: number;
    y: number;
    orientation: number;
    frameIndex: number;
    // Ten queuable commands
    orderQty: number;
    orderIndex: number;
    orderPool: [
        TCommand, TCommand, TCommand, TCommand, TCommand,
        TCommand, TCommand, TCommand, TCommand, TCommand
    ];
    active: boolean;
}</t>
<t tx="felix.20241224183015.1">&lt;&lt; imports &gt;&gt;
@others

</t>
<t tx="felix.20241224183525.1">/**
 * Tries to put browser into fullscreen mode.
 * @param element The element to put into fullscreen mode.
 * @returns A promise that resolves when the browser is in fullscreen mode.
 */
export function fullScreen(element: Element): Promise&lt;void&gt; {
    if (document.fullscreenElement !== null) {
        return Promise.resolve();  // already fullscreen
    }
    if (element.requestFullscreen) {
        const requestFullscreen = element.requestFullscreen || (element as any).webkitRequestFullscreen || (element as any).mozRequestFullScreen || (element as any).msRequestFullscreen;
        if (requestFullscreen) {
            return requestFullscreen.call(element).catch((err) =&gt; {
                console.error(
                    `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`,
                );
            });
        } else {
            return Promise.resolve();
        }
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="felix.20241224183532.1">/**
 * Creates a WebGL program from vertex and fragment shader source code.
 * @param gl The WebGL rendering context.
 * @param vs The source code for the vertex shader.
 * @param fs The source code for the fragment shader.
 * @returns The created WebGL program.
 * @throws Will throw an error if the program or shaders cannot be created, compiled, or linked.
 */
export function createProgram(gl: WebGLRenderingContext, vs: string, fs: string): WebGLProgram {
    const program = gl.createProgram();
    if (!program) {
        throw new Error('Unable to create WebGL program.');
    }

    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    if (!vertexShader) {
        throw new Error('Unable to create vertex shader.');
    }
    gl.shaderSource(vertexShader, vs);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(vertexShader);
        gl.deleteShader(vertexShader);
        throw new Error('Vertex shader compilation error: ' + error);
    }
    gl.attachShader(program, vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    if (!fragmentShader) {
        throw new Error('Unable to create fragment shader.');
    }
    gl.shaderSource(fragmentShader, fs);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        const error = gl.getShaderInfoLog(fragmentShader);
        gl.deleteShader(fragmentShader);
        throw new Error('Fragment shader compilation error: ' + error);
    }
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = gl.getProgramInfoLog(program);
        gl.deleteProgram(program);
        throw new Error('Program linking error: ' + error);
    }

    return program;
}

</t>
<t tx="felix.20241224222932.1">public procGame(): void {

    // procgame processes a game frame, animating each RFA
    // Note: This is not a game-states tick, at timePerTick intervals.

    if (this.gameaction) {

        switch (this.gameaction) {
            case this.DEFAULTACTION:
                this.trydefault()
                break;
            case this.RELEASESEL:
                this.tryselect()
                break;

            default:
                break;
        }

    }

    this.gameaction = 0 // -------------- no more game actions to do

    // Scroll if not selected    
    if (!this.selecting) {
        this.scrollx += this.scrollnowx;
        this.scrolly += this.scrollnowy;
        if (this.scrollx &gt; this.maxscrollx) {
            this.scrollx = this.maxscrollx;
        }
        if (this.scrollx &lt; 0) {
            this.scrollx = 0;
        }
        if (this.scrolly &gt; this.maxscrolly) {
            this.scrolly = this.maxscrolly;
        }
        if (this.scrolly &lt; 0) {
            this.scrolly = 0;
        }
    }
}

</t>
<t tx="felix.20241224222952.1">tick(): void {


    // Advance game states in pool:
    // meaning, from currentTick count, to the next one.

    // #########################################

    let processed = 0;
    let entity;
    for (let i = 0; processed &lt; this.entities.active || i &lt; this.entities.total; i++) {
        entity = this.entities.pool[i];
        if (entity.active) {
            processed += 1;
            // EXPERIMENT this.ai.process(entity);
        }
    }

    this.checkKeys();

    // Update currentTick count
    this.currentTick += 1;
}

</t>
<t tx="felix.20241224223038.1">public animateCursor(): void {
    // Animate at 15 FPS

    // Cursor
    if (this.curanim) {
        this.curanim += 1;
        if (this.curanim &gt; this.curanimtotal)
            this.curanim = 0
    }

}

</t>
<t tx="felix.20241224223104.1">export function interpolate(min: Point, max: Point, fract: number): Point {
    return new Point(max.x + (min.x - max.x) * fract, max.y + (min.y - max.y) * fract);
}

</t>
<t tx="felix.20241224223142.1">import { Point } from "./maths";
</t>
<t tx="felix.20241224223235.1">public trydefault(): void {
    // TODO : Replace with real default action
    // TEST CURSOR ANIMATION ON DEFAULT ACTION
    this.curanim = 1;
    this.curanimx = this.gamecurx - 32;
    this.curanimy = this.gamecury - 32;
}

</t>
<t tx="felix.20241224223239.1">public tryselect(): void {
    // Called from procGame
}

</t>
<t tx="felix.20241224223317.1">checkKeys(): void {
    if (this.keysPressed['ArrowUp'] || this.keysPressed['w']) {
        // playerY -= playerSpeed * deltaTime;
        // EXPERIMENT  this.setCursor("cur-pointer");
    }
    if (this.keysPressed['ArrowDown'] || this.keysPressed['s']) {
        // playerY += playerSpeed * deltaTime;
        // EXPERIMENT  this.setCursor("cur-target");
    }
    if (this.keysPressed['ArrowLeft'] || this.keysPressed['a']) {
        // playerX -= playerSpeed * deltaTime;
        // EXPERIMENT  this.changeOrientation(false);
    }
    if (this.keysPressed['ArrowRight'] || this.keysPressed['d']) {
        // playerX += playerSpeed * deltaTime;
        // EXPERIMENT  this.changeOrientation(true);
    }
}

</t>
<t tx="felix.20241227202430.1">&lt;&lt; imports &gt;&gt;
@others

</t>
<t tx="felix.20241227202519.1">import * as utils from "./utils";
import { Point, M3x3 } from "./maths";
import { TEntity } from "./type";

</t>
<t tx="felix.20241227213048.1">document.addEventListener('DOMContentLoaded', (event) =&gt; {
    if (!window.game) {
        window.game = new Game();
    } else {
        console.log('Game instance already started');
    }
});

</t>
<t tx="felix.20241227213056.1">export class Game {

    // HTML Elements
    startButtonElement: HTMLButtonElement = document.createElement("button");
    resolutionSelectElement: HTMLSelectElement = document.createElement("select");

    // Canvas Properties
    lastDisplayWidth: number = 0;
    lastDisplayHeight: number = 0;
    canvasElement: HTMLCanvasElement;
    canvasBoundingRect: DOMRect;
    glContext: WebGL2RenderingContext;

    // Game Screen Properties
    aspectRatio: number = 1; // set in startGame, this is display aspect ratio
    gameScreenWidth: number = 0; // set in startGame, this is game screen size
    gameScreenHeight: number = 0;
    gameWidthRatio: number = 0; // set in startGame, this is game screen ratio to the canvas size
    gameHeightRatio: number = 0;
    scrollEdgeX = 0; // set in startGame, constants for finding trigger zone
    scrollEdgeY = 0;

    // Map tile Properties
    tileBmpSize = 1024;  // size of a square bitmap of tiles
    tileSize = 128;      // size of an individual square TILE 
    tileRatio = this.tileBmpSize / this.tileSize;
    initRangeX = (this.gameScreenWidth / this.tileSize) + 1; // set in startGame
    initRangeY = (this.gameScreenHeight / this.tileSize) + 1;
    gameMapWidth = 9; // game map width in TILES 
    gameMapHeight = 9; // game map height in TILES 
    maxMapX = (this.gameMapWidth * this.tileSize) - 1;
    maxMapY = (this.gameMapHeight * this.tileSize) - 1;
    maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;
    maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;

    // Game state Properties
    started = false;
    gameAction = 0    // 0 = none

    // Mouse Properties
    mouseX: number = 0; // Current mouse position in window
    mouseY: number = 0;
    gameMouseX: number = 0; // Current mouse position in game
    gameMouseY: number = 0;
    gameSelectionX: number = 0;
    gameSelectionY: number = 0;

    // Mouse Cursor Properties
    documentElementClassList: DOMTokenList; // Css rules rely on this to change cursor.
    currentCursorClass = ""; //"cur-pointer", "cur-target", "cur-select" ...

    // Command Acknowledged Widget Animation Properties
    widgetAnim = 0
    widgetAnimTotal = 6
    widgetAnimX = 0
    widgetAnimY = 0

    // Cursor Selection State
    selecting: boolean = false;
    selX = 0; // Started selection at specific coords
    selY = 0;

    // Scroll Properties
    scrollX = 0; // Current scroll position 
    scrollY = 0;
    scrollNowX = 0; // Scroll amount to be applied to scroll when processing
    scrollNowY = 0;

    // Key press state
    keysPressed: Record&lt;string, any&gt; = {};

    // Image assets
    creaturesImage!: HTMLImageElement;
    tilesImage!: HTMLImageElement;

    // GAME-STATE TICKS AT 8 FPS
    tickAccumulator = 0; // What remained in deltaTime after last update 
    currentTick = 0;
    timePerTick = 125; // dt in ms (125 is 8 per second)
    timerTriggerAccum = this.timePerTick * 3; // 3 times the timePerTick

    // ANIMATIONS AT 15 FPS
    animAccumulator = 0; // What remained in deltaTime after last update 
    currentAnim = 0;
    timePerAnim = 67; // dt in ms (66.66 is 15 per second)

    // FPS counter
    lastTime = 0;
    fps = 0;
    fpsInterval = 1000; // Update FPS every 1 second
    fpsLastTime = 0;

    static SCROLLSPEED = 50;   // speed in pixels for scrolling
    static SCROLLBORDER = 10;  // pixels from screen to trigger scrolling

    static GAME_ACTIONS = {
        DEFAULT: 1,
        RELEASESEL: 2
    };

    static AVAILABLE_RESOLUTIONS = [
        {
            label: "16:9 (1920x1080)",
            width: 1920, height: 1080
        },
        {
            label: "16:10 (1920x1200)",
            width: 1920, height: 1200
        },
        {
            label: "4:3 (1440x1080)",
            width: 1440, height: 1080
        },
    ];

    @others

}

</t>
<t tx="felix.20241227213217.1">handleCanvasResize(entries: ResizeObserverEntry[]): void {
    // Canvas has style width: 100vw; and style height: 100vh;
    // So we need to handle a window resize which changes the canvas size.
    for (const entry of entries) {
        let width;
        let height;
        let dpr = window.devicePixelRatio;
        if (entry.devicePixelContentBoxSize) {
            // NOTE: Only this path gives the correct answer
            // The other 2 paths are an imperfect fallback
            // for browsers that don't provide anyway to do this
            width = entry.devicePixelContentBoxSize[0].inlineSize;
            height = entry.devicePixelContentBoxSize[0].blockSize;
            dpr = 1; // it's already in width and height
        } else if (entry.contentBoxSize) {
            if (entry.contentBoxSize[0]) {
                width = entry.contentBoxSize[0].inlineSize;
                height = entry.contentBoxSize[0].blockSize;
            } else {
                // legacy mozilla impl using only contentBox
                // @ts-expect-error
                width = entry.contentBoxSize.inlineSize;
                // @ts-expect-error
                height = entry.contentBoxSize.blockSize;
            }
        } else {
            // legacy
            width = entry.contentRect.width;
            height = entry.contentRect.height;
        }
        const displayWidth = Math.round(width * dpr);
        const displayHeight = Math.round(height * dpr);
        [this.lastDisplayWidth, this.lastDisplayHeight] = [displayWidth, displayHeight];

        this.setDimensionsVars();
    }
}

</t>
<t tx="felix.20241227213236.1">update(timestamp: number, skipRender?: boolean): void {
    const deltaTime = timestamp - this.lastTime;
    this.lastTime = timestamp;

    this.tickAccumulator += deltaTime;
    this.animAccumulator += deltaTime;

    this.procGame();

    while (this.animAccumulator &gt;= this.timePerAnim) {
        this.animateCursor();
        this.animAccumulator -= this.timePerAnim;
    }

    while (this.tickAccumulator &gt;= this.timePerTick) {
        this.tick();
        this.tickAccumulator -= this.timePerTick;
    }

    if (!skipRender) {
        // Gather render data and interpolate
        this.render(this.tickAccumulator / this.timePerTick);
    }

    // Calculate FPS
    if (timestamp - this.fpsLastTime &gt; this.fpsInterval) {
        this.fps = Math.round(1000 / deltaTime);
        this.fpsLastTime = timestamp;
        // console.log('RFA FPS ', this.fps); // 30
    }

}

</t>
<t tx="felix.20241227213841.1">constructor() {
    console.log("constructing game");

    this.documentElementClassList = document.documentElement.classList;

    this.canvasElement = document.createElement('canvas');
    document.body.appendChild(this.canvasElement);

    this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();
    this.setDimensionsVars();

    this.glContext = this.canvasElement.getContext('webgl2')!;

    // Prevent right-click context menu
    this.canvasElement.addEventListener('contextmenu', (event) =&gt; {
        event.preventDefault();
    });

    // Canvas has style width: 100vw; and style height: 100vh;
    const resizeObserver = new ResizeObserver(this.handleCanvasResize.bind(this));
    resizeObserver.observe(this.canvasElement, { box: 'content-box' });

    // Create a 'loading...' text element centered on screen
    const loadingText = document.createElement('div');
    loadingText.classList.add("loading-text");
    loadingText.textContent = 'Loading...';

    document.body.appendChild(loadingText);

    // Using promises, after both image assets have loaded, call mainMenu
    const creaturesPromise = utils.loadImage('images/alien.png');
    const tilesPromise = utils.loadImage('images/plancher-vertical.png');
    Promise.all([creaturesPromise, tilesPromise]).then((images) =&gt; {
        document.body.removeChild(loadingText);
        this.creaturesImage = images[0];
        this.tilesImage = images[1];
        this.mainMenu();
    });

}

</t>
<t tx="felix.20241228191055.1">resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {
    // Get the size the browser is displaying the canvas in device pixels.
    const [displayWidth, displayHeight] = [this.lastDisplayWidth, this.lastDisplayHeight];

    // Check if the canvas is not the same size.
    const needResize = canvas.width !== displayWidth ||
        canvas.height !== displayHeight;

    if (needResize) {
        // Make the canvas the same size
        canvas.width = displayWidth;
        canvas.height = displayHeight;
    }

    return needResize;
}

</t>
<t tx="felix.20241228192145.1">export function loadImage(src: string): Promise&lt;HTMLImageElement&gt; {
    return new Promise((resolve, reject) =&gt; {
        const image = new Image();
        image.onload = () =&gt; resolve(image);
        image.src = src;
    });
}

</t>
<t tx="felix.20241228193009.1">mainMenu(): void {
    // The images have loaded, so it's time to show the pre-game menu

    // Create the start button
    this.startButtonElement.textContent = "Start Game";
    this.startButtonElement.classList.add("btn-start");

    document.body.appendChild(this.startButtonElement);

    // Create the dropdown for screen resolution
    this.resolutionSelectElement.classList.add("resolution-select");


    // Populate the dropdown with options
    for (const { label, width, height } of Game.AVAILABLE_RESOLUTIONS) {
        const option = document.createElement("option");
        option.value = `${width}x${height}`;
        option.textContent = label;
        this.resolutionSelectElement.appendChild(option);
    }
    document.body.appendChild(this.resolutionSelectElement);

    // Use resolutionSelect.selectedIndex to get the selected resolution

    this.startButtonElement.addEventListener("click", this.startGame.bind(this));

}

</t>
<t tx="felix.20241229162002.1">toggleGameMenu(): void {
    console.log('Toggle Game Menu'); // Todo: Implement Game Menu
}

</t>
<t tx="felix.20241229162110.1">handleMouseMove(event: MouseEvent): void {
    this.setCursorPos(event);
    this.scrollNowX = 0;
    this.scrollNowY = 0;

    // Scroll if cursor is near the edge of the screen
    if (this.mouseX &gt; this.scrollEdgeX) {
        this.scrollNowX = Game.SCROLLSPEED;
    }
    if (this.mouseY &gt; this.scrollEdgeY) {
        this.scrollNowY = Game.SCROLLSPEED;
    }
    if (this.mouseX &lt; Game.SCROLLBORDER) {
        this.scrollNowX = -Game.SCROLLSPEED;
    }
    if (this.mouseY &lt; Game.SCROLLBORDER) {
        this.scrollNowY = -Game.SCROLLSPEED;
    }
}

</t>
<t tx="felix.20241229162200.1">handleMouseDown(event: MouseEvent): void {
    this.setCursorPos(event);
    this.gameMouseX = this.mouseX + this.scrollX;
    this.gameMouseY = this.mouseY + this.scrollY;
    if (!this.selecting) {
        if (event.button == 0) {
            this.selecting = true;
            this.setCursor("cur-target");
            this.selX = this.mouseX;
            this.selY = this.mouseY;
        }
        if (event.button == 2) {
            this.gameAction = Game.GAME_ACTIONS.DEFAULT;
        }
    }
}

</t>
<t tx="felix.20241229162201.1">handleMouseUp(event: MouseEvent): void {
    this.setCursorPos(event);
    this.gameSelectionX = this.selX + this.scrollX;
    this.gameSelectionY = this.selY + this.scrollY;
    this.gameMouseX = this.mouseX + this.scrollX;
    this.gameMouseY = this.mouseY + this.scrollY;
    if (event.button == 0) {
        this.selecting = false;
        this.setCursor("cur-pointer");
        this.gameAction = Game.GAME_ACTIONS.RELEASESEL;
    }

}

</t>
<t tx="felix.20241229162229.1">checkUpdate(): void {
    // Checks for needed ticks to be computed if game is minimized
    const timestamp = performance.now();
    const deltaTime = timestamp - this.lastTime;
    if ((this.tickAccumulator + deltaTime) &lt; this.timerTriggerAccum) {
        return;
    }
    // It's been a while, game is minimized: update without rendering.
    this.update(timestamp, true);
}

</t>
<t tx="felix.20241229163326.1">addGameEventListeners(): void {
    window.addEventListener("keydown", this.handleKeyDown.bind(this));
    window.addEventListener("keyup", this.handleKeyUp.bind(this));
    window.addEventListener("mousemove", this.handleMouseMove.bind(this));
    window.addEventListener("mousedown", this.handleMouseDown.bind(this));
    window.addEventListener("mouseup", this.handleMouseUp.bind(this));
    window.addEventListener("wheel", this.handleMouseWheel.bind(this), { passive: false });
}

</t>
<t tx="felix.20241229180756.1">handleMouseWheel(event: WheelEvent): void {
    if (event.deltaY &lt; 0) {
        // Todo: Zoom in
        console.log("CTRL+Scroll Up"); // You could trigger a specific game action here
    } else if (event.deltaY &gt; 0) {
        // Todo: Zoom out
        console.log("CTRL+Scroll Down");
    }

    // Prevents the default zoom behavior
    if (event.ctrlKey) {
        event.preventDefault();
    }
}

</t>
<t tx="felix.20241229190851.1">handleKeyDown(e: KeyboardEvent): void {
    this.keysPressed[e.key] = true;
    if (e.key === 'F10') {
        e.preventDefault();  // Prevent default F10 behavior
        this.toggleGameMenu();
    }
    // Prevent keyboard zoom.
    if (e.ctrlKey &amp;&amp; (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '_')) {
        e.preventDefault();
    }
}


</t>
<t tx="felix.20241229190855.1">handleKeyUp(e: KeyboardEvent): void {
    this.keysPressed[e.key] = false;
}

</t>
<t tx="felix.20241229214656.1">loop(timestamp: number): void {
    this.update(timestamp);
    requestAnimationFrame(this.loop.bind(this));
}

</t>
<t tx="felix.20241229230016.1">startGame(): void {
    const resolution = Game.AVAILABLE_RESOLUTIONS[this.resolutionSelectElement.selectedIndex];
    this.aspectRatio = resolution.width / resolution.height;
    this.gameScreenWidth = resolution.width;
    this.gameScreenHeight = resolution.height;
    this.scrollEdgeX = this.gameScreenWidth - Game.SCROLLBORDER; // constants for finding trigger zone
    this.scrollEdgeY = this.gameScreenHeight - Game.SCROLLBORDER;

    // Re-set 
    this.initRangeX = (this.gameScreenWidth / this.tileSize) + 1;
    this.initRangeY = (this.gameScreenHeight / this.tileSize) + 1;
    this.maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;
    this.maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;

    console.log('Starting the game with aspect ratio', this.aspectRatio);

    this.setCursor("cur-pointer");

    this.addGameEventListeners();

    this.startButtonElement.style.display = 'none';
    this.resolutionSelectElement.style.display = 'none';
    this.started = true;
    // Setup timer in case RAF Skipped when minimized or not in foreground.
    setInterval(() =&gt; { this.checkUpdate(); }, 500);
    this.loop(0);
}

</t>
<t tx="felix.20241230214840.1">processKeyInputs(): void {
    if (this.keysPressed['ArrowUp'] || this.keysPressed['w']) {
        //
    }
    if (this.keysPressed['ArrowDown'] || this.keysPressed['s']) {
        //
    }
    if (this.keysPressed['ArrowLeft'] || this.keysPressed['a']) {
        // 
    }
    if (this.keysPressed['ArrowRight'] || this.keysPressed['d']) {
        //
    }
}

</t>
<t tx="felix.20241230215224.1">procGame(): void {

    // procgame processes a game frame, animating each RFA
    // Note: This is not a game-states tick, at timePerTick intervals.

    if (this.gameAction) {

        switch (this.gameAction) {
            case Game.GAME_ACTIONS.DEFAULT:
                this.trydefault()
                break;
            case Game.GAME_ACTIONS.RELEASESEL:
                this.tryselect()
                break;

            default:
                break;
        }

    }

    this.gameAction = 0 // -------------- no more game actions to do

    // Scroll if not selected    
    if (!this.selecting) {
        this.scrollX += this.scrollNowX;
        this.scrollY += this.scrollNowY;
        if (this.scrollX &gt; this.maxScrollX) {
            this.scrollX = this.maxScrollX;
        }
        if (this.scrollX &lt; 0) {
            this.scrollX = 0;
        }
        if (this.scrollY &gt; this.maxScrollY) {
            this.scrollY = this.maxScrollY;
        }
        if (this.scrollY &lt; 0) {
            this.scrollY = 0;
        }
    }
}

</t>
<t tx="felix.20241230215229.1">tick(): void {

    // Advance game states in pool:
    // meaning, from currentTick count, to the next one.

    // #########################################

    /*
    let processed = 0;
    let entity;
    for (let i = 0; processed &lt; this.entities.active || i &lt; this.entities.total; i++) {
        entity = this.entities.pool[i];
        if (entity.active) {
            processed += 1;
            this.ai.process(entity);
        }
    }
    */

    this.processKeyInputs();

    // Update currentTick count
    this.currentTick += 1;
}

</t>
<t tx="felix.20241230215401.1">trydefault(): void {

    // TODO : Replace with test cursor animation with the real default action
    // TEST START WIDGET ANIMATION ON DEFAULT ACTION
    this.widgetAnim = 1;
    this.widgetAnimX = this.gameMouseX - 32;
    this.widgetAnimY = this.gameMouseY - 32;

}

</t>
<t tx="felix.20241230215406.1">tryselect(): void {
    // Called from procGame
}

</t>
<t tx="felix.20241231221007.1">render(interpolation: number): void {

    // Before rendering, resize canvas to display size. (in case of changing window size)
    this.resizeCanvasToDisplaySize(this.canvasElement);

    // Clear the canvas
    this.glContext.clearColor(0.0, 0.0, 0.0, 1.0); // Set base buffer color to black 
    this.glContext.clear(this.glContext.COLOR_BUFFER_BIT);

    this.glContext.clearColor(0.0, 0.0, 0.0, 0.0); // Set base buffer color to black fully transparent

    // Render the game

    // TODO: Render the game map
    // TODO: Render the game entities

    // Finished
    this.glContext.flush();
}

</t>
<t tx="felix.20241231222558.1">interpolate(min: Point, max: Point, fract: number): Point {
    return new Point(max.x + (min.x - max.x) * fract, max.y + (min.y - max.y) * fract);
}

</t>
<t tx="felix.20241231225835.1">animateCursor(): void {
    // Animate at 15 FPS

    // Cursor
    if (this.widgetAnim) {
        this.widgetAnim += 1;
        if (this.widgetAnim &gt; this.widgetAnimTotal)
            this.widgetAnim = 0
    }

}

</t>
<t tx="felix.20250101211507.1">setCursor(newClass: string) {
    if (this.currentCursorClass !== newClass) {
        if (this.currentCursorClass) {
            this.documentElementClassList.remove(this.currentCursorClass); // Remove from html
        }
        this.documentElementClassList.add(newClass); // Add to html
        this.currentCursorClass = newClass; // Update the tracked cursor class
    }
}

</t>
<t tx="felix.20250101212200.1">setCursorPos(event: MouseEvent): void {
    this.mouseX = event.clientX * (this.gameScreenWidth / this.canvasBoundingRect.width);
    this.mouseY = event.clientY * (this.gameScreenHeight / this.canvasBoundingRect.height);
}

</t>
<t tx="felix.20250101222813.1">setDimensionsVars(): DOMRect {
    this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();
    this.gameWidthRatio = (this.gameScreenWidth / this.canvasBoundingRect.width);
    this.gameHeightRatio = (this.gameScreenHeight / this.canvasBoundingRect.height)
    this.maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;
    this.maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;
    return this.canvasBoundingRect;
}

</t>
</tnodes>
</leo_file>
