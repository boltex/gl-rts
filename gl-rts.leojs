{
  "leoHeader": {
    "fileFormat": 2
  },
  "vnodes": [
    {
      "gnx": "felix.20241217200720.1",
      "vh": "introduction"
    },
    {
      "gnx": "felix.20241227202430.1",
      "vh": "@clean src/main.ts",
      "children": [
        {
          "gnx": "felix.20241227202519.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20241227213048.1",
          "vh": "Create Game"
        }
      ]
    },
    {
      "gnx": "felix.20250131210259.1",
      "vh": "@clean src/game.ts",
      "children": [
        {
          "gnx": "felix.20250131211056.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20241227213056.1",
          "vh": "class Game",
          "children": [
            {
              "gnx": "felix.20241227213841.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250202181151.1",
              "vh": "dispose"
            },
            {
              "gnx": "felix.20241227213217.1",
              "vh": "handleCanvasResize"
            },
            {
              "gnx": "felix.20241228191055.1",
              "vh": "resizeCanvasToDisplaySize"
            },
            {
              "gnx": "felix.20241229230016.1",
              "vh": "startGame"
            },
            {
              "gnx": "felix.20250105213621.1",
              "vh": "initGameStates"
            },
            {
              "gnx": "felix.20250315233643.1",
              "vh": "toggleShowFPS"
            },
            {
              "gnx": "felix.20250216154916.1",
              "vh": "setResolution"
            },
            {
              "gnx": "felix.20250217230642.1",
              "vh": "setGameSpeed"
            },
            {
              "gnx": "felix.20250215192808.1",
              "vh": "incrementGameSpeed"
            },
            {
              "gnx": "felix.20250215192823.1",
              "vh": "decrementGameSpeed"
            },
            {
              "gnx": "felix.20250217230732.1",
              "vh": "setKeyboardSpeed"
            },
            {
              "gnx": "felix.20250216160422.1",
              "vh": "incrementKeyboardSpeed"
            },
            {
              "gnx": "felix.20250216160438.1",
              "vh": "decrementKeyboardSpeed"
            },
            {
              "gnx": "felix.20250217230808.1",
              "vh": "setScrollSpeed"
            },
            {
              "gnx": "felix.20250216160324.1",
              "vh": "incrementScrollSpeed"
            },
            {
              "gnx": "felix.20250216160347.1",
              "vh": "decrementScrollSpeed"
            },
            {
              "gnx": "felix.20250217230846.1",
              "vh": "setDragSpeed"
            },
            {
              "gnx": "felix.20250216160803.1",
              "vh": "incrementDragSpeed"
            },
            {
              "gnx": "felix.20250216160821.1",
              "vh": "decrementDragSpeed"
            },
            {
              "gnx": "felix.20250216160848.1",
              "vh": "changeInvertDrag"
            },
            {
              "gnx": "felix.20241230215224.1",
              "vh": "procGame"
            },
            {
              "gnx": "felix.20241227213236.1",
              "vh": "update"
            },
            {
              "gnx": "felix.20241229162229.1",
              "vh": "checkUpdate"
            },
            {
              "gnx": "felix.20241230215229.1",
              "vh": "tick"
            },
            {
              "gnx": "felix.20241229214656.1",
              "vh": "loop"
            },
            {
              "gnx": "felix.20241230215401.1",
              "vh": "defaultAction"
            },
            {
              "gnx": "felix.20241230215406.1",
              "vh": "selectUnits"
            },
            {
              "gnx": "felix.20250318215714.1",
              "vh": "toggleMusic"
            },
            {
              "gnx": "felix.20250322192420.1",
              "vh": "setMusicEnabled"
            },
            {
              "gnx": "felix.20250322003545.1",
              "vh": "setMusicVolume"
            },
            {
              "gnx": "felix.20250322003551.1",
              "vh": "incrementMusicVolume"
            },
            {
              "gnx": "felix.20250322003539.1",
              "vh": "decrementMusicVolume"
            },
            {
              "gnx": "felix.20250318215721.1",
              "vh": "toggleSound"
            },
            {
              "gnx": "felix.20250322192447.1",
              "vh": "setSoundEnabled"
            },
            {
              "gnx": "felix.20250322003603.1",
              "vh": "setSoundVolume"
            },
            {
              "gnx": "felix.20250322003607.1",
              "vh": "incrementSoundVolume"
            },
            {
              "gnx": "felix.20250322003559.1",
              "vh": "decrementSoundVolume"
            },
            {
              "gnx": "felix.20250318215802.1",
              "vh": "toggleTerrain"
            },
            {
              "gnx": "felix.20250208202349.1",
              "vh": "setTileAt"
            },
            {
              "gnx": "felix.20250208205929.1",
              "vh": "getTileAt"
            },
            {
              "gnx": "felix.20250209010754.1",
              "vh": "saveMap"
            },
            {
              "gnx": "felix.20250209010800.1",
              "vh": "openMap"
            },
            {
              "gnx": "felix.20250210235944.1",
              "vh": "saveEntities"
            },
            {
              "gnx": "felix.20250211000007.1",
              "vh": "openEntities"
            },
            {
              "gnx": "felix.20250210235953.1",
              "vh": "saveAnimations"
            },
            {
              "gnx": "felix.20250211000023.1",
              "vh": "openAnimations"
            },
            {
              "gnx": "felix.20250216171203.1",
              "vh": "saveSettingsLocalStorage"
            },
            {
              "gnx": "felix.20250216171217.1",
              "vh": "loadSettingsLocalStorage"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210715.1",
      "vh": "@clean src/input-manager.ts",
      "children": [
        {
          "gnx": "felix.20250131211201.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250107221804.1",
          "vh": "class InputManager",
          "children": [
            {
              "gnx": "felix.20250107221855.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250216143132.1",
              "vh": "setKeyboardSpeed"
            },
            {
              "gnx": "felix.20250216143150.1",
              "vh": "setScrollSpeed"
            },
            {
              "gnx": "felix.20250216143220.1",
              "vh": "setDragSpeed"
            },
            {
              "gnx": "felix.20250107232140.1",
              "vh": "getters"
            },
            {
              "gnx": "felix.20250107230733.1",
              "vh": "init"
            },
            {
              "gnx": "felix.20250202204636.1",
              "vh": "dispose"
            },
            {
              "gnx": "felix.20250107230755.1",
              "vh": "handleKeyDown"
            },
            {
              "gnx": "felix.20250107230802.1",
              "vh": "handleKeyUp"
            },
            {
              "gnx": "felix.20250314173735.1",
              "vh": "handleMouseEnter"
            },
            {
              "gnx": "felix.20250314173741.1",
              "vh": "handleMouseLeave"
            },
            {
              "gnx": "felix.20250107230806.1",
              "vh": "handleMouseMove"
            },
            {
              "gnx": "felix.20250320230314.1",
              "vh": "handleMinimapInteraction"
            },
            {
              "gnx": "felix.20250320230955.1",
              "vh": "handleMapEditorInteraction"
            },
            {
              "gnx": "felix.20250314153934.1",
              "vh": "applyMouseScroll"
            },
            {
              "gnx": "felix.20250107230811.1",
              "vh": "handleMouseDown"
            },
            {
              "gnx": "felix.20250107230817.1",
              "vh": "handleMouseUp"
            },
            {
              "gnx": "felix.20250107230822.1",
              "vh": "handleMouseWheel"
            },
            {
              "gnx": "felix.20250107230828.1",
              "vh": "setCursorPos"
            },
            {
              "gnx": "felix.20250107230906.1",
              "vh": "processInputs"
            },
            {
              "gnx": "felix.20250107230936.1",
              "vh": "isSelecting"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003719.1",
      "vh": "@clean src/renderer-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201003821.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250201171432.1",
          "vh": "class RendererManager",
          "children": [
            {
              "gnx": "felix.20250201171528.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250322190011.1",
              "vh": "toggleTerrain"
            },
            {
              "gnx": "felix.20250205232454.1",
              "vh": "initUboBindings"
            },
            {
              "gnx": "felix.20250201171626.1",
              "vh": "setUboWorldTransforms"
            },
            {
              "gnx": "felix.20250201171643.1",
              "vh": "render"
            },
            {
              "gnx": "felix.20250201171639.1",
              "vh": "dispose"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250322135329.1",
      "vh": "@clean src/audio-manager.ts",
      "children": [
        {
          "gnx": "felix.20250322135517.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250322135530.1",
          "vh": "class AudioManager",
          "children": [
            {
              "gnx": "felix.20250322135640.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250322184509.1",
              "vh": "setMusicVolume"
            },
            {
              "gnx": "felix.20250322184330.1",
              "vh": "setSoundVolume"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250218223114.1",
      "vh": "@clean src/ui/main-menu-manager.ts",
      "children": [
        {
          "gnx": "felix.20250218224238.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250218224343.1",
          "vh": "class MainMenuManager",
          "children": [
            {
              "gnx": "felix.20250218224623.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250314205653.1",
              "vh": "mainMenu"
            },
            {
              "gnx": "felix.20250314213433.1",
              "vh": "getStartButtonElement"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250323204809.1",
      "vh": "@clean src/ui/help-menu-manager.ts",
      "children": [
        {
          "gnx": "felix.20250323204827.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250323204904.1",
          "vh": "class HelpMenuManager",
          "children": [
            {
              "gnx": "felix.20250323205747.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250323205910.1",
              "vh": "toggleHelp"
            },
            {
              "gnx": "felix.20250323211614.1",
              "vh": "buildHelpMenu"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250225234241.1",
      "vh": "@clean src/ui/options-menu-manager.ts",
      "children": [
        {
          "gnx": "felix.20250225234241.2",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250225234241.3",
          "vh": "class OptionsMenuManager",
          "children": [
            {
              "gnx": "felix.20250225234241.4",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250314210641.1",
              "vh": "toggleMenu"
            },
            {
              "gnx": "felix.20250314210719.1",
              "vh": "cancelMenu"
            },
            {
              "gnx": "felix.20250314210724.1",
              "vh": "setMenuControlValues"
            },
            {
              "gnx": "felix.20250314210729.1",
              "vh": "getResolutionSelectElement"
            },
            {
              "gnx": "felix.20250314210744.1",
              "vh": "buildMenu"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250218223128.1",
      "vh": "@clean src/ui/editor-manager.ts",
      "children": [
        {
          "gnx": "felix.20250218224239.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250218224355.1",
          "vh": "class EditorManager",
          "children": [
            {
              "gnx": "felix.20250218224639.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250314211048.1",
              "vh": "toggleMapEditor"
            },
            {
              "gnx": "felix.20250314211044.1",
              "vh": "getSelectedTileIndex"
            },
            {
              "gnx": "felix.20250314211040.1",
              "vh": "setTileSelectIndex"
            },
            {
              "gnx": "felix.20250314211034.1",
              "vh": "incrementMapTile"
            },
            {
              "gnx": "felix.20250314211031.1",
              "vh": "decrementMapTile"
            },
            {
              "gnx": "felix.20250314211027.1",
              "vh": "incrementAnimation"
            },
            {
              "gnx": "felix.20250314211022.1",
              "vh": "decrementAnimation"
            },
            {
              "gnx": "felix.20250314211017.1",
              "vh": "updateTilePreview"
            },
            {
              "gnx": "felix.20250314211012.1",
              "vh": "updateAnimationPreview"
            },
            {
              "gnx": "felix.20250314211007.1",
              "vh": "buildMapEditor"
            },
            {
              "gnx": "felix.20250314210957.1",
              "vh": "addDragElement"
            },
            {
              "gnx": "felix.20250328190413.1",
              "vh": "toggleAnimationPlayPause"
            },
            {
              "gnx": "felix.20250328190512.1",
              "vh": "toggleAnimationVisibility"
            },
            {
              "gnx": "felix.20250329171733.1",
              "vh": "rotatePreview"
            },
            {
              "gnx": "felix.20250328190757.1",
              "vh": "changeSelectedFrame"
            },
            {
              "gnx": "felix.20250328190808.1",
              "vh": "changeSpriteNumber"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250218223131.1",
      "vh": "@clean src/ui/cursor-manager.ts",
      "children": [
        {
          "gnx": "felix.20250218224241.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250218224356.1",
          "vh": "class CursorManager",
          "children": [
            {
              "gnx": "felix.20250218224627.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250314211411.1",
              "vh": "setCursor"
            },
            {
              "gnx": "felix.20250314211330.1",
              "vh": "animateCursor"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250218223137.1",
      "vh": "@clean src/ui/file-manager.ts",
      "children": [
        {
          "gnx": "felix.20250218224243.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250218224358.1",
          "vh": "class FileManager",
          "children": [
            {
              "gnx": "felix.20250218224631.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250314213037.1",
              "vh": "initFileInput"
            },
            {
              "gnx": "felix.20250314213028.1",
              "vh": "openMapFile"
            },
            {
              "gnx": "felix.20250314213023.1",
              "vh": "saveMapFile"
            },
            {
              "gnx": "felix.20250314213018.1",
              "vh": "openAnimationsFile"
            },
            {
              "gnx": "felix.20250314213014.1",
              "vh": "saveAnimationsFile"
            },
            {
              "gnx": "felix.20250314213010.1",
              "vh": "openEntityListFile"
            },
            {
              "gnx": "felix.20250314213006.1",
              "vh": "saveEntityListFile"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003723.2",
      "vh": "@clean src/camera-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201003827.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250201233259.1",
          "vh": "class CameraManager",
          "children": [
            {
              "gnx": "felix.20250201233355.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250201234908.1",
              "vh": "scroll"
            },
            {
              "gnx": "felix.20250202002655.1",
              "vh": "setResolution"
            },
            {
              "gnx": "felix.20250201233351.1",
              "vh": "updateProperties"
            },
            {
              "gnx": "felix.20250212210804.1",
              "vh": "animateZoom"
            },
            {
              "gnx": "felix.20250201233346.1",
              "vh": "resetZoom"
            },
            {
              "gnx": "felix.20250204221504.1",
              "vh": "zoomIn"
            },
            {
              "gnx": "felix.20250204221510.1",
              "vh": "zoomOut"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250201003723.3",
      "vh": "@clean src/time-manager.ts",
      "children": [
        {
          "gnx": "felix.20250201003825.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250202011725.1",
          "vh": "class TimeManager",
          "children": [
            {
              "gnx": "felix.20250202135345.1",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250215190948.1",
              "vh": "setGameSpeed"
            },
            {
              "gnx": "felix.20250202135338.1",
              "vh": "update"
            },
            {
              "gnx": "felix.20250202135334.1",
              "vh": "shouldAnimUpdate"
            },
            {
              "gnx": "felix.20250202135329.1",
              "vh": "shouldTickUpdate"
            },
            {
              "gnx": "felix.20250202135324.1",
              "vh": "updateFps"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210755.1",
      "vh": "@clean src/entities.ts",
      "children": [
        {
          "gnx": "felix.20250131211133.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250105212000.1",
          "vh": "class Entities",
          "children": [
            {
              "gnx": "felix.20250105212000.2",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250105212000.3",
              "vh": "spawn"
            },
            {
              "gnx": "felix.20250105212000.4",
              "vh": "remove"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210816.1",
      "vh": "@clean src/behaviors.ts",
      "children": [
        {
          "gnx": "felix.20250131211212.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250105212047.1",
          "vh": "class Behaviors",
          "children": [
            {
              "gnx": "felix.20250105212047.2",
              "vh": "constructor"
            },
            {
              "gnx": "felix.20250105212047.3",
              "vh": "process"
            },
            {
              "gnx": "felix.20250327233801.1",
              "vh": "preview"
            },
            {
              "gnx": "felix.20250105212047.4",
              "vh": "alien"
            }
          ]
        }
      ]
    },
    {
      "gnx": "felix.20250131210828.1",
      "vh": "@clean src/renderers.ts",
      "children": [
        {
          "gnx": "felix.20250131211216.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20250126174340.1",
          "vh": "class BaseRenderer"
        },
        {
          "gnx": "felix.20250126193731.1",
          "vh": "class TileRenderer"
        },
        {
          "gnx": "felix.20250315211404.1",
          "vh": "class FontRenderer"
        },
        {
          "gnx": "felix.20250207201240.1",
          "vh": "class WidgetRenderer"
        },
        {
          "gnx": "felix.20250127234240.1",
          "vh": "class SpriteRenderer"
        },
        {
          "gnx": "felix.20250128200945.1",
          "vh": "class RectangleRenderer"
        },
        {
          "gnx": "felix.20250318233413.1",
          "vh": "class MinimapRenderer"
        }
      ]
    },
    {
      "gnx": "felix.20241220002054.1",
      "vh": "@clean src/types.ts",
      "children": [
        {
          "gnx": "felix.20241220002054.3",
          "vh": "types"
        }
      ]
    },
    {
      "gnx": "felix.20241224183015.1",
      "vh": "@clean src/utils.ts",
      "children": [
        {
          "gnx": "felix.20250122233854.1",
          "vh": "<< imports >>"
        },
        {
          "gnx": "felix.20241224183525.1",
          "vh": "fullScreen"
        },
        {
          "gnx": "felix.20250120234029.1",
          "vh": "interpolate"
        },
        {
          "gnx": "felix.20241228192145.1",
          "vh": "loadImage"
        },
        {
          "gnx": "felix.20250202200500.1",
          "vh": "getDisplaySize"
        },
        {
          "gnx": "felix.20250202202711.1",
          "vh": "debounce"
        }
      ]
    },
    {
      "gnx": "felix.20250107011547.1",
      "vh": "@clean src/config.ts"
    },
    {
      "gnx": "felix.20250125002553.1",
      "vh": "@clean src/shaders.ts"
    }
  ],
  "tnodes": {
    "felix.20241217200720.1": "Basic WebGL RTS game engine\n\nBased on the following tutorials:\n\n- Main features use WebGL concepts such as VAO (Vertex Array Objects), UBO (Uniform Buffer Objects), draw instances, and shaders from the Andrew Adamson WebGL tutorials at https://www.youtube.com/watch?v=-T6EbWCq99c&list=PLPbmjY2NVO_X1U1JzLxLDdRn4NmtxyQQo\n\n- Window resize detection and handling for canvas from https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html\n\n- Game class setup inspired by [James Byrde](https://github.com/jamesrehabstudio) tutorials at [https://www.youtube.com/@jamesbyrde3798](https://www.youtube.com/@jamesbyrde3798)\n\n- Timing inspired from the [Glenn Fiedler](https://github.com/gafferongames) tutorial at [https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/)\n\n",
    "felix.20241227202430.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20241227202519.1": "import '../public/style.css';\nimport { Game } from \"./game\";\nimport * as utils from \"./utils\";\n\n",
    "felix.20241227213048.1": "document.addEventListener('DOMContentLoaded', (event) => {\n\n    const loadingText = document.createElement('div');\n    loadingText.classList.add(\"loading-text\");\n    loadingText.textContent = 'Loading...';\n    document.body.appendChild(loadingText);\n\n    const creaturesPromise = utils.loadImage('images/alien.png');\n    const tilesPromise = utils.loadImage('images/map-tiles-vertical.png');\n    const widgetsPromise = utils.loadImage('images/animated-widget-128.png');\n    const fontPromise = utils.loadImage('images/font-texture.png');\n\n    const preloadCursorImages = [\n        \"images/cursor-pointer32.png\",\n        \"images/cursor-target32.png\",\n        \"images/cursor-green1-32.png\",\n        \"images/cursor-green2-32.png\",\n        \"images/cursor-yellow1-32.png\",\n        \"images/cursor-yellow2-32.png\",\n        \"images/cursor-red1-32.png\",\n        \"images/cursor-red2-32.png\",\n        \"images/scroll-bottom32.png\",\n        \"images/scroll-bottom-left32.png\",\n        \"images/scroll-bottom-right32.png\",\n        \"images/scroll-top32.png\",\n        \"images/scroll-top-left32.png\",\n        \"images/scroll-top-right32.png\",\n        \"images/scroll-left32.png\",\n        \"images/scroll-right32.png\"\n    ];\n\n    // Preload cursors for performance\n    preloadCursorImages.forEach((src) => {\n        const img = new Image();\n        img.src = src;\n    });\n\n    Promise.all([creaturesPromise, tilesPromise, widgetsPromise, fontPromise]).then((images) => {\n        document.body.removeChild(loadingText);\n        if (!window.game) {\n            window.game = new Game(images[0], images[1], images[2], images[3]);\n\n            // Clean up on unload\n            window.addEventListener('unload', () => {\n                window.game.dispose();\n            });\n        } else {\n            console.error('Game instance already started');\n        }\n    });\n});\n\n",
    "felix.20250131210259.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211056.1": "import { RendererManager } from \"./renderer-manager\";\nimport { InputManager } from \"./input-manager\";\nimport { Behaviors } from \"./behaviors\";\nimport { Entities } from \"./entities\";\nimport { CONFIG } from './config';\nimport { EntityType, TRectangle, TSelectAnim, Settings, EntityAnimation, TEntity } from \"./types\";\nimport { CameraManager } from \"./camera-manager\";\nimport { TimeManager } from \"./time-manager\";\nimport { CursorManager } from \"./ui/cursor-manager\";\nimport { EditorManager } from \"./ui/editor-manager\";\nimport { FileManager } from \"./ui/file-manager\";\nimport { MainMenuManager } from \"./ui/main-menu-manager\";\nimport { OptionsMenuManager } from \"./ui/options-menu-manager\";\nimport * as utils from \"./utils\";\nimport { AudioManager } from \"./audio-manager\";\nimport { HelpMenuManager } from \"./ui/help-menu-manager\";\n\n",
    "felix.20241227213056.1": "export class Game {\n\n    // Manager classes\n    inputManager: InputManager;\n    rendererManager: RendererManager;\n    cameraManager: CameraManager;\n    timeManager: TimeManager;\n    cursorManager: CursorManager;\n    helpMenuManager: HelpMenuManager;\n    mainMenuManager: MainMenuManager;\n    optionsMenuManager: OptionsMenuManager;\n    fileManager: FileManager;\n    editorManager: EditorManager;\n    audioManager: AudioManager;\n\n    // Canvas Properties\n    lastDisplayWidth = 0;\n    lastDisplayHeight = 0;\n    canvasElement: HTMLCanvasElement;\n    canvasBoundingRect: DOMRect;\n    gl: WebGL2RenderingContext;\n\n    // Game options\n    resolutionIndex: number = CONFIG.DISPLAY.DEFAULT_RESOLUTION; // Affects cameraManager.resolution\n    gameSpeedIndex: number = CONFIG.GAME.TIMING.DEFAULT_SPEED; // Affects timeManager.timePerTick\n    keyboardSpeedIndex: number = CONFIG.CAMERA.SCROLL.DEFAULT_KEYBOARD_SPEED; // Affects inputManager.keyboardSpeed\n    scrollSpeedIndex: number = CONFIG.CAMERA.SCROLL.DEFAULT_SCROLL_SPEED; // Affects inputManager.scrollSpeed\n    dragSpeedIndex: number = CONFIG.CAMERA.SCROLL.DEFAULT_DRAG_SPEED; // Affects inputManager.dragSpeed\n    invertDrag: boolean = CONFIG.CAMERA.SCROLL.DEFAULT_DRAG_INVERT; // Affects inputManager.invertDrag\n    musicEnabled: boolean = true;\n    musicVolume: number = 50;\n    soundEnabled: boolean = true;\n    soundVolume: number = 50;\n\n    // Game editor state\n    previewEntity: TEntity | null = null;\n\n    // Game state Properties\n    started: boolean = false;\n    isMultiplayer: boolean = false;\n    showFPS: boolean = false;\n    gamemap: number[] = [];\n    gameMapChanged: boolean = true;\n    minimapRect: TRectangle[] = [\n        {\n            x: 0,\n            y: 0,\n            width: 0,\n            height: 0,\n            r: 1, // White\n            g: 1,\n            b: 1,\n            a: 0.15\n        }\n    ];\n    gameAction: number = 0;    // 0 = none\n    entities!: Entities;\n    entityBehaviors!: Behaviors;\n    lastScrollX = -1; // initialized at -1 so that we can detect first frame.\n    lastScrollY = -1;\n    lastScreenWidth = -1;\n    lastScreenHeight = -1;\n    animations: EntityAnimation[] = [];\n\n    private startGameHandler = this.startGame.bind(this);\n    private handleContextMenu = (event: MouseEvent) => event.preventDefault();\n    private resizeObserver: ResizeObserver;\n\n    @others\n\n}\n\n",
    "felix.20241227213841.1": "constructor(sprites: HTMLImageElement, tiles: HTMLImageElement, widgets: HTMLImageElement, font: HTMLImageElement) {\n\n    this.canvasElement = document.createElement('canvas');\n    document.body.appendChild(this.canvasElement);\n\n    this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();\n\n    const gl = this.canvasElement.getContext('webgl2');\n    if (gl) {\n        this.gl = gl; // ok, we have a WebGL2 context\n    } else {\n        throw new Error('WebGL2 not supported in this browser'); // Error handling\n    }\n\n    this.gl.enable(this.gl.BLEND);\n    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n    this.gl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black\n\n    // Prevent right-click context menu\n    document.addEventListener('contextmenu', this.handleContextMenu);\n\n    // Canvas has style width: 100vw; and style height: 100vh; so we need to handle resizes!\n    const debouncedResize = utils.debounce(this.handleCanvasResize.bind(this), 250);\n    this.resizeObserver = new ResizeObserver(debouncedResize);\n    this.resizeObserver.observe(this.canvasElement, { box: 'content-box' });\n\n    this.timeManager = new TimeManager();\n    this.cameraManager = new CameraManager(this);\n    this.rendererManager = new RendererManager(this.gl, tiles, sprites, widgets, font);\n    this.inputManager = new InputManager(this);\n    this.inputManager.init(); // Start even before game start to prevent zooming.\n    this.resizeCanvasToDisplaySize(this.canvasElement);\n    this.fileManager = new FileManager(this);\n    this.cursorManager = new CursorManager(this);\n    this.helpMenuManager = new HelpMenuManager(this);\n    this.mainMenuManager = new MainMenuManager(this);\n    this.optionsMenuManager = new OptionsMenuManager(this);\n    this.editorManager = new EditorManager(this, this.fileManager);\n    this.audioManager = new AudioManager(this);\n\n    // Load settings from local storage at start. Those are saved when users presses ok in settings dialog.\n    this.loadSettingsLocalStorage();\n\n    this.mainMenuManager.mainMenu();\n    this.mainMenuManager.getStartButtonElement().addEventListener(\"click\", this.startGameHandler);\n}\n\n",
    "felix.20250202181151.1": "dispose(): void {\n    this.rendererManager.dispose();\n    document.removeEventListener('contextmenu', this.handleContextMenu);\n    this.mainMenuManager.getStartButtonElement().removeEventListener(\"click\", this.startGameHandler);\n    this.resizeObserver.unobserve(this.canvasElement);\n    this.resizeObserver.disconnect();\n    this.inputManager.dispose();\n}\n\n",
    "felix.20241227213217.1": "handleCanvasResize(entries: ResizeObserverEntry[]): void {\n    for (const entry of entries) {\n        const { width: displayWidth, height: displayHeight } = utils.getDisplaySize(entry);\n        this.lastDisplayWidth = displayWidth;\n        this.lastDisplayHeight = displayHeight;\n        this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();\n        this.cameraManager.updateProperties(this.canvasBoundingRect);\n    }\n}\n\n",
    "felix.20241228191055.1": "resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {\n    const displayWidth = this.lastDisplayWidth;\n    const displayHeight = this.lastDisplayHeight;\n\n    const needResize = canvas.width !== displayWidth || canvas.height !== displayHeight;\n    if (needResize) {\n        // Set the canvas dimensions to the display size\n        canvas.width = displayWidth;\n        canvas.height = displayHeight;\n\n        // Set the viewport to fill the canvas\n        this.gl.viewport(0, 0, canvas.width, canvas.height); // This will also clear the canvas  \n        if (this.rendererManager && this.rendererManager.worldBuffer) {\n            this.rendererManager.setUboWorldTransforms(this.cameraManager.gameScreenWidth, this.cameraManager.gameScreenHeight);\n        }\n    }\n    return needResize;\n}\n\n",
    "felix.20241229230016.1": "startGame(): void {\n    this.cameraManager.setResolution(CONFIG.DISPLAY.RESOLUTIONS[this.resolutionIndex]);\n    this.cameraManager.updateProperties(this.canvasBoundingRect);\n    this.rendererManager.setUboWorldTransforms(this.cameraManager.gameScreenWidth, this.cameraManager.gameScreenHeight);\n\n    this.cursorManager.setCursor(\"cur-pointer\");\n\n    this.mainMenuManager.getStartButtonElement().style.display = 'none';\n\n    this.initGameStates();\n    this.started = true;\n    this.timeManager.lastTime = performance.now();\n    setInterval(() => { this.checkUpdate(); }, CONFIG.GAME.TIMING.CHECK_UPDATE_INTERVAL); // Setup timer in case RAF Skipped when minimized\n    this.loop(0);\n}\n\n",
    "felix.20250105213621.1": "initGameStates(): void {\n    this.entities = new Entities(CONFIG.GAME.ENTITY.INITIAL_POOL_SIZE);\n    this.entityBehaviors = new Behaviors(this);\n    // Prepare a 'default' animation of 10 frames going from 1 to 10.\n    this.animations.push({\n        label: 'default',\n        frames: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    });\n\n    // Fill Entities pool\n    // EXPERIMENTAL TEST: Create 3 test Aliens\n    // 1\n    let alien = this.entities.spawn();\n    alien.type = EntityType.ALIEN;\n    alien.hitPoints = 100;\n    alien.size = 128;\n    alien.x = 1100;\n    alien.y = 1100;\n    alien.frameIndex = 33;\n    alien.orientation = 6;\n    // 2\n    alien = this.entities.spawn();\n    alien.type = EntityType.ALIEN;\n    alien.hitPoints = 100;\n    alien.size = 128;\n    alien.x = 0;\n    alien.y = 0;\n    alien.frameIndex = 212;\n    alien.orientation = 5;\n    // 3\n    alien = this.entities.spawn();\n    alien.type = EntityType.ALIEN;\n    alien.hitPoints = 100;\n    alien.size = 128;\n    alien.x = 455;\n    alien.y = 455;\n    alien.frameIndex = 122;\n    alien.orientation = 14;\n\n    // Build Map (Will later be bigger maps loaded from file)\n    // Use Config.GAME.MAP.WIDTH and Config.GAME.MAP.HEIGHT\n    // For now, just fill with random tiles\n    this.gamemap = []; // AS a linear array of size Config.GAME.MAP.WIDTH * Config.GAME.MAP.HEIGHT\n    for (let i = 0; i < CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.MAP.HEIGHT; i++) {\n        this.gamemap.push(Math.floor(Math.random() * 16));\n    }\n}\n\n",
    "felix.20250315233643.1": "toggleShowFPS(): void {\n    this.showFPS = !this.showFPS;\n}\n\n",
    "felix.20250216154916.1": "setResolution(resolutionIndex: number): void {\n    this.resolutionIndex = resolutionIndex;\n    this.cameraManager.setResolution(CONFIG.DISPLAY.RESOLUTIONS[this.resolutionIndex]);\n    this.cameraManager.updateProperties(this.canvasBoundingRect);\n    this.cameraManager.scroll({ dx: 0, dy: 0 });\n    this.rendererManager.setUboWorldTransforms(this.cameraManager.gameScreenWidth, this.cameraManager.gameScreenHeight);\n}\n\n",
    "felix.20250217230642.1": "setGameSpeed(speedIndex: number): void {\n    // Single player only. Prevent if multiplayer.\n    if (this.isMultiplayer) {\n        return;\n    }\n    if (speedIndex >= 0 && speedIndex < CONFIG.GAME.TIMING.GAME_SPEEDS.length) {\n        this.gameSpeedIndex = speedIndex;\n        this.timeManager.setGameSpeed(CONFIG.GAME.TIMING.GAME_SPEEDS[this.gameSpeedIndex].value);\n    }\n}\n\n",
    "felix.20250215192808.1": "incrementGameSpeed(): void {\n    // Single player only. Prevent if multiplayer.\n    if (this.isMultiplayer) {\n        return;\n    }\n    this.gameSpeedIndex += 1;\n    if (this.gameSpeedIndex >= CONFIG.GAME.TIMING.GAME_SPEEDS.length) {\n        this.gameSpeedIndex = CONFIG.GAME.TIMING.GAME_SPEEDS.length - 1;\n    }\n    this.timeManager.setGameSpeed(CONFIG.GAME.TIMING.GAME_SPEEDS[this.gameSpeedIndex].value);\n}\n\n",
    "felix.20250215192823.1": "decrementGameSpeed(): void {\n    // Single player only. Prevent if multiplayer.\n    if (this.isMultiplayer) {\n        return;\n    }\n    this.gameSpeedIndex -= 1;\n    if (this.gameSpeedIndex < 0) {\n        this.gameSpeedIndex = 0;\n    }\n    this.timeManager.setGameSpeed(CONFIG.GAME.TIMING.GAME_SPEEDS[this.gameSpeedIndex].value);\n}\n\n",
    "felix.20250217230732.1": "setKeyboardSpeed(speedIndex: number): void {\n    if (speedIndex >= 0 && speedIndex < CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS.length) {\n        this.keyboardSpeedIndex = speedIndex;\n        this.inputManager.setKeyboardSpeed(CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS[this.keyboardSpeedIndex].value);\n    }\n}\n\n",
    "felix.20250216160422.1": "incrementKeyboardSpeed(): void {\n    this.keyboardSpeedIndex += 1;\n    if (this.keyboardSpeedIndex >= CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS.length) {\n        this.keyboardSpeedIndex = CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS.length - 1;\n    }\n    this.inputManager.setKeyboardSpeed(CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS[this.keyboardSpeedIndex].value);\n}\n\n",
    "felix.20250216160438.1": "decrementKeyboardSpeed(): void {\n    this.keyboardSpeedIndex -= 1;\n    if (this.keyboardSpeedIndex < 0) {\n        this.keyboardSpeedIndex = 0;\n    }\n    this.inputManager.setKeyboardSpeed(CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS[this.keyboardSpeedIndex].value);\n}\n\n",
    "felix.20250217230808.1": "setScrollSpeed(speedIndex: number): void {\n    if (speedIndex >= 0 && speedIndex < CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS.length) {\n        this.scrollSpeedIndex = speedIndex;\n        this.inputManager.setScrollSpeed(CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS[this.scrollSpeedIndex].value);\n    }\n}\n\n",
    "felix.20250216160324.1": "incrementScrollSpeed(): void {\n    this.scrollSpeedIndex += 1;\n    if (this.scrollSpeedIndex >= CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS.length) {\n        this.scrollSpeedIndex = CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS.length - 1;\n    }\n    this.inputManager.setScrollSpeed(CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS[this.scrollSpeedIndex].value);\n}\n\n",
    "felix.20250216160347.1": "decrementScrollSpeed(): void {\n    this.scrollSpeedIndex -= 1;\n    if (this.scrollSpeedIndex < 0) {\n        this.scrollSpeedIndex = 0;\n    }\n    this.inputManager.setScrollSpeed(CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS[this.scrollSpeedIndex].value);\n}\n\n",
    "felix.20250217230846.1": "setDragSpeed(speedIndex: number): void {\n    if (speedIndex >= 0 && speedIndex < CONFIG.CAMERA.SCROLL.DRAG_SPEEDS.length) {\n        this.dragSpeedIndex = speedIndex;\n        this.inputManager.setDragSpeed(CONFIG.CAMERA.SCROLL.DRAG_SPEEDS[this.dragSpeedIndex].value, this.invertDrag);\n    }\n}\n\n",
    "felix.20250216160803.1": "incrementDragSpeed(): void {\n    this.dragSpeedIndex += 1;\n    if (this.dragSpeedIndex >= CONFIG.CAMERA.SCROLL.DRAG_SPEEDS.length) {\n        this.dragSpeedIndex = CONFIG.CAMERA.SCROLL.DRAG_SPEEDS.length - 1;\n    }\n    this.inputManager.setDragSpeed(CONFIG.CAMERA.SCROLL.DRAG_SPEEDS[this.dragSpeedIndex].value, this.invertDrag);\n}\n\n",
    "felix.20250216160821.1": "decrementDragSpeed(): void {\n    this.dragSpeedIndex -= 1;\n    if (this.dragSpeedIndex < 0) {\n        this.dragSpeedIndex = 0;\n    }\n    this.inputManager.setDragSpeed(CONFIG.CAMERA.SCROLL.DRAG_SPEEDS[this.dragSpeedIndex].value, this.invertDrag);\n}\n\n",
    "felix.20250216160848.1": "changeInvertDrag(invert: boolean): void {\n    this.invertDrag = invert;\n    this.inputManager.setDragSpeed(CONFIG.CAMERA.SCROLL.DRAG_SPEEDS[this.dragSpeedIndex].value, this.invertDrag);\n}\n\n",
    "felix.20241230215224.1": "procGame(): void {\n\n    if (this.gameAction) {\n\n        switch (this.gameAction) {\n            case CONFIG.GAME.ACTIONS.DEFAULT:\n                this.defaultAction();\n                break;\n            case CONFIG.GAME.ACTIONS.RELEASESEL:\n                this.selectUnits();\n                break;\n\n            default:\n                break;\n        }\n\n    }\n\n    this.gameAction = 0; // Reset game action after processing\n\n    this.inputManager.processInputs();\n\n}\n\n",
    "felix.20241227213236.1": "update(timestamp: number, skipRender?: boolean): void {\n\n    // 0. Optimize for performance\n    const cursorManager = this.cursorManager;\n    const cameraManager = this.cameraManager;\n    const inputManager = this.inputManager;\n    const timeManager = this.timeManager;\n\n    // 1. Update time\n    const deltaTime = timeManager.update(timestamp);\n\n    // 2. Process immediate user input actions\n    cameraManager.animateZoom();\n    this.procGame();\n\n    // 3. Update constant speed animations if needed\n    while (timeManager.shouldAnimUpdate()) {\n        // Animate cursor and UI hud, minimap, etc. at specific constant speed\n        cursorManager.animateCursor();\n    }\n\n    // 4. Update game logic at specific game-speed if needed\n    while (timeManager.shouldTickUpdate()) {\n        // Advance game states in pool from currentTick count, to the next one.\n        // This is the game logic update, at chosen game speed:\n        // slowest, slower, slow, normal, fast, faster, fastest.\n        this.tick();\n    }\n\n    // 5. Render\n    if (!skipRender) {\n        // Before rendering, resize canvas to display size. (in case of changing window size)\n        this.resizeCanvasToDisplaySize(this.canvasElement)\n\n        // Text to render, such as animation frame number, APM or FPS.\n        const text: [number, number, number, number][] = []; // X, Y, Char Index, Scale\n\n        const visibleTiles: [number, number, number][] = []; // X, Y and Tile Index\n\n        // If camera did not move nor zoom, we can reuse the last visible tiles by leaving visibleTiles empty.\n        const cameraChanged = cameraManager.scrollX !== this.lastScrollX ||\n            cameraManager.scrollY !== this.lastScrollY ||\n            cameraManager.gameScreenWidth !== this.lastScreenWidth ||\n            cameraManager.gameScreenHeight !== this.lastScreenHeight;\n        if (\n            this.gameMapChanged || cameraChanged\n        ) {\n            // Save for next frame to check if camera moved.\n            this.lastScreenWidth = cameraManager.gameScreenWidth;\n            this.lastScreenHeight = cameraManager.gameScreenHeight;\n            this.lastScrollX = cameraManager.scrollX;\n            this.lastScrollY = cameraManager.scrollY;\n            const tilesize = CONFIG.GAME.TILE.SIZE;\n            const tileoffx = Math.floor(this.lastScrollX / tilesize);\n            const tileoffy = Math.floor(this.lastScrollY / tilesize);\n            let rangex = (this.lastScreenWidth / tilesize) + 1;\n            let rangey = (this.lastScreenHeight / tilesize) + 1;\n            if (this.lastScrollX % tilesize > tilesize - (this.lastScreenWidth % tilesize)) {\n                rangex += 1;\n            }\n            if (this.lastScrollY % tilesize > tilesize - (this.lastScreenHeight % tilesize)) {\n                rangey += 1;\n            }\n            for (let y = 0; y < rangey; y++) {\n                for (let x = 0; x < rangex; x++) {\n                    const a = this.gamemap[(tileoffx + x) + ((tileoffy + y) * (CONFIG.GAME.MAP.WIDTH))];\n                    visibleTiles.push(\n                        [x * tilesize - (this.lastScrollX % tilesize),\n                        y * tilesize - (this.lastScrollY % tilesize),\n                            a]\n                    );\n\n                }\n            }\n        }\n\n        // Selection lines with four thin rectangles, if user is selecting.\n        const cursor: TRectangle[] = [];\n        if (inputManager.isSelecting) {\n            // Draw selection rectangle with lines\n            const cx1 = Math.min(inputManager.selX, inputManager.mouseX);\n            const cx2 = Math.max(inputManager.selX, inputManager.mouseX);\n            const cy1 = Math.min(inputManager.selY, inputManager.mouseY);\n            const cy2 = Math.max(inputManager.selY, inputManager.mouseY);\n            const thickness = 2 / cameraManager.zoom; // Divide by zoom to keep thickness constant\n            cursor.push(\n                // Top, bottom, left, right lines\n                { x: cx1, y: cy1, width: cx2 - cx1, height: thickness, r: 0, g: 1, b: 0, a: 1 },\n                { x: cx1, y: cy2, width: cx2 - cx1, height: thickness, r: 0, g: 1, b: 0, a: 1 },\n                { x: cx1, y: cy1, width: thickness, height: cy2 - cy1, r: 0, g: 1, b: 0, a: 1 },\n                { x: cx2, y: cy1, width: thickness, height: cy2 - cy1, r: 0, g: 1, b: 0, a: 1 }\n            );\n        }\n\n        // Minimap camera view rectangle\n        if (cameraChanged) {\n            // Calculate minimap properties (match those used in MinimapRenderer.updateTransformData)\n            const minimapPadding = 10 / cameraManager.zoom;\n            const minimapDisplaySize = Math.min(cameraManager.gameScreenWidth, cameraManager.gameScreenHeight) / CONFIG.UI.MINIMAP_RATIO;\n            const minimapX = minimapPadding;\n            const minimapY = cameraManager.gameScreenHeight - minimapDisplaySize - minimapPadding;\n\n            // Calculate the scale ratio between world space and minimap space\n            const mapWorldWidth = CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.TILE.SIZE;\n            const mapWorldHeight = CONFIG.GAME.MAP.HEIGHT * CONFIG.GAME.TILE.SIZE;\n            const minimapScale = minimapDisplaySize / Math.max(mapWorldWidth, mapWorldHeight);\n\n            // Calculate viewport rectangle in minimap coordinates\n            this.minimapRect[0].x = minimapX + (cameraManager.scrollX * minimapScale);\n            this.minimapRect[0].y = minimapY + (cameraManager.scrollY * minimapScale);\n            this.minimapRect[0].width = cameraManager.gameScreenWidth * minimapScale;\n            this.minimapRect[0].height = cameraManager.gameScreenHeight * minimapScale;\n        }\n\n        // If the map Editor is toggled, add a grid to the visible tiles, also highlight the mouse scroll zones. Also do animations if needed.\n        if (this.editorManager.isMapEditorOpen) {\n\n            const thickness = 2 / cameraManager.zoom; // Divide by zoom to keep thickness constant\n            const tilesize = CONFIG.GAME.TILE.SIZE;\n\n            // if the animation preview is not shown, draw the grid lines.\n            if (!this.editorManager.isAnimationPreviewVisible) {\n                // Draw horizontal grid lines\n                for (let y = 0; y <= CONFIG.GAME.MAP.HEIGHT; y++) {\n                    const lineY = y * tilesize - (this.lastScrollY % tilesize);\n                    cursor.push(\n                        { x: 0, y: lineY, width: this.lastScreenWidth, height: thickness, r: 1, g: 1, b: 1, a: 1 }\n                    );\n                }\n\n                // Draw vertical grid lines \n                for (let x = 0; x <= CONFIG.GAME.MAP.WIDTH; x++) {\n                    const lineX = x * tilesize - (this.lastScrollX % tilesize);\n                    cursor.push(\n                        { x: lineX, y: 0, width: thickness, height: this.lastScreenHeight, r: 1, g: 1, b: 1, a: 1 }\n                    );\n                }\n            }\n\n            // Draw a full rectangle over the tile which contains the current mouse pointer.\n            const tileoffx = Math.floor(cameraManager.scrollX / tilesize);\n            const tileoffy = Math.floor(cameraManager.scrollY / tilesize);\n            const x = Math.floor((inputManager.mouseX + cameraManager.scrollX) / tilesize) - tileoffx;\n            const y = Math.floor((inputManager.mouseY + cameraManager.scrollY) / tilesize) - tileoffy;\n            cursor.push(\n                { x: x * tilesize - (this.lastScrollX % tilesize), y: y * tilesize - (this.lastScrollY % tilesize), width: tilesize, height: tilesize, r: 1, g: 1, b: 1, a: 0.2 }\n            );\n\n            // If animation preview is visible, make sure the special entity is present in the entities pool.\n            // If already there, just update its position, orientation and frame index. \n            // Make sure its centered in the screen relative to the scroll (instead of being fixed on the game map), and also very big.\n            if (this.editorManager.isAnimationPreviewVisible) {\n                const editorManager = this.editorManager;\n                if (!this.previewEntity) {\n                    // spawn it\n                    this.previewEntity = this.entities.spawn();\n                    this.previewEntity.type = EntityType.ALIEN;\n                    this.previewEntity.hitPoints = 100;\n                }\n\n                // Update its position, size, orientation and frame index.\n                this.previewEntity.x = this.lastScreenWidth / 2 + this.lastScrollX;\n                this.previewEntity.y = this.lastScreenHeight / 2 + this.lastScrollY;\n                this.previewEntity.orientation = editorManager.previewAnimationOrientation;\n                // Make it bigger than the other entities, And compensate for zoom to be constant on screen.\n                this.previewEntity.size = 128 * 4 / cameraManager.zoom;\n\n                // Now translate x and y so that it is centered instead of having its top-left corner at origin\n                this.previewEntity.x -= this.previewEntity.size / 2;\n                this.previewEntity.y -= this.previewEntity.size / 2;\n\n                const animIndex = editorManager.currentAnimIndex;\n                const previewFrame = editorManager.previewAnimationFrame;\n                const animations = this.animations\n                this.previewEntity.frameIndex = animations[animIndex].frames[previewFrame];\n\n                // Add text underneath to show the current frame index.\n                const frameIndex = animations[animIndex].frames[previewFrame];\n                const frameString = `Frame: ${previewFrame} of ${animations[animIndex].frames.length}`;\n                const spriteString = `Sprite ${frameIndex} `\n                // Loop each letter in the string and add to the text array\n                let x = cameraManager.gameScreenWidth / 2 - this.previewEntity.size / 2;\n                let y = cameraManager.gameScreenHeight / 2 - this.previewEntity.size / 2;\n                for (let i = 0; i < frameString.length; i++) {\n                    const charIndex = frameString.charCodeAt(i) - 32;\n                    text.push([x, y, charIndex, 32 / cameraManager.zoom]);\n                    x += CONFIG.FONT_SIZES[charIndex] / cameraManager.zoom;\n                }\n                x = cameraManager.gameScreenWidth / 2 - this.previewEntity.size / 2;\n                y = cameraManager.gameScreenHeight / 2 + 128 / cameraManager.zoom;\n                for (let i = 0; i < spriteString.length; i++) {\n                    const charIndex = spriteString.charCodeAt(i) - 32;\n                    text.push([x, y, charIndex, 32 / cameraManager.zoom]);\n                    x += CONFIG.FONT_SIZES[charIndex] / cameraManager.zoom;\n                }\n            } else {\n                // editor manager is not open, so remove the preview entity if it exists.\n                if (this.previewEntity) {\n                    this.entities.remove(this.previewEntity);\n                    this.previewEntity = null;\n                }\n            }\n        } else {\n            // editor manager is not open, so remove the preview entity if it exists.\n            if (this.previewEntity) {\n                this.entities.remove(this.previewEntity);\n                this.previewEntity = null;\n            }\n        }\n\n        // Animated selection widget, if any.\n        const visibleWidgets: [number, number, number, number][] = []; // X, Y and Tile Index\n        if (cursorManager.widgetAnim > 0) {\n            visibleWidgets.push([\n                cursorManager.widgetAnimX - cameraManager.scrollX,\n                cursorManager.widgetAnimY - cameraManager.scrollY,\n                cursorManager.widgetAnimFrames[cursorManager.widgetAnim], // 0-3 are other, animate 6 frames from 4 to 9.\n                CONFIG.GAME.WIDGETS.SIZE / 2  // half of 128 is 64\n            ]);\n        }\n\n        if (this.showFPS) {\n            const fps = 'FPS: ' + timeManager.fps.toString();\n            // Loop each letter in the string and add to the text array\n            let x = 20 / cameraManager.zoom;\n            for (let i = 0; i < fps.length; i++) {\n                const charIndex = fps.charCodeAt(i) - 32;\n                text.push([x, 20 / cameraManager.zoom, charIndex, 32 / cameraManager.zoom]);\n                x += CONFIG.FONT_SIZES[charIndex] / cameraManager.zoom;\n            }\n        }\n\n        this.rendererManager.render(\n            visibleTiles,\n            this.entities.pool,\n            cursor,\n            this.minimapRect,\n            visibleWidgets,\n            text,\n            cameraManager,\n            timeManager.getInterpolation(),\n            this.gamemap,\n            this.gameMapChanged\n        );\n\n        this.gameMapChanged = false; // This now has been rendered.\n    }\n\n    // 6. FPS\n    timeManager.updateFps(timestamp, deltaTime);\n}\n\n",
    "felix.20241229162229.1": "checkUpdate(): void {\n    // Checks for needed ticks to be computed if game is minimized\n    const timestamp = performance.now();\n    if (this.timeManager.needCatchUp(timestamp)) {\n        this.update(timestamp, true);\n    }\n}\n\n",
    "felix.20241230215229.1": "tick(): void {\n\n    // Advance game states in pool from currentTick count, to the next one.\n    let processed = 0;\n    let entity;\n\n    // if the map editor is open and the animation preview is visible, process the preview entity only.\n    if (this.editorManager.isMapEditorOpen && this.editorManager.isAnimationPreviewVisible) {\n\n        for (let i = 0; processed < this.entities.active || i < this.entities.total; i++) {\n            entity = this.entities.pool[i];\n            if (entity.active) {\n                processed += 1;\n                this.entityBehaviors.preview(entity);\n            }\n        }\n\n    } else {\n\n        // Process the real entities\n        for (let i = 0; processed < this.entities.active || i < this.entities.total; i++) {\n            entity = this.entities.pool[i];\n            if (entity.active) {\n                processed += 1;\n                this.entityBehaviors.process(entity);\n            }\n        }\n\n    }\n\n}\n\n",
    "felix.20241229214656.1": "loop(timestamp: number): void {\n    this.update(timestamp);\n    requestAnimationFrame(this.loop.bind(this));\n}\n\n",
    "felix.20241230215401.1": "defaultAction(): void {\n\n    // * This is the 'default' action for a context sensitive right-click (on ground is move, on ennemy is attack, )\n\n    const gamePosition = this.inputManager.gamePosition;\n\n    // TODO : First check if the mouse is over the minimap, \n    // if so, consider the default action to be done on the ground of the coordinates of the minimap. (usually move command)\n\n    // TODO : Replace test cursor animation with the real default action\n    // FOR NOW: START WIDGET ANIMATION ON DEFAULT ACTION\n    this.cursorManager.widgetAnim = 1;\n    this.cursorManager.widgetAnimX = gamePosition.x - 32;\n    this.cursorManager.widgetAnimY = gamePosition.y - 32;\n}\n\n",
    "felix.20241230215406.1": "selectUnits(): void {\n\n    // Called from procGame\n    const selectionStart = this.inputManager.selectionStart;\n    const selectionEnd = this.inputManager.selectionEnd;\n\n    // console.log('select', selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);\n    // TODO : Add selection logic here\n\n}\n\n",
    "felix.20250318215714.1": "toggleMusic(): void {\n    this.musicEnabled = !this.musicEnabled;\n    this.audioManager.setMusicVolume(this.musicEnabled ? this.musicVolume / 100 : 0);\n}\n\n",
    "felix.20250322192420.1": "setMusicEnabled(value: boolean): void {\n    this.musicEnabled = value;\n    this.audioManager.setMusicVolume(this.musicEnabled ? this.musicVolume / 100 : 0);\n}\n\n",
    "felix.20250322003545.1": "setMusicVolume(volume: number): void {\n    this.musicVolume = volume;\n    this.audioManager.setMusicVolume(this.musicEnabled ? this.musicVolume / 100 : 0);\n}\n\n",
    "felix.20250322003551.1": "incrementMusicVolume(): void {\n    this.musicVolume += 5;\n    this.musicVolume = Math.ceil(this.musicVolume / 5) * 5;\n    if (this.musicVolume > 100) {\n        this.musicVolume = 100;\n    }\n    this.audioManager.setMusicVolume(this.musicEnabled ? this.musicVolume / 100 : 0);\n}\n\n",
    "felix.20250322003539.1": "decrementMusicVolume(): void {\n    this.musicVolume -= 5;\n    this.musicVolume = Math.ceil(this.musicVolume / 5) * 5;\n    if (this.musicVolume < 0) {\n        this.musicVolume = 0;\n    }\n    this.audioManager.setMusicVolume(this.musicEnabled ? this.musicVolume / 100 : 0);\n}\n\n",
    "felix.20250318215721.1": "toggleSound(): void {\n    this.soundEnabled = !this.soundEnabled;\n    this.audioManager.setSoundVolume(this.soundEnabled ? this.soundVolume / 100 : 0);\n}\n\n",
    "felix.20250322192447.1": "setSoundEnabled(value: boolean): void {\n    this.soundEnabled = value;\n    this.audioManager.setSoundVolume(this.soundEnabled ? this.soundVolume / 100 : 0);\n}\n\n",
    "felix.20250322003603.1": "setSoundVolume(volume: number): void {\n    this.soundVolume = volume;\n    this.audioManager.setSoundVolume(this.soundEnabled ? this.soundVolume / 100 : 0);\n}\n\n",
    "felix.20250322003607.1": "incrementSoundVolume(): void {\n    this.soundVolume += 5;\n    this.soundVolume = Math.ceil(this.soundVolume / 5) * 5;\n    if (this.soundVolume > 100) {\n        this.soundVolume = 100;\n    }\n    this.audioManager.setSoundVolume(this.soundEnabled ? this.soundVolume / 100 : 0);\n}\n\n",
    "felix.20250322003559.1": "decrementSoundVolume(): void {\n    this.soundVolume -= 5;\n    this.soundVolume = Math.ceil(this.soundVolume / 5) * 5;\n    if (this.soundVolume < 0) {\n        this.soundVolume = 0;\n    }\n    this.audioManager.setSoundVolume(this.soundEnabled ? this.soundVolume / 100 : 0);\n}\n\n",
    "felix.20250318215802.1": "toggleTerrain(): void {\n    this.rendererManager.toggleTerrain();\n    this.gameMapChanged = true;\n}\n\n",
    "felix.20250208202349.1": "setTileAt(gameMouseX: number, gameMouseY: number, tileIndex: number): void {\n    // Replace tile in gameMap at gameMouseX, gameMouseY with tileIndex\n    // So we need to know the tile size, and the scroll position. Also set gameMapChanged.\n\n    const tilesize = CONFIG.GAME.TILE.SIZE;\n    // Convert game coordinates to tile grid coordinates\n    const tileX = Math.floor(gameMouseX / tilesize);\n    const tileY = Math.floor(gameMouseY / tilesize);\n    // Compute the tile index for the linear gamemap array\n    const index = tileX + (tileY * CONFIG.GAME.MAP.WIDTH);\n\n    if (index < 0 || index >= this.gamemap.length) {\n        console.warn(`Tile position out of bounds: (${tileX}, ${tileY})`);\n        return;\n    }\n\n    this.gamemap[index] = tileIndex;\n    this.gameMapChanged = true;\n}\n\n",
    "felix.20250208205929.1": "sampleTileAt(gameMouseX: number, gameMouseY: number): void {\n    // This is the opposite of setTileAt, it samples the tile at gameMouseX, gameMouseY\n    // and sets the UI to the selected tile.\n    const tilesize = CONFIG.GAME.TILE.SIZE;\n    // Convert game coordinates to tile grid coordinates\n    const tileX = Math.floor(gameMouseX / tilesize);\n    const tileY = Math.floor(gameMouseY / tilesize);\n    // Compute the tile index in the gamemap\n    const index = tileX + (tileY * CONFIG.GAME.MAP.WIDTH);\n\n    if (index < 0 || index >= this.gamemap.length) {\n        console.warn(`Tile position out of bounds: (${tileX}, ${tileY})`);\n        return;\n    }\n\n    const sampledTile = this.gamemap[index];\n\n    this.editorManager.setTileSelectIndex(sampledTile);\n}\n\n",
    "felix.20250209010754.1": "saveMap(mapData?: number[], filename?: string) {\n    if (!mapData) {\n        mapData = this.gamemap;\n    }\n    if (!filename) {\n        filename = `map_${CONFIG.GAME.MAP.WIDTH}_${CONFIG.GAME.MAP.HEIGHT}.json`;\n\n    }\n    const jsonString = JSON.stringify(mapData, null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n\n    const link = document.createElement(\"a\");\n    link.href = URL.createObjectURL(blob);\n    link.download = filename;\n\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\n\n\n",
    "felix.20250209010800.1": "openMap(jsonData: number[]) {\n    // Load the map from a JSON file\n    this.gamemap = jsonData;\n    this.gameMapChanged = true;\n}\n\n",
    "felix.20250210235944.1": "saveEntities(): void {\n    // TODO : Save the entities list (only for active, not all pool)\n    console.log(\"Save Entities!\");\n}\n\n",
    "felix.20250211000007.1": "openEntities(): void {\n    // TODO : Open an entities list from file, replacing the current entities list\n    // The file is a JSON file containing an array of entities\n    console.log(\"Open Entities!\");\n}\n\n",
    "felix.20250210235953.1": "saveAnimations(animations?: EntityAnimation[]): void {\n    if (!animations) {\n        animations = this.animations;\n    }\n    const jsonString = JSON.stringify(animations, null, 2);\n    const blob = new Blob([jsonString], { type: \"application/json\" });\n\n    const link = document.createElement(\"a\");\n    link.href = URL.createObjectURL(blob);\n    link.download = \"animations.json\";\n\n    document.body.appendChild(link);\n    link.click();\n    document.body.removeChild(link);\n}\n\n",
    "felix.20250211000023.1": "openAnimations(jsonData: EntityAnimation[]): void {\n    // Load the animations from a JSON file\n    this.animations = jsonData;\n    // Refresh the editor's animations list\n    this.editorManager.updateAnimationPreview();\n}\n\n",
    "felix.20250216171203.1": "saveSettingsLocalStorage(): void {\n    const settings: Settings = {\n        resolutionIndex: this.resolutionIndex,\n        gameSpeedIndex: this.gameSpeedIndex,\n        keyboardSpeedIndex: this.keyboardSpeedIndex,\n        scrollSpeedIndex: this.scrollSpeedIndex,\n        dragSpeedIndex: this.dragSpeedIndex,\n        invertDrag: this.invertDrag,\n        musicEnabled: this.musicEnabled,\n        musicVolume: this.musicVolume,\n        soundEnabled: this.soundEnabled,\n        soundVolume: this.soundVolume\n    };\n    localStorage.setItem('settings', JSON.stringify(settings));\n}\n\n",
    "felix.20250216171217.1": "loadSettingsLocalStorage(): void {\n    const settings = localStorage.getItem('settings');\n    // If inexistant settings, the defaults will remain.\n    if (settings) {\n        const parsedSettings = JSON.parse(settings);\n\n        this.resolutionIndex = parsedSettings.resolutionIndex ?? this.resolutionIndex;\n        this.gameSpeedIndex = parsedSettings.gameSpeedIndex ?? this.gameSpeedIndex;\n        this.keyboardSpeedIndex = parsedSettings.keyboardSpeedIndex ?? this.keyboardSpeedIndex;\n        this.scrollSpeedIndex = parsedSettings.scrollSpeedIndex ?? this.scrollSpeedIndex;\n        this.dragSpeedIndex = parsedSettings.dragSpeedIndex ?? this.dragSpeedIndex;\n        this.invertDrag = parsedSettings.invertDrag ?? this.invertDrag;\n        this.musicEnabled = parsedSettings.musicEnabled ?? this.musicEnabled;\n        this.musicVolume = parsedSettings.musicVolume ?? this.musicVolume;\n        this.soundEnabled = parsedSettings.soundEnabled ?? this.soundEnabled;\n        this.soundVolume = parsedSettings.soundVolume ?? this.soundVolume;\n\n        this.setResolution(this.resolutionIndex);\n        this.setGameSpeed(this.gameSpeedIndex);\n        this.setKeyboardSpeed(this.keyboardSpeedIndex);\n        this.setScrollSpeed(this.scrollSpeedIndex);\n        this.setDragSpeed(this.dragSpeedIndex);\n        this.changeInvertDrag(this.invertDrag);\n    }\n}\n\n",
    "felix.20250131210715.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211201.1": "import { Game } from \"./game\";\nimport { CONFIG } from './config';\n\n",
    "felix.20250107221804.1": "export class InputManager {\n    private game: Game;\n    private keyboardSpeed: number;\n    private scrollSpeed: number;\n    private dragSpeed: number;\n    private invertDrag: boolean = false;\n\n    private keysPressed: Record<string, boolean> = {};\n    private selecting: boolean = false;\n    private minimapDragging: boolean = false;\n    private dragScrolling: boolean = false;\n    private borderScrolling: boolean = false;\n    public mouseInScreen = true;\n    public mouseX = 0;  // in gameScreen coordinates.\n    public mouseY = 0;\n    private gameMouseX = 0; // In game coordinates. with zoom factor applied.\n    private gameMouseY = 0;\n    public selX = 0;\n    public selY = 0;\n    private gameSelStartX = 0;\n    private gameSelStartY = 0;\n    private gameSelEndX = 0;\n    private gameSelEndY = 0;\n    private scrollNowX = 0;\n    private scrollNowY = 0;\n    private lastMouseX = 0\n    private lastMouseY = 0;\n\n    private keyboardUp = false;\n    private keyboardDown = false;\n    private keyboardLeft = false;\n    private keyboardRight = false;\n\n    private keyDownHandler = this.handleKeyDown.bind(this);\n    private keyUpHandler = this.handleKeyUp.bind(this);\n    private mouseEnterHandler = this.handleMouseEnter.bind(this);\n    private mouseLeaveHandler = this.handleMouseLeave.bind(this);\n    private mouseMoveHandler = this.handleMouseMove.bind(this);\n    private mouseDownHandler = this.handleMouseDown.bind(this);\n    private mouseUpHandler = this.handleMouseUp.bind(this);\n    private mouseWheelHandler = this.handleMouseWheel.bind(this);\n\n    @others\n\n}\n\n",
    "felix.20250107221855.1": "constructor(game: Game) {\n    this.game = game;\n    this.keyboardSpeed = CONFIG.CAMERA.SCROLL.KEYBOARD_SPEEDS[CONFIG.CAMERA.SCROLL.DEFAULT_KEYBOARD_SPEED].value;\n    this.scrollSpeed = CONFIG.CAMERA.SCROLL.SCROLL_SPEEDS[CONFIG.CAMERA.SCROLL.DEFAULT_SCROLL_SPEED].value;\n    this.dragSpeed = CONFIG.CAMERA.SCROLL.DRAG_SPEEDS[CONFIG.CAMERA.SCROLL.DEFAULT_DRAG_SPEED].value;\n    this.invertDrag = CONFIG.CAMERA.SCROLL.DEFAULT_DRAG_INVERT;\n}\n\n",
    "felix.20250216143132.1": "setKeyboardSpeed(keyboardSpeed: number): void {\n    this.keyboardSpeed = keyboardSpeed;\n}\n\n",
    "felix.20250216143150.1": "setScrollSpeed(scrollSpeed: number): void {\n    this.scrollSpeed = scrollSpeed;\n}\n\n",
    "felix.20250216143220.1": "setDragSpeed(dragSpeed: number, invertDrag: boolean): void {\n    this.dragSpeed = dragSpeed;\n    this.invertDrag = invertDrag;\n}\n\n",
    "felix.20250107232140.1": "get gamePosition(): { x: number, y: number } {\n    return { x: this.gameMouseX, y: this.gameMouseY };\n}\n\nget selectionStart(): { x: number, y: number } {\n    return { x: this.gameSelStartX, y: this.gameSelStartY };\n}\n\nget selectionEnd(): { x: number, y: number } {\n    return { x: this.gameSelEndX, y: this.gameSelEndY };\n}\n\nget scrollVelocity(): { dx: number, dy: number } {\n    return { dx: this.scrollNowX, dy: this.scrollNowY };\n}\n\n",
    "felix.20250107230733.1": "init(): void {\n    window.addEventListener(\"keydown\", this.keyDownHandler);\n    window.addEventListener(\"keyup\", this.keyUpHandler);\n    document.documentElement.addEventListener(\"mouseenter\", this.mouseEnterHandler);\n    document.documentElement.addEventListener(\"mouseleave\", this.mouseLeaveHandler);\n    window.addEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.addEventListener(\"mousedown\", this.mouseDownHandler);\n    window.addEventListener(\"mouseup\", this.mouseUpHandler);\n    window.addEventListener(\"wheel\", this.mouseWheelHandler, { passive: false });\n}\n\n",
    "felix.20250202204636.1": "dispose(): void {\n    window.removeEventListener(\"keydown\", this.keyDownHandler);\n    window.removeEventListener(\"keyup\", this.keyUpHandler);\n    document.documentElement.removeEventListener(\"mouseenter\", this.mouseEnterHandler);\n    document.documentElement.removeEventListener(\"mouseleave\", this.mouseLeaveHandler);\n    window.removeEventListener(\"mousemove\", this.mouseMoveHandler);\n    window.removeEventListener(\"mousedown\", this.mouseDownHandler);\n    window.removeEventListener(\"mouseup\", this.mouseUpHandler);\n    window.removeEventListener(\"wheel\", this.mouseWheelHandler);\n}\n\n",
    "felix.20250107230755.1": "private handleKeyDown(e: KeyboardEvent): void {\n\n    // TODO : The top conditions in this method could be improved! More things should be prevented by default.\n    // For example, the default behavior of the 'F5' or keyboard zooms +/- should also be prevented by default.\n\n    if (this.game.editorManager.isMapEditorOpen) {\n        // Only when in Map Editor (Add tile inc/dec and ctrl+s/ctrl+o shortcuts)\n        if (e.key === 'NumPad+' || e.key === '+' || (!e.shiftKey && e.key === '=')) {\n            e.preventDefault();\n            this.game.editorManager.incrementMapTile();\n            return;\n        }\n        if (e.key === 'NumPad-' || e.key === '-' || e.key === '_') {\n            e.preventDefault();\n            this.game.editorManager.decrementMapTile();\n            return;\n        }\n        if (e.ctrlKey && (e.key === 's' || e.key === 'o')) {\n            e.preventDefault();  // Prevent the default save/open behavior\n        }\n\n        if (this.game.editorManager.isAnimationPreviewVisible) {\n            // If spacebar is pressed, toggle play/pause animation preview.\n            if (e.key === ' ') {\n                e.preventDefault();\n                this.game.editorManager.toggleAnimationPlayPause();\n                return;\n            }\n\n            // If 'a' or 'd' are pressed, rotate the orientation of the preview left/right.\n            if (e.key === 'a' || e.key === 'd') {\n                e.preventDefault();\n                this.game.editorManager.rotatePreview(e.key === 'a' ? -1 : 1);\n                return;\n            }\n\n            // If left/right arrows are pressed, change selected frame.\n            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {\n                e.preventDefault();\n                this.game.editorManager.changeSelectedFrame(e.key === 'ArrowLeft' ? -1 : 1);\n                return;\n            }\n\n            // If up/down arrows are pressed, change the sprite number at the current frame.\n            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                this.game.editorManager.changeSpriteNumber(e.key === 'ArrowUp' ? 1 : -1);\n                return;\n            }\n\n        }\n\n\n    } else if (!this.game.optionsMenuManager.isMenuOpen) {\n        // Only when not in map editor nor game menu (game speed shortcuts)\n        if (e.key === 'NumPad+' || e.key === '+' || (!e.shiftKey && e.key === '=')) {\n            e.preventDefault();\n            this.game.incrementGameSpeed();\n            return;\n        }\n        if (e.key === 'NumPad-' || e.key === '-' || e.key === '_') {\n            e.preventDefault();\n            this.game.decrementGameSpeed();\n            return;\n        }\n    }\n\n    if (this.game.started) {\n        // Only when the game has started (game shortcuts)\n        if (e.key === 'F1') {\n            e.preventDefault();\n            if (this.game.optionsMenuManager.isMenuOpen || this.game.editorManager.isMapEditorOpen) {\n                return;\n            }\n            this.game.helpMenuManager.toggleHelp();\n            return;\n        }\n        if (e.key === 'F5' || e.ctrlKey && e.key === 'r') {\n            e.preventDefault();\n            return;\n        }\n        if (e.key === 'F9') {\n            e.preventDefault();\n            if (this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n                return;\n            }\n            this.selecting = false;\n            this.dragScrolling = false;\n            this.game.editorManager.toggleMapEditor();\n            return;\n        }\n        if (e.key === 'F10') {\n            e.preventDefault();\n            if (this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n                return; // Use the ok or cancel buttons instead.\n            }\n            this.selecting = false;\n            this.dragScrolling = false;\n            this.game.optionsMenuManager.toggleMenu();\n            return;\n        }\n        if (e.key === 'F6') {\n            e.preventDefault();\n            if (!this.game.optionsMenuManager.isMenuOpen) {\n                this.game.cameraManager.resetZoom();\n            }\n            return;\n        }\n        // Check for the 'escape' key and close the options menu if it's open.\n        if (e.key === 'Escape') {\n            e.preventDefault();\n            if (this.game.optionsMenuManager.isMenuOpen) {\n                this.game.optionsMenuManager.cancelMenu();\n                return;\n            }\n            if (this.game.helpMenuManager.isHelpMenuOpen) {\n                this.game.helpMenuManager.toggleHelp();\n                return;\n            }\n\n            // TODO : If interface is waiting for a target (e.g. building placement), cancel that action.\n\n        }\n        // Check for CTRL+ALT+F for toggling 'showFPS' option.\n        if (e.ctrlKey && e.altKey && e.key === 'f') {\n            e.preventDefault();\n            this.game.toggleShowFPS();\n            return;\n        }\n        // Check for Ctrl+m to toggle the music.\n        if (e.ctrlKey && e.key === 'm') {\n            e.preventDefault();\n            this.game.toggleMusic();\n            return;\n        }\n        // Check for Ctrl+s to toggle the sound.\n        if (e.ctrlKey && e.key === 's') {\n            e.preventDefault();\n            this.game.toggleSound();\n            return;\n        }\n        if (e.ctrlKey && (e.key === 'o')) {\n            e.preventDefault();  // Prevent the default open behavior\n        }\n        // Check for 'tab' to toggle the minimap terrain visibility.\n        if (e.key === 'Tab') {\n            e.preventDefault();\n            this.game.toggleTerrain();\n            return;\n        }\n\n    }\n\n    // To keep track of which keys are currently pressed.\n    this.keysPressed[e.key] = true;\n\n    // If Ctrl + + or Ctrl + - is pressed, prevent the browser from zooming in or out.\n    if (e.ctrlKey && (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '_')) {\n        e.preventDefault();\n    }\n}\n\n",
    "felix.20250107230802.1": "private handleKeyUp(e: KeyboardEvent): void {\n    this.keysPressed[e.key] = false;\n}\n\n",
    "felix.20250314173735.1": "private handleMouseEnter(event: MouseEvent): void {\n    this.mouseInScreen = true;\n}\n\n",
    "felix.20250314173741.1": "private handleMouseLeave(event: MouseEvent): void {\n    this.mouseInScreen = false;\n}\n\n",
    "felix.20250107230806.1": "private handleMouseMove(event: MouseEvent): void {\n    // ignore if not started or in game menu\n    if (!this.game.started || this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n        return;\n    }\n    if (this.dragScrolling) {\n        // first, calculate the difference between the last mouse position and the current one.\n        let dragX = this.lastMouseX - event.clientX;\n        let dragY = this.lastMouseY - event.clientY;\n\n        // Already 'inverted' so flip it if not inverted.\n        if (!this.invertDrag) {\n            dragX = -dragX;\n            dragY = -dragY;\n        }\n\n        // Then, convert the difference to game coordinates.\n        this.scrollNowX = this.dragSpeed * dragX * (this.game.cameraManager.gameScreenWidth / this.game.canvasBoundingRect.width);\n        this.scrollNowY = this.dragSpeed * dragY * (this.game.cameraManager.gameScreenHeight / this.game.canvasBoundingRect.height);\n\n        // Update the cursor to reflect the drag direction based on scrollNowX and scrollNowY.\n        let cursor = 'cur-none';\n\n        // Only update if we're actually moving\n        if (this.scrollNowX !== 0 || this.scrollNowY !== 0) {\n            // Calculate the angle in radians\n            const angle = Math.atan2(this.scrollNowY, this.scrollNowX);\n\n            // Convert to degrees (0-360)\n            let degrees = angle * 180 / Math.PI;\n            if (degrees < 0) {\n                degrees += 360;\n            }\n\n            // Determine direction based on angle with 45-degree segments (±22.5° around each direction)\n            if ((degrees >= 337.5 || degrees < 22.5)) {\n                cursor = 'cur-scroll-right';\n            } else if (degrees >= 22.5 && degrees < 67.5) {\n                cursor = 'cur-scroll-bottom-right';\n            } else if (degrees >= 67.5 && degrees < 112.5) {\n                cursor = 'cur-scroll-bottom';\n            } else if (degrees >= 112.5 && degrees < 157.5) {\n                cursor = 'cur-scroll-bottom-left';\n            } else if (degrees >= 157.5 && degrees < 202.5) {\n                cursor = 'cur-scroll-left';\n            } else if (degrees >= 202.5 && degrees < 247.5) {\n                cursor = 'cur-scroll-top-left';\n            } else if (degrees >= 247.5 && degrees < 292.5) {\n                cursor = 'cur-scroll-top';\n            } else if (degrees >= 292.5 && degrees < 337.5) {\n                cursor = 'cur-scroll-top-right';\n            }\n        }\n        this.game.cursorManager.setCursor(cursor);\n    }\n    this.setCursorPos(event);\n    if (this.minimapDragging) {\n        // Check minimap first\n        if (this.handleMinimapInteraction()) {\n            return;\n        }\n    }\n    // Map editor mode\n    if (this.game.editorManager.isMapEditorOpen) {\n        if (this.handleMapEditorInteraction(event)) {\n            return;\n        }\n        // We only returned if it was a click that interacted with the map editor.\n    }\n    this.applyMouseScroll();\n}\n\n",
    "felix.20250320230314.1": "private handleMinimapInteraction(): boolean {\n    const cameraManager = this.game.cameraManager;\n\n    // Calculate minimap bounds\n    const minimapPadding = 10 / cameraManager.zoom;\n    const minimapDisplaySize = Math.min(cameraManager.gameScreenWidth, cameraManager.gameScreenHeight) / CONFIG.UI.MINIMAP_RATIO;\n    const minimapX = minimapPadding;\n    const minimapY = cameraManager.gameScreenHeight - minimapDisplaySize - minimapPadding;\n\n    // Check if cursor is within minimap bounds, or if it's currently dragging the minimap\n    if (this.minimapDragging ||\n        this.mouseX >= minimapX &&\n        this.mouseX <= minimapX + minimapDisplaySize &&\n        this.mouseY >= minimapY &&\n        this.mouseY <= minimapY + minimapDisplaySize) {\n\n        // Calculate world position from minimap coordinates\n        const mapWorldWidth = CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.TILE.SIZE;\n        const mapWorldHeight = CONFIG.GAME.MAP.HEIGHT * CONFIG.GAME.TILE.SIZE;\n\n        // Clamp mouse position to minimap bounds because we allowed dragging outside the minimap\n        const cappedMouseX = Math.min(Math.max(this.mouseX, minimapX), minimapX + minimapDisplaySize);\n        const cappedmouseY = Math.min(Math.max(this.mouseY, minimapY), minimapY + minimapDisplaySize);\n\n        // Calculate relative position within minimap (0 to 1)\n        const minimapRelativeX = (cappedMouseX - minimapX) / minimapDisplaySize;\n        const minimapRelativeY = (cappedmouseY - minimapY) / minimapDisplaySize;\n\n        // Convert to world position\n        const worldX = minimapRelativeX * mapWorldWidth;\n        const worldY = minimapRelativeY * mapWorldHeight;\n\n        // Center the camera on this position\n        cameraManager.scrollX = worldX - (cameraManager.gameScreenWidth / 2);\n        cameraManager.scrollY = worldY - (cameraManager.gameScreenHeight / 2);\n\n        // Ensure camera stays within bounds\n        cameraManager.scroll();\n        this.minimapDragging = true;\n        return true;\n    }\n    return false;\n}\n\n",
    "felix.20250320230955.1": "private handleMapEditorInteraction(event: MouseEvent): boolean {\n    // Make sure the event is over the canvas, not the map editor UI\n    if (event.target !== this.game.canvasElement) {\n        return false;\n    }\n\n    // Use buttons for move events, button for down events\n    const isLeftButton = event.type === 'mousedown' ? event.button === 0 : event.buttons === 1;\n    const isRightButton = event.type === 'mousedown' ? event.button === 2 : event.buttons === 2;\n\n    if (isLeftButton) {\n        // Replace the clicked tile with the selected one\n        const tileIndex = this.game.editorManager.getSelectedTileIndex();\n        this.game.setTileAt(this.gameMouseX, this.gameMouseY, tileIndex);\n        return true;\n    }\n\n    if (isRightButton) {\n        // Sample the tile at the clicked position\n        this.game.sampleTileAt(this.gameMouseX, this.gameMouseY);\n        return true;\n    }\n\n    return false;\n}\n\n",
    "felix.20250314153934.1": "/**\n * Set the scroll velocity based on the mouse position.\n */\nprivate applyMouseScroll(): void {\n    if (!this.selecting) {\n        if (!this.dragScrolling) {\n            this.scrollNowX = 0;\n            this.scrollNowY = 0;\n        }\n        const fps = this.game.timeManager.fps || 1; // Avoid division by zero.\n        let cursor: string | undefined;\n        const camera = this.game.cameraManager;\n        const scrollSpeed = this.scrollSpeed * (30 / fps);\n        if (this.mouseY > camera.scrollEdgeYMax && camera.scrollY < camera.maxScrollY) {\n            this.scrollNowY = scrollSpeed;\n            cursor = 'cur-scroll-bottom';\n        } else if (this.mouseY < camera.scrollEdgeYMin && camera.scrollY > 0) {\n            this.scrollNowY = -scrollSpeed;\n            cursor = 'cur-scroll-top';\n        }\n        if (this.mouseX > camera.scrollEdgeXMax && camera.scrollX < camera.maxScrollX) {\n            this.scrollNowX = scrollSpeed;\n            if (cursor) {\n                cursor += '-right';\n            } else {\n                cursor = 'cur-scroll-right';\n            }\n        } else if (this.mouseX < camera.scrollEdgeXMin && camera.scrollX > 0) {\n            this.scrollNowX = -scrollSpeed;\n            if (cursor) {\n                cursor += '-left';\n            } else {\n                cursor = 'cur-scroll-left';\n            }\n        }\n        if (cursor) {\n            this.borderScrolling = true;\n            this.game.cursorManager.setCursor(cursor);\n        } else if (!this.dragScrolling) {\n            this.game.cursorManager.setCursor('cur-pointer');\n            this.borderScrolling = false;\n        } else {\n            this.borderScrolling = false;\n        }\n    }\n}\n\n",
    "felix.20250107230811.1": "private handleMouseDown(event: MouseEvent): void {\n    this.setCursorPos(event);\n\n    // ignore if not started or in game menu\n    if (!this.game.started || this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n        return;\n    }\n\n    // for both game and map editor.\n    if (event.button === 1) {\n        // middle mouse is drag-scroll.\n        if (!this.dragScrolling) {\n            this.dragScrolling = true;\n            // No cursor when dragging.\n            this.game.cursorManager.setCursor('cur-none');\n        }\n    }\n\n    // Map editor mode\n    if (this.game.editorManager.isMapEditorOpen) {\n        this.handleMapEditorInteraction(event);\n        return; // We return here to avoid the default behavior.\n    }\n\n    if (!this.selecting) {\n        if (event.button === 0) {\n            // Check minimap first\n            if (this.handleMinimapInteraction()) {\n                return;\n            }\n            this.selecting = true;\n            this.selX = this.mouseX;\n            this.selY = this.mouseY;\n            this.gameSelStartX = this.selX + this.game.cameraManager.scrollX;\n            this.gameSelStartY = this.selY + this.game.cameraManager.scrollY;\n            this.game.cursorManager.setCursor('cur-target');\n        }\n        if (event.button === 2) {\n            this.game.gameAction = CONFIG.GAME.ACTIONS.DEFAULT;\n        }\n    }\n\n}\n\n",
    "felix.20250107230817.1": "private handleMouseUp(event: MouseEvent): void {\n    this.setCursorPos(event);\n\n    // ignore if not started or in game menu\n    if (!this.game.started || this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n        return;\n    }\n\n    // for both game and map editor.\n    if (event.button === 1) {\n        this.dragScrolling = false;\n        // now restore cursor.\n        if (this.selecting) {\n            this.game.cursorManager.setCursor('cur-target');\n        } else {\n            this.game.cursorManager.setCursor('cur-pointer');\n        }\n    }\n\n    if (this.game.editorManager.isMapEditorOpen) {\n        // special case for map editor, if needed.\n        return\n    }\n\n    if (event.button === 0) {\n        this.minimapDragging = false; // In case it was dragging the camera on the minimap.\n        this.gameSelEndX = this.mouseX + this.game.cameraManager.scrollX;\n        this.gameSelEndY = this.mouseY + this.game.cameraManager.scrollY;\n        this.selecting = false;\n        this.game.gameAction = CONFIG.GAME.ACTIONS.RELEASESEL;\n        // now restore cursor.\n        if (this.dragScrolling) {\n            this.game.cursorManager.setCursor('cur-none');\n        } else {\n            this.game.cursorManager.setCursor('cur-pointer');\n        }\n    }\n\n}\n\n",
    "felix.20250107230822.1": "private handleMouseWheel(event: WheelEvent): void {\n    if (event.ctrlKey) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n    }\n    // ignore in game menu,  while selecting or if not started\n    if (!this.game.started || this.selecting || this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n        return;\n    }\n    if (event.deltaY < 0) {\n        this.game.cameraManager.zoomIn();\n    } else if (event.deltaY > 0) {\n        this.game.cameraManager.zoomOut();\n    }\n}\n\n",
    "felix.20250107230828.1": "setCursorPos(event?: MouseEvent): void {\n    let x, y;\n    if (event) {\n        x = event.clientX;\n        y = event.clientY;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n    } else {\n        x = this.lastMouseX;\n        y = this.lastMouseY;\n    }\n    this.mouseX = x * (this.game.cameraManager.gameScreenWidth / this.game.canvasBoundingRect.width);\n    this.mouseY = y * (this.game.cameraManager.gameScreenHeight / this.game.canvasBoundingRect.height);\n    // Convert to game coordinates into gameMouseX and gameMouseY.\n    this.gameMouseX = this.mouseX + this.game.cameraManager.scrollX;\n    this.gameMouseY = this.mouseY + this.game.cameraManager.scrollY;\n}\n\n",
    "felix.20250107230906.1": "processInputs(): void {\n    // ignore in game menu\n    if (this.game.optionsMenuManager.isMenuOpen || this.game.helpMenuManager.isHelpMenuOpen) {\n        return;\n    }\n    const fps = this.game.timeManager.fps || 1; // Avoid division by zero.\n\n    // keyboard needs to be scaled for 30fps\n    if (this.keysPressed['ArrowUp'] || this.keysPressed['w']) {\n        this.scrollNowY = -this.keyboardSpeed * (30 / fps);\n        this.keyboardUp = true\n    } else if (this.keyboardUp) {\n        this.keyboardUp = false;\n        this.scrollNowY = 0;\n        this.applyMouseScroll();\n    }\n    if (this.keysPressed['ArrowDown'] || this.keysPressed['s']) {\n        this.scrollNowY = this.keyboardSpeed * (30 / fps);\n        this.keyboardDown = true\n    } else if (this.keyboardDown) {\n        this.keyboardDown = false;\n        this.scrollNowY = 0;\n        this.applyMouseScroll();\n    }\n    if (this.keysPressed['ArrowLeft'] || this.keysPressed['a']) {\n        this.scrollNowX = -this.keyboardSpeed * (30 / fps);\n        this.keyboardLeft = true\n    } else if (this.keyboardLeft) {\n        this.keyboardLeft = false;\n        this.scrollNowX = 0;\n        this.applyMouseScroll();\n    }\n    if (this.keysPressed['ArrowRight'] || this.keysPressed['d']) {\n        this.scrollNowX = this.keyboardSpeed * (30 / fps);\n        this.keyboardRight = true\n    } else if (this.keyboardRight) {\n        this.keyboardRight = false;\n        this.scrollNowX = 0;\n        this.applyMouseScroll();\n    }\n\n    // Scroll if not currently dragging a selection and in the game area.\n    if (!this.selecting && this.mouseInScreen) {\n        this.game.cameraManager.scroll(this.scrollVelocity);\n        if (this.dragScrolling && !this.borderScrolling) {\n            // Reset velocity to 0 after scrolling.\n            this.scrollNowX = 0;\n            this.scrollNowY = 0;\n        }\n    }\n}\n\n",
    "felix.20250107230936.1": "get isSelecting(): boolean {\n    return this.selecting;\n}\n\n",
    "felix.20250201003719.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250201003821.1": "import { TileRenderer, SpriteRenderer, RectangleRenderer, WidgetRenderer, FontRenderer, MinimapRenderer } from \"./renderers\";\nimport { CONFIG } from \"./config\";\nimport { TEntity, TRectangle } from \"./types\";\nimport { CameraManager } from \"./camera-manager\";\n\n",
    "felix.20250201171432.1": "export class RendererManager {\n\n    worldBuffer: WebGLBuffer;\n    private worldData: Float32Array;\n\n    private gl: WebGL2RenderingContext;\n    private tileRenderer: TileRenderer;\n    private widgetRenderer: WidgetRenderer;\n    private spriteRenderer: SpriteRenderer;\n    private rectangleRenderer: RectangleRenderer;\n    private fontRenderer: FontRenderer;\n    private static readonly WORLD_BINDING_POINT = 0;\n    private minimapRenderer: MinimapRenderer;\n    private minimapSize: number = 256; // Size of the minimap texture\n    private terrainVisible: boolean = true; // Draw terrain background titles under units\n\n    @others\n\n}\n\n",
    "felix.20250201171528.1": "constructor(gl: WebGL2RenderingContext, tilesImage: HTMLImageElement, creaturesImage: HTMLImageElement, widgetsImage: HTMLImageElement, fontImage: HTMLImageElement) {\n    this.gl = gl;\n    this.tileRenderer = new TileRenderer(this.gl, tilesImage, CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.MAP.HEIGHT);\n    this.widgetRenderer = new WidgetRenderer(this.gl, widgetsImage, CONFIG.GAME.WIDGETS.MAX);\n    this.spriteRenderer = new SpriteRenderer(this.gl, creaturesImage, CONFIG.GAME.ENTITY.INITIAL_POOL_SIZE);\n    this.rectangleRenderer = new RectangleRenderer(this.gl, CONFIG.GAME.RECTANGLES.MAX);\n    this.fontRenderer = new FontRenderer(this.gl, fontImage, CONFIG.GAME.FONT.MAX);\n    this.minimapRenderer = new MinimapRenderer(this.gl, this.minimapSize);\n    this.worldBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, this.worldBuffer);\n    // Here bind 16 even though we only need 8 bytes, because the minimum size of a UBO is 16 bytes.\n    this.gl.bufferData(this.gl.UNIFORM_BUFFER, 16, this.gl.DYNAMIC_DRAW);\n    this.initUboBindings();\n    this.worldData = new Float32Array(2);\n}\n\n",
    "felix.20250322190011.1": "toggleTerrain(): void {\n    this.terrainVisible = !this.terrainVisible;\n}\n\n",
    "felix.20250205232454.1": "private initUboBindings(): void {\n    // Bind all shaders to the same binding point\n    const programs = [\n        this.tileRenderer.program,\n        this.widgetRenderer.program,\n        this.spriteRenderer.program,\n        this.rectangleRenderer.program\n    ].filter((p): p is WebGLProgram => p != null);\n\n    for (const program of programs) {\n        const blockIndex = this.gl.getUniformBlockIndex(program, 'World');\n        this.gl.uniformBlockBinding(program, blockIndex, RendererManager.WORLD_BINDING_POINT);\n    }\n\n    // Bind the buffer once\n    this.gl.bindBufferBase(\n        this.gl.UNIFORM_BUFFER,\n        RendererManager.WORLD_BINDING_POINT,\n        this.worldBuffer\n    );\n}\n\n",
    "felix.20250201171626.1": "setUboWorldTransforms(gameScreenWidth: number, gameScreenHeight: number): void {\n    // Update the uniform buffer with current world transform values.\n    this.worldData[0] = 2 / gameScreenWidth;\n    this.worldData[1] = 2 / -gameScreenHeight;\n    this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, this.worldBuffer);\n    this.gl.bufferSubData(this.gl.UNIFORM_BUFFER, 0, this.worldData);\n}\n\n",
    "felix.20250201171643.1": "render(\n    visibleTiles: [number, number, number][],\n    entitiesPool: TEntity[],\n    selectionRectangles: TRectangle[],\n    minimapViewRectangles: TRectangle[],\n    visibleWidgets: [number, number, number, number][],\n    text: [number, number, number, number][],\n    camera: CameraManager,\n    interpolation: number,\n    gamemap: number[],\n    minimapNeedsUpdate: boolean\n): void {\n\n    // TODO : Use interpolation for smooth rendering.\n\n    // Clear canvas before rendering.\n    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n    // Update minimap background if needed\n    if (minimapNeedsUpdate) {\n\n        // Set UBO for minimap rendering\n        this.setUboWorldTransforms(this.minimapSize, this.minimapSize);\n\n        this.minimapRenderer.renderMapToTexture(this.tileRenderer, gamemap, this.terrainVisible);\n\n        // Restore UBO for main game rendering\n        this.setUboWorldTransforms(camera.gameScreenWidth, camera.gameScreenHeight);\n    }\n\n    // Render tile layer.\n    if (visibleTiles.length) {\n        // Update tile transform data if needed.\n        this.tileRenderer.updateTransformData(visibleTiles);\n    }\n    this.tileRenderer.render(); // Do render the last frame's tiles if no tiles are visible.\n\n    // Render sprites.\n    this.spriteRenderer.updateTransformData(entitiesPool, camera);\n    this.spriteRenderer.render();\n\n    // Render fog of war, if any.\n    // TODO: Implement Fog of War at some point :)\n\n    // Render selection rectangles, if any.\n    if (selectionRectangles.length) {\n        this.rectangleRenderer.updateTransformData(selectionRectangles);\n        this.rectangleRenderer.render();\n    }\n\n    // Render selection animations, if any.\n    if (visibleWidgets.length) {\n        // Update tile transform data if needed.\n        this.widgetRenderer.updateTransformData(visibleWidgets);\n        this.widgetRenderer.render();\n    }\n\n    if (text.length) {\n        this.fontRenderer.updateTransformData(text);\n        this.fontRenderer.render();\n    }\n\n    // Render minimap in bottom left corner\n    this.minimapRenderer.updateTransformData([], camera);\n    this.minimapRenderer.render();\n\n    // Render current camera view as a rectangle on the minimap\n    if (minimapViewRectangles.length) {\n        this.rectangleRenderer.updateTransformData(minimapViewRectangles);\n        this.rectangleRenderer.render();\n    }\n\n    this.gl.flush();\n}\n\n",
    "felix.20250201171639.1": "dispose(): void {\n    this.tileRenderer.dispose();\n    this.spriteRenderer.dispose();\n    this.rectangleRenderer.dispose();\n    this.widgetRenderer.dispose();\n    this.minimapRenderer.dispose();\n}\n",
    "felix.20250322135329.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250322135517.1": "import { CONFIG } from './config';\nimport { Game } from './game';\n\n",
    "felix.20250322135530.1": "export class AudioManager {\n\n    private game: Game;\n    private soundVolume: number = 1.0;\n    private musicVolume: number = 1.0;\n\n    @others\n\n}\n\n",
    "felix.20250322135640.1": "constructor(game: Game) {\n    this.game = game;\n    // todo\n}\n\n",
    "felix.20250322184509.1": "setMusicVolume(volume: number): void {\n    this.musicVolume = volume;\n    console.log(\"setMusicVolume: \" + this.musicVolume);\n    // this.music.setVolume(volume);\n}\n\n",
    "felix.20250322184330.1": "setSoundVolume(volume: number): void {\n    this.soundVolume = volume;\n    console.log(\"setSoundVolume: \" + this.soundVolume);\n    // this.sound.setVolume(volume);\n}\n\n",
    "felix.20250218223114.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250218224238.1": "import { CONFIG } from '../config';\nimport { Game } from '../game';\n\n",
    "felix.20250218224343.1": "export class MainMenuManager {\n    private startButtonElement: HTMLButtonElement;\n    private game: Game;\n\n    @others\n\n}\n\n",
    "felix.20250218224623.1": "constructor(game: Game) {\n    this.game = game;\n    this.startButtonElement = document.createElement(\"button\");\n}\n\n",
    "felix.20250314205653.1": "mainMenu(): void {\n    // Create the start button\n    this.startButtonElement.textContent = \"Start Game\";\n    this.startButtonElement.classList.add(\"btn-start\");\n    document.body.appendChild(this.startButtonElement);\n}\n\n",
    "felix.20250314213433.1": "getStartButtonElement(): HTMLButtonElement {\n    return this.startButtonElement;\n}\n",
    "felix.20250323204809.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250323204827.1": "import { CONFIG } from '../config';\nimport { Game } from '../game';\n\n",
    "felix.20250323204904.1": "export class HelpMenuManager {\n\n    private game: Game;\n    private helpMenuElement: HTMLDivElement | null = null;\n    public isHelpMenuOpen: boolean = false;\n\n    @others\n}\n",
    "felix.20250323205747.1": "constructor(game: Game) {\n    this.game = game;\n    //\n}\n\n",
    "felix.20250323205910.1": "toggleHelp(): void {\n    if (!this.helpMenuElement) {\n        this.buildHelpMenu();\n    } else {\n        // Toggle visibility\n        if (this.helpMenuElement.style.display === \"none\" || this.helpMenuElement.style.display === \"\") {\n            this.helpMenuElement.style.display = \"block\";\n            this.isHelpMenuOpen = true;\n        } else {\n            this.helpMenuElement.style.display = \"none\";\n            this.isHelpMenuOpen = false;\n        }\n    }\n}\n\n",
    "felix.20250323211614.1": "private buildHelpMenu(): void {\n    // Create the help menu container\n    this.helpMenuElement = document.createElement(\"div\");\n    this.helpMenuElement.style.display = \"block\";\n    this.helpMenuElement.id = \"help-menu\";\n\n    // 'Main help' heading\n    const heading = document.createElement(\"h2\");\n    heading.textContent = \"Game Shortcuts\";\n    this.helpMenuElement.appendChild(heading);\n\n    // Create a table for shortcuts\n    const table = document.createElement(\"table\");\n    table.id = \"shortcuts-table\";\n\n    CONFIG.SHORTCUT_KEYS.forEach((shortcut) => {\n        const row = document.createElement(\"tr\");\n\n        const keyCell = document.createElement(\"td\");\n        keyCell.className = \"shortcut-key\";\n        keyCell.textContent = shortcut.key;\n\n        const actionCell = document.createElement(\"td\");\n        actionCell.className = \"shortcut-action\";\n        actionCell.textContent = shortcut.action;\n\n        row.appendChild(keyCell);\n        row.appendChild(actionCell);\n        table.appendChild(row);\n    });\n\n    this.helpMenuElement.appendChild(table);\n\n    // 'Editor help' heading\n    const editorHeading = document.createElement(\"h2\");\n    editorHeading.textContent = \"Editor Shortcuts\";\n    this.helpMenuElement.appendChild(editorHeading);\n\n    // Create a table for editor shortcuts\n    const editorTable = document.createElement(\"table\");\n    editorTable.id = \"shortcuts-table\";\n    CONFIG.EDITOR_KEYS.forEach((shortcut) => {\n        const row = document.createElement(\"tr\");\n\n        const keyCell = document.createElement(\"td\");\n        keyCell.className = \"shortcut-key\";\n        keyCell.textContent = shortcut.key;\n\n        const actionCell = document.createElement(\"td\");\n        actionCell.className = \"shortcut-action\";\n        actionCell.textContent = shortcut.action;\n\n        row.appendChild(keyCell);\n        row.appendChild(actionCell);\n        editorTable.appendChild(row);\n    });\n\n    this.helpMenuElement.appendChild(editorTable);\n\n    // Append the help menu container to the document body\n    document.body.appendChild(this.helpMenuElement);\n    this.isHelpMenuOpen = true;\n}\n",
    "felix.20250225234241.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250225234241.2": "import { CONFIG } from '../config';\nimport { Game } from '../game';\n\n",
    "felix.20250225234241.3": "export class OptionsMenuManager {\n    isMenuOpen: boolean = false;\n    private oldSettings: any;\n    private gameMenuElement: HTMLDivElement | null = null;\n    private resolutionSelectElement: HTMLSelectElement | null = null;\n    private gameSpeedRange: HTMLInputElement | null = null;\n    private keyboardScrollSpeedRange: HTMLInputElement | null = null;\n    private scrollSpeedRange: HTMLInputElement | null = null;\n    private dragSpeedRange: HTMLInputElement | null = null;\n    private invertDragCheckbox: HTMLInputElement | null = null;\n    private toggleMusicCheckbox: HTMLInputElement | null = null;\n    private musicVolumeRange: HTMLInputElement | null = null;\n    private toggleSoundCheckbox: HTMLInputElement | null = null;\n    private soundVolumeRange: HTMLInputElement | null = null;\n\n    private game: Game;\n\n    @others\n\n}\n\n",
    "felix.20250225234241.4": "constructor(game: Game) {\n    this.game = game;\n}\n\n",
    "felix.20250314210641.1": "toggleMenu(): void {\n    // Create the game menu elements\n    if (!this.gameMenuElement) {\n        this.buildMenu();\n    } else {\n        // Toggle visibility\n        if (this.gameMenuElement.style.display === \"none\" || this.gameMenuElement.style.display === \"\") {\n            this.gameMenuElement.style.display = \"block\";\n            this.isMenuOpen = true;\n        } else {\n            this.gameMenuElement.style.display = \"none\";\n            this.isMenuOpen = false;\n        }\n    }\n    if (this.gameMenuElement) {\n        // Set control values from the game options\n        this.setMenuControlValues();\n        // Preserve those settings in case the user changes them and cancels.\n        this.oldSettings = {\n            resolutionIndex: this.game.resolutionIndex,\n            gameSpeedIndex: this.game.gameSpeedIndex,\n            keyboardSpeedIndex: this.game.keyboardSpeedIndex,\n            scrollSpeedIndex: this.game.scrollSpeedIndex,\n            dragSpeedIndex: this.game.dragSpeedIndex,\n            invertDrag: this.game.invertDrag,\n            musicEnabled: this.game.musicEnabled,\n            musicVolume: this.game.musicVolume,\n            soundEnabled: this.game.soundEnabled,\n            soundVolume: this.game.soundVolume,\n        };\n    }\n}\n\n",
    "felix.20250314210719.1": "cancelMenu(): void {\n    // Close the menu and restore the old settings\n    this.game.setResolution(this.oldSettings.resolutionIndex);\n    this.game.setGameSpeed(this.oldSettings.gameSpeedIndex);\n    this.game.setKeyboardSpeed(this.oldSettings.keyboardSpeedIndex);\n    this.game.setScrollSpeed(this.oldSettings.scrollSpeedIndex);\n    this.game.setDragSpeed(this.oldSettings.dragSpeedIndex);\n    this.game.changeInvertDrag(this.oldSettings.invertDrag);\n    this.game.setMusicEnabled(this.oldSettings.musicEnabled);\n    this.game.setMusicVolume(this.oldSettings.musicVolume);\n    this.game.setSoundEnabled(this.oldSettings.soundEnabled);\n    this.game.setSoundVolume(this.oldSettings.soundVolume);\n    this.toggleMenu();\n}\n\n",
    "felix.20250314210724.1": "setMenuControlValues(): void {\n    if (this.resolutionSelectElement) {\n        this.resolutionSelectElement.selectedIndex = this.game.resolutionIndex;\n    }\n    if (this.gameSpeedRange) {\n        this.gameSpeedRange.value = this.game.gameSpeedIndex.toString();\n    }\n    if (this.keyboardScrollSpeedRange) {\n        this.keyboardScrollSpeedRange.value = this.game.keyboardSpeedIndex.toString();\n    }\n    if (this.scrollSpeedRange) {\n        this.scrollSpeedRange.value = this.game.scrollSpeedIndex.toString();\n    }\n    if (this.dragSpeedRange) {\n        this.dragSpeedRange.value = this.game.dragSpeedIndex.toString();\n    }\n    if (this.invertDragCheckbox) {\n        this.invertDragCheckbox.checked = this.game.invertDrag;\n    }\n    if (this.toggleMusicCheckbox) {\n        this.toggleMusicCheckbox.checked = this.game.musicEnabled;\n    }\n    if (this.musicVolumeRange) {\n        this.musicVolumeRange.value = this.game.musicVolume.toString();\n    }\n    if (this.toggleSoundCheckbox) {\n        this.toggleSoundCheckbox.checked = this.game.soundEnabled;\n    }\n    if (this.soundVolumeRange) {\n        this.soundVolumeRange.value = this.game.soundVolume.toString();\n    }\n}\n\n",
    "felix.20250314210729.1": "getResolutionSelectElement(): HTMLSelectElement | null {\n    return this.resolutionSelectElement;\n}\n\n",
    "felix.20250314210744.1": "buildMenu(): void {\n    this.gameMenuElement = document.createElement(\"div\");\n    this.gameMenuElement.id = \"game-menu\";\n    this.gameMenuElement.style.display = \"block\";\n\n    // 'Option' heading\n    const heading = document.createElement(\"h2\");\n    heading.textContent = \"Options\";\n    this.gameMenuElement.appendChild(heading);\n\n    // Create the dropdown for screen resolution\n    const gameResolution = document.createElement(\"label\");\n    gameResolution.htmlFor = \"resolution-select\";\n    gameResolution.textContent = \"Resolution\";\n    this.gameMenuElement.appendChild(gameResolution);\n    this.resolutionSelectElement = document.createElement(\"select\");\n    this.resolutionSelectElement.id = \"resolution-select\";\n    this.resolutionSelectElement.classList.add(\"resolution-select\");\n\n    // Populate the dropdown with options\n    for (const { label, width, height } of CONFIG.DISPLAY.RESOLUTIONS) {\n        const option = document.createElement(\"option\");\n        option.value = `${width}x${height}`;\n        option.textContent = label;\n        this.resolutionSelectElement.appendChild(option);\n    }\n    this.resolutionSelectElement.selectedIndex = CONFIG.DISPLAY.DEFAULT_RESOLUTION;\n    this.resolutionSelectElement.addEventListener(\"change\", () => {\n        if (this.resolutionSelectElement) {\n            const selectedResolutionIndex = this.resolutionSelectElement.selectedIndex;\n            this.game.setResolution(selectedResolutionIndex);\n        }\n    });\n    this.gameMenuElement.appendChild(this.resolutionSelectElement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create the game speed range input made of two buttons to decrement and increment, \n    const gameSpeedLabel = document.createElement(\"label\");\n    gameSpeedLabel.textContent = \"Game Speed\";\n    gameSpeedLabel.htmlFor = \"game-speed\";\n    this.gameMenuElement.appendChild(gameSpeedLabel);\n\n    const gameSpeedDecrement = document.createElement(\"button\");\n    gameSpeedDecrement.textContent = \"-\";\n    gameSpeedDecrement.addEventListener(\"click\", () => {\n        this.game.decrementGameSpeed();\n        if (this.gameSpeedRange) {\n            this.gameSpeedRange.value = this.game.gameSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(gameSpeedDecrement);\n    this.gameSpeedRange = document.createElement(\"input\");\n    this.gameSpeedRange.id = \"game-speed\";\n    this.gameSpeedRange.type = \"range\";\n    this.gameSpeedRange.min = \"0\";\n    this.gameSpeedRange.max = \"6\";\n    this.gameSpeedRange.step = \"1\";\n    this.gameSpeedRange.value = \"3\";\n    this.gameSpeedRange.addEventListener(\"change\", () => {\n        if (this.gameSpeedRange) {\n            this.game.setGameSpeed(parseInt(this.gameSpeedRange.value, 10));\n        }\n    });\n    this.gameMenuElement.appendChild(this.gameSpeedRange);\n    const gameSpeedIncrement = document.createElement(\"button\");\n    gameSpeedIncrement.classList.add(\"button-increment\");\n    gameSpeedIncrement.textContent = \"+\";\n    gameSpeedIncrement.addEventListener(\"click\", () => {\n        this.game.incrementGameSpeed();\n        if (this.gameSpeedRange) {\n            this.gameSpeedRange.value = this.game.gameSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(gameSpeedIncrement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create mouse scroll speed range input made of two buttons to decrement and increment, \n    const scrollSpeedLabel = document.createElement(\"label\");\n    scrollSpeedLabel.textContent = \"Mouse Scroll Speed\";\n    scrollSpeedLabel.htmlFor = \"scroll-speed\";\n    this.gameMenuElement.appendChild(scrollSpeedLabel);\n\n    const scrollSpeedDecrement = document.createElement(\"button\");\n    scrollSpeedDecrement.textContent = \"-\";\n    scrollSpeedDecrement.addEventListener(\"click\", () => {\n        this.game.decrementScrollSpeed();\n        if (this.scrollSpeedRange) {\n            this.scrollSpeedRange.value = this.game.scrollSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(scrollSpeedDecrement);\n    this.scrollSpeedRange = document.createElement(\"input\");\n    this.scrollSpeedRange.id = \"scroll-speed\";\n    this.scrollSpeedRange.type = \"range\";\n    this.scrollSpeedRange.min = \"0\";\n    this.scrollSpeedRange.max = \"6\";\n    this.scrollSpeedRange.step = \"1\";\n    this.scrollSpeedRange.value = \"3\";\n    this.scrollSpeedRange.addEventListener(\"change\", () => {\n        if (this.scrollSpeedRange) {\n            this.game.setScrollSpeed(parseInt(this.scrollSpeedRange.value, 10));\n        }\n    });\n    this.gameMenuElement.appendChild(this.scrollSpeedRange);\n    const scrollSpeedIncrement = document.createElement(\"button\");\n    scrollSpeedIncrement.classList.add(\"button-increment\");\n    scrollSpeedIncrement.textContent = \"+\";\n    scrollSpeedIncrement.addEventListener(\"click\", () => {\n        this.game.incrementScrollSpeed();\n        if (this.scrollSpeedRange) {\n            this.scrollSpeedRange.value = this.game.scrollSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(scrollSpeedIncrement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create keyboard scroll speed range input made of two buttons to decrement and increment, \n    const keyboardScrollSpeedLabel = document.createElement(\"label\");\n    keyboardScrollSpeedLabel.textContent = \"Keyboard Scroll Speed\";\n    keyboardScrollSpeedLabel.htmlFor = \"keyboard-scroll-speed\";\n    this.gameMenuElement.appendChild(keyboardScrollSpeedLabel);\n\n    const keyboardScrollSpeedDecrement = document.createElement(\"button\");\n    keyboardScrollSpeedDecrement.textContent = \"-\";\n    keyboardScrollSpeedDecrement.addEventListener(\"click\", () => {\n        this.game.decrementKeyboardSpeed();\n        if (this.keyboardScrollSpeedRange) {\n            this.keyboardScrollSpeedRange.value = this.game.keyboardSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(keyboardScrollSpeedDecrement);\n    this.keyboardScrollSpeedRange = document.createElement(\"input\");\n    this.keyboardScrollSpeedRange.id = \"keyboard-scroll-speed\";\n    this.keyboardScrollSpeedRange.type = \"range\";\n    this.keyboardScrollSpeedRange.min = \"0\";\n    this.keyboardScrollSpeedRange.max = \"6\";\n    this.keyboardScrollSpeedRange.step = \"1\";\n    this.keyboardScrollSpeedRange.value = \"3\";\n    this.keyboardScrollSpeedRange.addEventListener(\"change\", () => {\n        if (this.keyboardScrollSpeedRange) {\n            console.log('keyboardScrollSpeedRange changed to:', this.keyboardScrollSpeedRange.value);\n            this.game.setKeyboardSpeed(parseInt(this.keyboardScrollSpeedRange.value, 10));\n        }\n    });\n    this.gameMenuElement.appendChild(this.keyboardScrollSpeedRange);\n    const keyboardScrollSpeedIncrement = document.createElement(\"button\");\n    keyboardScrollSpeedIncrement.classList.add(\"button-increment\");\n    keyboardScrollSpeedIncrement.textContent = \"+\";\n    keyboardScrollSpeedIncrement.addEventListener(\"click\", () => {\n        this.game.incrementKeyboardSpeed();\n        if (this.keyboardScrollSpeedRange) {\n            this.keyboardScrollSpeedRange.value = this.game.keyboardSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(keyboardScrollSpeedIncrement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create drag scroll speed range input made of two buttons to decrement and increment, \n    const dragSpeedLabel = document.createElement(\"label\");\n    dragSpeedLabel.htmlFor = \"drag-speed\";\n    dragSpeedLabel.textContent = \"Drag Scroll Speed\";\n    this.gameMenuElement.appendChild(dragSpeedLabel);\n\n    const dragSpeedDecrement = document.createElement(\"button\");\n    dragSpeedDecrement.textContent = \"-\";\n    dragSpeedDecrement.addEventListener(\"click\", () => {\n        this.game.decrementDragSpeed();\n        if (this.dragSpeedRange) {\n            this.dragSpeedRange.value = this.game.dragSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(dragSpeedDecrement);\n    this.dragSpeedRange = document.createElement(\"input\");\n    this.dragSpeedRange.id = \"drag-speed\";\n    this.dragSpeedRange.type = \"range\";\n    this.dragSpeedRange.min = \"0\";\n    this.dragSpeedRange.max = \"6\";\n    this.dragSpeedRange.step = \"1\";\n    this.dragSpeedRange.value = \"3\";\n    this.dragSpeedRange.addEventListener(\"change\", () => {\n        if (this.dragSpeedRange) {\n            this.game.setDragSpeed(parseInt(this.dragSpeedRange.value, 10));\n        }\n    });\n    this.gameMenuElement.appendChild(this.dragSpeedRange);\n    const dragSpeedIncrement = document.createElement(\"button\");\n    dragSpeedIncrement.classList.add(\"button-increment\");\n    dragSpeedIncrement.textContent = \"+\";\n    dragSpeedIncrement.addEventListener(\"click\", () => {\n        this.game.incrementDragSpeed();\n        if (this.dragSpeedRange) {\n            this.dragSpeedRange.value = this.game.dragSpeedIndex.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(dragSpeedIncrement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create invert-drag checkbox\n    const invertDragLabel = document.createElement(\"label\");\n    invertDragLabel.textContent = \"Invert Drag Scroll\";\n    invertDragLabel.htmlFor = \"invert-drag\";\n    this.gameMenuElement.appendChild(invertDragLabel);\n    this.invertDragCheckbox = document.createElement(\"input\");\n    this.invertDragCheckbox.id = \"invert-drag\";\n    this.invertDragCheckbox.type = \"checkbox\";\n    this.invertDragCheckbox.checked = false;\n    this.invertDragCheckbox.addEventListener(\"change\", () => {\n        this.game.changeInvertDrag(!!this.invertDragCheckbox?.checked);\n        // No need to update the checkbox value as it updates itself.\n    });\n    this.gameMenuElement.appendChild(this.invertDragCheckbox);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n\n    // Create toggle music checkbox\n    const toggleMusicLabel = document.createElement(\"label\");\n    toggleMusicLabel.textContent = \"Toggle Music\";\n    toggleMusicLabel.htmlFor = \"toggle-music\";\n    this.gameMenuElement.appendChild(toggleMusicLabel);\n    this.toggleMusicCheckbox = document.createElement(\"input\");\n    this.toggleMusicCheckbox.id = \"toggle-music\";\n    this.toggleMusicCheckbox.type = \"checkbox\";\n    this.toggleMusicCheckbox.checked = true;\n    this.toggleMusicCheckbox.addEventListener(\"change\", () => {\n        // Toggle music\n        this.game.toggleMusic();\n    });\n    this.gameMenuElement.appendChild(this.toggleMusicCheckbox);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n\n    // Create music volume range input made of two buttons to decrement and increment, \n    const musicVolumeLabel = document.createElement(\"label\");\n    musicVolumeLabel.htmlFor = \"music-volume\";\n    musicVolumeLabel.textContent = \"Music Volume\";\n    this.gameMenuElement.appendChild(musicVolumeLabel);\n\n    const musicVolumeDecrement = document.createElement(\"button\");\n    musicVolumeDecrement.textContent = \"-\";\n    musicVolumeDecrement.addEventListener(\"click\", () => {\n        this.game.decrementMusicVolume();\n        if (this.musicVolumeRange) {\n            this.musicVolumeRange.value = this.game.musicVolume.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(musicVolumeDecrement);\n    this.musicVolumeRange = document.createElement(\"input\");\n    this.musicVolumeRange.id = \"music-volume\";\n    this.musicVolumeRange.type = \"range\";\n    this.musicVolumeRange.min = \"0\";\n    this.musicVolumeRange.max = \"100\";\n    this.musicVolumeRange.step = \"1\";\n    this.musicVolumeRange.value = \"50\";\n    this.musicVolumeRange.addEventListener(\"change\", () => {\n        if (this.musicVolumeRange) {\n            this.game.setMusicVolume(\n                parseInt(this.musicVolumeRange.value, 10)\n            );\n        }\n    });\n    this.gameMenuElement.appendChild(this.musicVolumeRange);\n    const musicVolumeIncrement = document.createElement(\"button\");\n    musicVolumeIncrement.textContent = \"+\";\n    musicVolumeIncrement.classList.add(\"button-increment\");\n    musicVolumeIncrement.addEventListener(\"click\", () => {\n        this.game.incrementMusicVolume();\n        if (this.musicVolumeRange) {\n            this.musicVolumeRange.value = this.game.musicVolume.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(musicVolumeIncrement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create toggle sound checkbox\n    const toggleSoundLabel = document.createElement(\"label\");\n    toggleSoundLabel.textContent = \"Toggle Sound\";\n    toggleSoundLabel.htmlFor = \"toggle-sound\";\n    this.gameMenuElement.appendChild(toggleSoundLabel);\n    this.toggleSoundCheckbox = document.createElement(\"input\");\n    this.toggleSoundCheckbox.id = \"toggle-sound\";\n    this.toggleSoundCheckbox.type = \"checkbox\";\n    this.toggleSoundCheckbox.checked = true;\n    this.toggleSoundCheckbox.addEventListener(\"change\", () => {\n        // Toggle sound\n        this.game.toggleSound();\n    });\n    this.gameMenuElement.appendChild(this.toggleSoundCheckbox);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n    // Create music volume range input made of two buttons to decrement and increment, \n    const soundVolumeLabel = document.createElement(\"label\");\n    soundVolumeLabel.textContent = \"Sound Volume\";\n    soundVolumeLabel.htmlFor = \"sound-volume\";\n    this.gameMenuElement.appendChild(soundVolumeLabel);\n\n    const soundVolumeDecrement = document.createElement(\"button\");\n    soundVolumeDecrement.textContent = \"-\";\n    soundVolumeDecrement.addEventListener(\"click\", () => {\n        this.game.decrementSoundVolume();\n        if (this.soundVolumeRange) {\n            this.soundVolumeRange.value = this.game.soundVolume.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(soundVolumeDecrement);\n    this.soundVolumeRange = document.createElement(\"input\");\n    this.soundVolumeRange.id = \"sound-volume\";\n    this.soundVolumeRange.type = \"range\";\n    this.soundVolumeRange.min = \"0\";\n    this.soundVolumeRange.max = \"100\";\n    this.soundVolumeRange.step = \"1\";\n    this.soundVolumeRange.value = \"50\";\n    this.soundVolumeRange.addEventListener(\"change\", () => {\n        if (this.soundVolumeRange) {\n            this.game.setSoundVolume(parseInt(this.soundVolumeRange.value, 10));\n        }\n    });\n    this.gameMenuElement.appendChild(this.soundVolumeRange);\n    const soundVolumeIncrement = document.createElement(\"button\");\n    soundVolumeIncrement.textContent = \"+\";\n    soundVolumeIncrement.classList.add(\"button-increment\");\n    soundVolumeIncrement.addEventListener(\"click\", () => {\n        this.game.incrementSoundVolume();\n        if (this.soundVolumeRange) {\n            this.soundVolumeRange.value = this.game.soundVolume.toString();\n        }\n    });\n    this.gameMenuElement.appendChild(soundVolumeIncrement);\n    this.gameMenuElement.appendChild(document.createElement(\"br\"));\n\n\n    // Add 'OK' and 'Cancel' buttons\n    const okButton = document.createElement(\"button\");\n    okButton.textContent = \"OK\";\n    okButton.id = \"ok-button\";\n    okButton.addEventListener(\"click\", () => {\n        // Close the menu, no need to apply the settings as they are already applied.\n        // Save those to local storage.\n        this.game.saveSettingsLocalStorage();\n        this.toggleMenu();\n    });\n    this.gameMenuElement.appendChild(okButton);\n\n    const cancelButton = document.createElement(\"button\");\n    cancelButton.textContent = \"Cancel\";\n    cancelButton.id = \"cancel-button\";\n    cancelButton.addEventListener(\"click\", () => {\n        this.cancelMenu();\n    });\n    this.gameMenuElement.appendChild(cancelButton);\n\n    // Append the game menu container to the document body\n    document.body.appendChild(this.gameMenuElement);\n    this.isMenuOpen = true;\n}\n",
    "felix.20250218223128.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250218224239.1": "import { CONFIG } from '../config';\nimport { Game } from '../game';\nimport { FileManager } from './file-manager';\n\n",
    "felix.20250218224355.1": "export class EditorManager {\n    isMapEditorOpen: boolean = false;\n    isAnimationPreviewVisible = false\n    isAnimationPreviewPlaying = false;\n\n    private mapEditorElement: HTMLDivElement | null = null;\n    private tilePreview: HTMLDivElement | null = null;\n    private tileInput: HTMLInputElement | null = null;\n    private currentTileIndex: number = 0; // between 0 and CONFIG.GAME.TILE.DEPTH\n\n    private animInput: HTMLInputElement | null = null;\n    private animLabelInput: HTMLInputElement | null = null;\n    private animListText: HTMLInputElement | null = null;\n    private toggleAnimationVisibleButton: HTMLButtonElement | null = null;\n    private toggleAnimationPlayPauseButton: HTMLButtonElement | null = null;\n\n    currentAnimIndex: number = 0; // Current animation shown in the editor\n    previewAnimationFrame: number = 0; // Current frame of the animation being previewed\n    previewAnimationOrientation: number = 0; // Orientation of the previewed unit. (independant of the animation being previewed)\n\n    private game: Game;\n    private fileManager: FileManager;\n\n    @others\n\n}\n\n",
    "felix.20250218224639.1": "constructor(game: Game, fileManager: FileManager) {\n    this.game = game;\n    this.fileManager = fileManager;\n}\n\n",
    "felix.20250314211048.1": "toggleMapEditor(): void {\n    if (!this.mapEditorElement) {\n        this.buildMapEditor();\n    } else {\n        // Toggle visibility\n        if (this.mapEditorElement.style.display === \"none\" || this.mapEditorElement.style.display === \"\") {\n            this.mapEditorElement.style.display = \"block\";\n            this.isMapEditorOpen = true;\n        } else {\n            this.mapEditorElement.style.display = \"none\";\n            this.isMapEditorOpen = false;\n        }\n    }\n}\n\n",
    "felix.20250314211044.1": "getSelectedTileIndex(): number {\n    return this.currentTileIndex;\n}\n\n",
    "felix.20250314211040.1": "setTileSelectIndex(index: number): void {\n    this.currentTileIndex = index;\n    if (this.tileInput) {\n        this.tileInput.value = index.toString();\n    }\n    this.updateTilePreview();\n}\n\n",
    "felix.20250314211034.1": "incrementMapTile(): void {\n    this.currentTileIndex = (this.currentTileIndex + 1) % CONFIG.GAME.TILE.DEPTH;\n    if (this.tileInput) {\n        this.tileInput.value = this.currentTileIndex.toString();\n    }\n    this.updateTilePreview();\n}\n\n",
    "felix.20250314211031.1": "decrementMapTile(): void {\n    this.currentTileIndex = (this.currentTileIndex - 1 + CONFIG.GAME.TILE.DEPTH) % CONFIG.GAME.TILE.DEPTH;\n    if (this.tileInput) {\n        this.tileInput.value = this.currentTileIndex.toString();\n    }\n    this.updateTilePreview();\n}\n\n",
    "felix.20250314211027.1": "incrementAnimation(): void {\n    this.currentAnimIndex = (this.currentAnimIndex + 1) % this.game.animations.length;\n    if (this.animInput) {\n        this.animInput.value = this.currentAnimIndex.toString();\n    }\n    this.updateAnimationPreview();\n}\n\n",
    "felix.20250314211022.1": "decrementAnimation(): void {\n    this.currentAnimIndex = (this.currentAnimIndex - 1 + this.game.animations.length) % this.game.animations.length;\n    if (this.animInput) {\n        this.animInput.value = this.currentAnimIndex.toString();\n    }\n    this.updateAnimationPreview();\n}\n\n",
    "felix.20250314211017.1": "private updateTilePreview(): void {\n    if (this.tilePreview) {\n        // Calculate background position so that the preview shows only the selected tile.\n        // Assuming vertical stacking: the Y offset is negative (tileIndex * 128)\n        this.tilePreview.style.backgroundPosition = `0px -${this.currentTileIndex * CONFIG.GAME.TILE.SIZE}px`;\n\n        // CONFIG.GAME.TILE.SIZE is 128 and CONFIG.GAME.TILE.DEPTH is 64 so background size is 128 * 64\n        this.tilePreview.style.backgroundSize = `${CONFIG.GAME.TILE.SIZE}px ${CONFIG.GAME.TILE.SIZE * CONFIG.GAME.TILE.DEPTH}px`;\n    }\n}\n\n",
    "felix.20250314211012.1": "updateAnimationPreview(): void {\n    // Put the content of the current animation list into the animListText input.\n    if (this.game.animations[this.currentAnimIndex] == null) {\n        // This specific animation of currentAnimIndex does not exist!\n        this.currentAnimIndex = 0;\n        if (this.game.animations[this.currentAnimIndex] == null) {\n            // Not even the first animation list is initialized!\n            this.game.animations[this.currentAnimIndex] = { label: \"default\" + this.currentAnimIndex.toString(), frames: [] };\n\n        }\n        if (this.animLabelInput) {\n            this.animLabelInput.value = this.game.animations[this.currentAnimIndex].label;\n        }\n        if (this.animInput) {\n            this.animInput.value = this.currentAnimIndex.toString();\n        }\n    }\n\n    if (this.animLabelInput) {\n        this.animLabelInput.value = this.game.animations[this.currentAnimIndex].label;\n    }\n\n    if (this.animListText) {\n        this.animListText.value = JSON.stringify(this.game.animations[this.currentAnimIndex].frames);\n    }\n\n    // restart the preview animation\n    this.previewAnimationFrame = 0;\n}\n\n",
    "felix.20250314211007.1": "private buildMapEditor(): void {\n    // Create the map editor container\n    this.mapEditorElement = document.createElement(\"div\");\n    this.mapEditorElement.style.display = \"block\";\n    this.mapEditorElement.id = \"map-editor\";\n\n    // Create tile preview element using the atlas (using background positioning)\n    this.tilePreview = document.createElement(\"div\");\n    this.tilePreview.id = \"tile-preview\";\n    this.updateTilePreview();\n\n    // Create Up and Down buttons\n    const upTileButton = document.createElement(\"button\");\n    upTileButton.textContent = \"▲\";\n    upTileButton.title = \"Next tile (or press '+' key)\";\n    upTileButton.addEventListener(\"click\", () => {\n        this.incrementMapTile();\n    });\n\n    const downTileButton = document.createElement(\"button\");\n    downTileButton.textContent = \"▼\";\n    downTileButton.title = \"Previous tile (or press '-' key)\";\n    downTileButton.addEventListener(\"click\", () => {\n        this.decrementMapTile();\n    });\n\n    // Create number input to manually select tile index\n    this.tileInput = document.createElement(\"input\");\n    this.tileInput.type = \"number\";\n    this.tileInput.min = \"0\";\n    this.tileInput.max = (CONFIG.GAME.TILE.DEPTH - 1).toString();\n    this.tileInput.value = this.currentTileIndex.toString();\n    this.tileInput.addEventListener(\"change\", () => {\n        if (this.tileInput) {\n            let newValue = parseInt(this.tileInput.value, 10);\n            if (isNaN(newValue)) newValue = 0;\n            const min = 0;\n            const max = CONFIG.GAME.TILE.DEPTH - 1;\n            newValue = Math.max(min, Math.min(newValue, max));\n            this.currentTileIndex = newValue;\n            this.tileInput.value = newValue.toString();\n            this.updateTilePreview();\n        }\n    });\n\n    // Append elements to map editor container\n    this.mapEditorElement.appendChild(this.tilePreview);\n    this.mapEditorElement.appendChild(upTileButton);\n    this.mapEditorElement.appendChild(downTileButton);\n    this.mapEditorElement.appendChild(this.tileInput);\n\n    // Insert newline\n    this.mapEditorElement.appendChild(document.createElement(\"br\"));\n\n    // Create open and Save map buttons\n    const openMapButton = document.createElement(\"button\");\n    openMapButton.textContent = \"Open\";\n    openMapButton.addEventListener(\"click\", () => {\n        this.fileManager.openMapFile();\n    });\n    const saveMapButton = document.createElement(\"button\");\n    saveMapButton.textContent = \"Save\";\n    saveMapButton.addEventListener(\"click\", () => {\n        this.fileManager.saveMapFile();\n    });\n\n    this.mapEditorElement.appendChild(openMapButton);\n    this.mapEditorElement.appendChild(saveMapButton);\n\n    this.mapEditorElement.appendChild(document.createElement(\"br\"));\n    this.mapEditorElement.appendChild(document.createElement(\"br\"));\n    // Create Up and Down buttons\n    const upAnimButton = document.createElement(\"button\");\n    upAnimButton.textContent = \"▲\";\n    upAnimButton.title = \"Next animation\";\n    upAnimButton.addEventListener(\"click\", () => {\n        this.incrementAnimation();\n\n    });\n\n    const downAnimButton = document.createElement(\"button\");\n    downAnimButton.textContent = \"▼\";\n    downAnimButton.title = \"Previous animation\";\n    downAnimButton.addEventListener(\"click\", () => {\n        this.decrementAnimation();\n    });\n\n    // Create Add and Delete buttons\n    const addAnimButton = document.createElement(\"button\");\n    addAnimButton.textContent = \"+\";\n    addAnimButton.title = \"Add new animation\";\n    addAnimButton.addEventListener(\"click\", () => {\n        // Add a new animation with empty frames at the current index\n        this.game.animations.splice(this.currentAnimIndex + 1, 0, { label: \"new\", frames: [1, 2, 3, 4, 5] });\n        this.currentAnimIndex++;\n        if (this.animInput) {\n            this.animInput.value = this.currentAnimIndex.toString();\n        }\n        this.updateAnimationPreview();\n    });\n\n    // Create Delete button\n    const deleteAnimButton = document.createElement(\"button\");\n    deleteAnimButton.textContent = \"-\";\n    deleteAnimButton.title = \"Delete current animation\";\n    deleteAnimButton.addEventListener(\"click\", () => {\n        if (this.game.animations.length > 1) {\n            this.game.animations.splice(this.currentAnimIndex, 1); // This will remove the current animation at the current index\n            this.currentAnimIndex = Math.min(this.currentAnimIndex, this.game.animations.length - 1);\n            if (this.animInput) {\n                this.animInput.value = this.currentAnimIndex.toString();\n            }\n            this.updateAnimationPreview();\n        }\n    });\n\n    // Create number input to manually select anim index\n    this.animInput = document.createElement(\"input\");\n    this.animInput.type = \"number\";\n    this.animInput.min = \"0\";\n    this.animInput.max = (this.game.animations.length - 1).toString();\n    this.animInput.value = this.currentAnimIndex.toString();\n    this.animInput.addEventListener(\"change\", () => {\n        if (this.animInput) {\n            let newValue = parseInt(this.animInput.value, 10);\n            if (isNaN(newValue)) newValue = 0;\n            const min = 0;\n            const max = this.game.animations.length - 1;\n            newValue = Math.max(min, Math.min(newValue, max));\n            this.currentAnimIndex = newValue;\n            this.animInput.value = newValue.toString();\n            console.log('currentAnimIndex', newValue);\n            this.updateAnimationPreview();\n        }\n    });\n\n    // Create text input for animation label\n    this.animLabelInput = document.createElement(\"input\");\n    this.animLabelInput.type = \"text\";\n    // Add 'anim-name' class\n    this.animLabelInput.className = \"anim-name\";\n    this.animLabelInput.value = this.game.animations[this.currentAnimIndex].label;\n    this.animLabelInput.addEventListener(\"change\", () => {\n        if (this.animLabelInput) {\n            console.log(\"animLabelInput changed to:\", this.animLabelInput.value);\n            this.game.animations[this.currentAnimIndex].label = this.animLabelInput.value;\n        }\n    });\n\n    // Create text input for animation lists to be parsed like: \"[0,1,2,22,33,255]\"\n    this.animListText = document.createElement(\"input\");\n    this.animListText.type = \"text\";\n    this.animListText.value = JSON.stringify(this.game.animations[this.currentAnimIndex].frames);\n    this.animListText.addEventListener(\"change\", () => {\n        if (this.animListText) {\n            console.log(\"animListText changed to:\", this.animListText.value);\n            // parse the input value into an array of numbers, checking that it is valid.\n            const previousValue = this.animListText.value;\n            try {\n                const animList = JSON.parse(this.animListText.value);\n                if (Array.isArray(animList) && animList.every((val: any) => {\n                    // Now make sure the array of arrays is valid by limiting the number values to 255\n                    return typeof val === 'number' && val >= 0 && val <= 255;\n                })) {\n                    this.game.animations[this.currentAnimIndex].frames = animList;\n                } else {\n                    throw new Error('Invalid animation list');\n                }\n            } catch (err) {\n                console.error('Error parsing animation list:', err);\n                // Reset to previous valid value\n                this.animListText.value = previousValue;\n            }\n        }\n    });\n\n    // Create open and Save buttons\n    const openAnimationsButton = document.createElement(\"button\");\n    openAnimationsButton.textContent = \"Open\";\n    openAnimationsButton.addEventListener(\"click\", () => {\n        this.fileManager.openAnimationsFile();\n    });\n    const saveAnimationsButton = document.createElement(\"button\");\n    saveAnimationsButton.textContent = \"Save\";\n    saveAnimationsButton.addEventListener(\"click\", () => {\n        this.fileManager.saveAnimationsFile();\n    });\n\n    // Create a 'Hide/Show' button for the main animation preview\n    this.toggleAnimationVisibleButton = document.createElement(\"button\");\n    this.toggleAnimationVisibleButton.textContent = \"Show\";\n    this.toggleAnimationVisibleButton.title = \"Toggle animation visibility\";\n    this.toggleAnimationVisibleButton.addEventListener(\"click\", () => {\n        this.toggleAnimationVisibility();\n    });\n\n    // Create 'Play' and 'Pause' buttons for the main animation preview\n    this.toggleAnimationPlayPauseButton = document.createElement(\"button\");\n    this.toggleAnimationPlayPauseButton.textContent = \"Play\";\n    this.toggleAnimationPlayPauseButton.title = \"Toggle animation play\";\n    this.toggleAnimationPlayPauseButton.addEventListener(\"click\", () => {\n        this.toggleAnimationPlayPause();\n    });\n\n    this.mapEditorElement.appendChild(upAnimButton);\n    this.mapEditorElement.appendChild(downAnimButton);\n\n    this.mapEditorElement.appendChild(addAnimButton);\n    this.mapEditorElement.appendChild(deleteAnimButton);\n\n\n    this.mapEditorElement.appendChild(this.animInput);\n    this.mapEditorElement.appendChild(this.animLabelInput);\n    this.mapEditorElement.appendChild(this.animListText);\n    this.mapEditorElement.appendChild(openAnimationsButton);\n    this.mapEditorElement.appendChild(saveAnimationsButton);\n\n    this.mapEditorElement.appendChild(this.toggleAnimationVisibleButton);\n    this.mapEditorElement.appendChild(this.toggleAnimationPlayPauseButton);\n\n\n    // Append the map editor container to the document body\n    document.body.appendChild(this.mapEditorElement);\n\n    // Make the map editor draggable\n    this.addDragElement(this.mapEditorElement);\n    this.isMapEditorOpen = true;\n}\n\n",
    "felix.20250314210957.1": "private addDragElement(elm: HTMLElement): void {\n    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;\n\n    elm.addEventListener(\"mousedown\", dragMouseDown);\n\n    function dragMouseDown(e: MouseEvent): void {\n        // Only drag if mouse event is directly on the mapEditorElement, not on the buttons or input.\n        if (e.target !== elm) {\n            return;\n        }\n        e.preventDefault();\n        // get the mouse cursor position at startup:\n        pos3 = e.clientX;\n        pos4 = e.clientY;\n        document.addEventListener(\"mouseup\", closeDragElement);\n        document.addEventListener(\"mousemove\", elementDrag);\n    }\n\n    function elementDrag(e: MouseEvent): void {\n        e.preventDefault();\n        // calculate the new cursor position:\n        pos1 = pos3 - e.clientX;\n        pos2 = pos4 - e.clientY;\n        pos3 = e.clientX;\n        pos4 = e.clientY;\n        // set the element's new position:\n        elm.style.top = (elm.offsetTop - pos2) + \"px\";\n        elm.style.left = (elm.offsetLeft - pos1) + \"px\";\n    }\n\n    function closeDragElement(): void {\n        // stop moving when mouse button is released:\n        document.removeEventListener(\"mouseup\", closeDragElement);\n        document.removeEventListener(\"mousemove\", elementDrag);\n    }\n}\n",
    "felix.20250328190413.1": "toggleAnimationPlayPause(): void {\n    if (this.isAnimationPreviewPlaying) {\n        this.isAnimationPreviewPlaying = false;\n    } else {\n        this.isAnimationPreviewPlaying = true;\n    }\n    // change text from 'Play' to 'Pause' and vice versa\n    if (this.toggleAnimationPlayPauseButton) {\n        if (this.isAnimationPreviewPlaying) {\n            this.toggleAnimationPlayPauseButton.textContent = \"Pause\";\n        } else {\n            this.toggleAnimationPlayPauseButton.textContent = \"Play\";\n        }\n    }\n}\n\n",
    "felix.20250328190512.1": "toggleAnimationVisibility(): void {\n    if (this.isAnimationPreviewVisible) {\n        this.isAnimationPreviewVisible = false;\n    } else {\n        this.isAnimationPreviewVisible = true;\n    }\n    // change text from 'Show' to 'Hide' and vice versa\n    if (this.toggleAnimationVisibleButton) {\n        if (this.isAnimationPreviewVisible) {\n            this.toggleAnimationVisibleButton.textContent = \"Hide\";\n        } else {\n            this.toggleAnimationVisibleButton.textContent = \"Show\";\n        }\n    }\n}\n\n",
    "felix.20250329171733.1": "rotatePreview(amount: number): void {\n    // Adjust previewAnimationOrientation by amount\n    // Roll over if exceeding the number of orientations (16, from 0 to 15)\n    // Otherwise, if animating or not visible, ignore.\n    if (this.isAnimationPreviewVisible) {\n        this.previewAnimationOrientation = (this.previewAnimationOrientation + amount + 16) % 16;\n    }\n}\n\n",
    "felix.20250328190757.1": "changeSelectedFrame(amount: number): void {\n    // If paused and not animating, change the current frame shown of the selected animation (previewAnimationFrame). Roll over if exceeding the number of frames\n    // Otherwise, if animating or not visible, ignore.\n    if (!this.isAnimationPreviewPlaying && this.isAnimationPreviewVisible) {\n        const animation = this.game.animations[this.currentAnimIndex];\n        this.previewAnimationFrame = (this.previewAnimationFrame + amount + animation.frames.length) % animation.frames.length;\n    }\n\n}\n\n",
    "felix.20250328190808.1": "changeSpriteNumber(amount: number): void {\n    // If paused and not animating, change the sprite at the current slot of selected animation. \n    // which is the frame at this.game.animations[this.currentAnimIndex].frames[this.previewAnimationFrame]\n    // \n    // Roll over if exceeding the number of sprites\n    // Otherwise, if animating or not visible, ignore.\n    if (!this.isAnimationPreviewPlaying && this.isAnimationPreviewVisible) {\n        const animation = this.game.animations[this.currentAnimIndex];\n        animation.frames[this.previewAnimationFrame] = (animation.frames[this.previewAnimationFrame] + amount + 256) % 256;\n    }\n    // Update the input text box with the new value\n    if (this.animListText) {\n        this.animListText.value = JSON.stringify(this.game.animations[this.currentAnimIndex].frames);\n    }\n\n}\n\n",
    "felix.20250218223131.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250218224241.1": "import { CONFIG } from '../config';\nimport { Game } from '../game';\n\n",
    "felix.20250218224356.1": "export class CursorManager {\n    // Command Acknowledged Widget Animation Properties\n    widgetAnim: number = 0;\n    widgetAnimTotal: number = CONFIG.UI.WIDGET.TOTAL_FRAMES;\n    widgetAnimFrames: readonly number[] = CONFIG.UI.WIDGET.ANIMATION_FRAMES;\n    widgetAnimX: number = 0;\n    widgetAnimY: number = 0;\n\n    private documentElementClassList: DOMTokenList;\n    private currentCursorClass: string = \"\"; // Mouse Cursor: cur-pointer, cur-target...\n\n    private game: Game;\n\n    @others\n\n}\n\n",
    "felix.20250218224627.1": "constructor(game: Game) {\n    this.game = game;\n    this.documentElementClassList = document.documentElement.classList;\n}\n\n",
    "felix.20250314211411.1": "setCursor(newClass: string): void {\n    if (this.currentCursorClass !== newClass) {\n        if (this.currentCursorClass) {\n            this.documentElementClassList.remove(this.currentCursorClass);\n        }\n        this.documentElementClassList.add(newClass);\n        this.currentCursorClass = newClass;\n    }\n}\n\n",
    "felix.20250314211330.1": "animateCursor(): void {\n    if (this.widgetAnim) {\n        this.widgetAnim += 1;\n        if (this.widgetAnim > this.widgetAnimTotal) {\n            this.widgetAnim = 0;\n        }\n    }\n}\n",
    "felix.20250218223137.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250218224243.1": "import { CONFIG } from '../config';\nimport { Game } from '../game';\n\n",
    "felix.20250218224358.1": "export class FileManager {\n    private fileInput: HTMLInputElement | null = null;\n    private fileInputFor: 'map' | 'entity' | 'animation' = 'map';\n\n    private game: Game;\n\n    @others\n\n}\n\n",
    "felix.20250218224631.1": "constructor(game: Game) {\n    this.game = game;\n    this.initFileInput();\n}\n\n",
    "felix.20250314213037.1": "private initFileInput(): void {\n    // Create file input for loading and saving maps\n    this.fileInput = document.createElement('input');\n    this.fileInput.type = 'file';\n    this.fileInput.accept = '.json';\n    this.fileInput.style.display = 'none';  // Hide the input from view\n    this.fileInput.addEventListener('change', (event: Event) => {\n        const target = event.target as HTMLInputElement;\n        const file = target.files?.[0];\n        if (file) {\n            const reader = new FileReader();\n\n            reader.onload = (e) => {\n                try {\n                    const jsonData = JSON.parse(e.target?.result as string);\n\n                    // Check which 'open' button was clicked to determine how to handle the file data.\n                    switch (this.fileInputFor) {\n                        case 'map':\n                            // Check that the map data is valid before opening it.\n                            // it should be an array of numbers totalling the product of the map dimensions.\n                            if (!Array.isArray(jsonData) || jsonData.length !== CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.MAP.HEIGHT) {\n                                throw new Error('Invalid map data');\n                            }\n                            this.game.openMap(jsonData);\n                            break;\n                        case 'entity':\n                            console.log('Opening entity list file:', jsonData);\n                            // todo\n                            break;\n                        case 'animation':\n                            // Animations are an array of EntityAnimation.\n                            if (!Array.isArray(jsonData)) {\n                                throw new Error('Invalid animation data');\n                            }\n                            for (let i = 0; i < jsonData.length; i++) {\n                                // check that each animation has the required properties\n                                const anim = jsonData[i];\n                                // Check if anim.label is a string\n                                if (typeof anim.label !== 'string') {\n                                    throw new Error('Invalid animation data');\n                                }\n                                // Check if anim.frames is an array of numbers\n                                if (!Array.isArray(anim.frames) || !anim.frames.every((frame: any) => typeof frame === 'number')) {\n                                    throw new Error('Invalid animation data');\n                                }\n                            }\n                            this.game.openAnimations(jsonData);\n                            break;\n                        default:\n                            console.log('unknown file input type');\n                            break;\n                    }\n                } catch (err) {\n                    console.error('Error parsing JSON file:', err);\n                }\n            };\n\n            reader.readAsText(file);\n        }\n    });\n\n    document.body.appendChild(this.fileInput);\n}\n\n",
    "felix.20250314213028.1": "openMapFile(): void {\n    // Use a file picker dialog to select a map file.\n    if (this.fileInput) {\n        this.fileInputFor = 'map';\n        this.fileInput.click();  // This opens the file picker dialog\n    }\n}\n\n",
    "felix.20250314213023.1": "saveMapFile(): void {\n    // No need for a file picker dialog, just save the map data to a file.\n    this.game.saveMap(); // No param is default to save the current map.\n}\n\n",
    "felix.20250314213018.1": "openAnimationsFile(): void {\n    // Use a file picker dialog to select an animation file.\n    if (this.fileInput) {\n        this.fileInputFor = 'animation';\n        this.fileInput.click();  // This opens the file picker dialog\n    }\n}\n\n",
    "felix.20250314213014.1": "saveAnimationsFile(): void {\n    // No need for a file picker dialog, just save the animations data to a file.\n    this.game.saveAnimations(); // No param is default to save the current animations.\n}\n\n",
    "felix.20250314213010.1": "openEntityListFile(): void {\n    if (this.fileInput) {\n        this.fileInputFor = 'entity';\n        this.fileInput.click();  // This opens the file picker dialog\n    }\n}\n\n",
    "felix.20250314213006.1": "saveEntityListFile(): void {\n    // No need for a file picker dialog, just save the active entities\n    this.game.saveEntities();\n}\n\n",
    "felix.20250201003723.2": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250201003827.1": "import { CONFIG } from './config';\nimport { Game } from './game';\n\n",
    "felix.20250201233259.1": "export class CameraManager {\n    resolution: {\n        label: string;\n        width: number;\n        height: number;\n    };\n    aspectRatio: number;\n    gameScreenWidth: number;\n    gameScreenHeight: number;\n    scrollEdgeXMax: number;\n    scrollEdgeYMax: number;\n    scrollEdgeXMin: number;\n    scrollEdgeYMin: number;\n    zoom: number;\n    zoomTarget: number; // Used for smooth zooming\n    gameWidthRatio: number;\n    gameHeightRatio: number;\n    initRangeX: number;\n    initRangeY: number;\n    game: Game;\n\n    scrollX = 0;\n    scrollY = 0;\n    maxScrollX: number;\n    maxScrollY: number;\n    zoomFactor = CONFIG.CAMERA.ZOOM.FACTOR;\n    minZoom = CONFIG.CAMERA.ZOOM.MIN;\n    maxZoom = CONFIG.CAMERA.ZOOM.MAX;\n    readonly maxMapX = (CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.TILE.SIZE) - 1;\n    readonly maxMapY = (CONFIG.GAME.MAP.HEIGHT * CONFIG.GAME.TILE.SIZE) - 1;\n\n    @others\n\n}\n",
    "felix.20250201233355.1": "constructor(game: Game) {\n    this.game = game;\n    this.resolution = CONFIG.DISPLAY.RESOLUTIONS[CONFIG.DISPLAY.DEFAULT_RESOLUTION];\n    this.zoom = 1;\n    this.zoomTarget = 1;\n    this.aspectRatio = this.resolution.width / this.resolution.height;\n    this.gameScreenWidth = this.resolution.width / this.zoom;\n    this.gameScreenHeight = this.resolution.height / this.zoom;\n    this.initRangeX = (this.gameScreenWidth / CONFIG.GAME.TILE.SIZE) + 1;\n    this.initRangeY = (this.gameScreenHeight / CONFIG.GAME.TILE.SIZE) + 1;\n    this.scrollEdgeXMax = 0;\n    this.scrollEdgeYMax = 0;\n    this.scrollEdgeXMin = 0;\n    this.scrollEdgeYMin = 0;\n    this.gameWidthRatio = 0;\n    this.gameHeightRatio = 0;\n    this.maxScrollX = 0;\n    this.maxScrollY = 0;\n}\n\n",
    "felix.20250201234908.1": "scroll(scrollVelocity?: { dx: number, dy: number }): boolean {\n    if (scrollVelocity) {\n        this.scrollX += scrollVelocity.dx;\n        this.scrollY += scrollVelocity.dy;\n    }\n    let stop = false;\n    if (this.scrollX < 0) { this.scrollX = 0; stop = true; };\n    if (this.scrollY < 0) { this.scrollY = 0; stop = true; };\n    if (this.scrollX > this.maxScrollX) { this.scrollX = this.maxScrollX; stop = true; };\n    if (this.scrollY > this.maxScrollY) { this.scrollY = this.maxScrollY; stop = true; };\n    return stop;\n}\n\n",
    "felix.20250202002655.1": "setResolution(resolution: {\n    label: string;\n    width: number;\n    height: number;\n}): void {\n    this.resolution = resolution;\n    this.aspectRatio = this.resolution.width / this.resolution.height;\n}\n\n",
    "felix.20250201233351.1": "updateProperties(canvasBoundingRect: DOMRect): void {\n    // Called when the mouse-wheel zoomed in or out, or when the game is started.\n    const scrollZoneThickness = CONFIG.CAMERA.SCROLL.BORDER / this.zoom; // Divide by zoom to keep thickness constant\n    this.gameScreenWidth = this.resolution.width / this.zoom;\n    this.gameScreenHeight = this.resolution.height / this.zoom;\n    this.scrollEdgeXMax = this.gameScreenWidth - scrollZoneThickness;\n    this.scrollEdgeYMax = this.gameScreenHeight - scrollZoneThickness;\n    this.scrollEdgeXMin = scrollZoneThickness;\n    this.scrollEdgeYMin = scrollZoneThickness;\n    this.initRangeX = (this.gameScreenWidth / CONFIG.GAME.TILE.SIZE) + 1;\n    this.initRangeY = (this.gameScreenHeight / CONFIG.GAME.TILE.SIZE) + 1;\n    this.maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;\n    this.maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;\n    this.gameWidthRatio = this.gameScreenWidth / canvasBoundingRect.width;\n    this.gameHeightRatio = this.gameScreenHeight / canvasBoundingRect.height;\n}\n\n",
    "felix.20250212210804.1": "animateZoom(): void {\n    if (this.zoom === this.zoomTarget) {\n        return;\n    }\n\n    const oldZoom = this.zoom;\n    let newZoom = oldZoom;\n\n    if (newZoom < this.zoomTarget) {\n        newZoom = oldZoom * this.zoomFactor; // Zoom in\n    } else if (newZoom > this.zoomTarget) {\n        newZoom = oldZoom / this.zoomFactor; // Zoom out\n    }\n\n    if (newZoom > this.maxZoom || newZoom < this.minZoom) {\n        return;\n    }\n    const mouseX = this.game.inputManager.mouseX;\n    const mouseY = this.game.inputManager.mouseY;\n\n    // Adjust scroll so that the world coordinate under the mouse remains constant.\n    this.scrollX = this.scrollX + (mouseX / oldZoom) - (mouseX / newZoom);\n    this.scrollY = this.scrollY + (mouseY / oldZoom) - (mouseY / newZoom);\n\n    this.zoom = newZoom;\n    this.updateProperties(this.game.canvasBoundingRect); // Updates maxScrollX and maxScrollY\n    this.scroll(); // scroll without parameter just limits to maxScroll.\n    this.game.inputManager.setCursorPos(); // Update mouse and gameMouse coords\n    this.game.rendererManager.setUboWorldTransforms(this.gameScreenWidth, this.gameScreenHeight); // update world coords\n}\n\n",
    "felix.20250201233346.1": "resetZoom(): void {\n    this.zoomTarget = 1;\n}\n\n",
    "felix.20250204221504.1": "zoomIn() {\n    const oldZoom = this.zoom;\n    const newZoom = oldZoom * this.zoomFactor;\n    if (newZoom > this.maxZoom) {\n        return;\n    }\n    this.zoomTarget = newZoom;\n}\n\n",
    "felix.20250204221510.1": "zoomOut() {\n    const oldZoom = this.zoom;\n    const newZoom = oldZoom / this.zoomFactor;\n    if (newZoom < this.minZoom) {\n        return;\n    }\n    this.zoomTarget = newZoom;\n}\n\n",
    "felix.20250201003723.3": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250201003825.1": "import { CONFIG } from './config';\n\n",
    "felix.20250202011725.1": "export class TimeManager {\n\n    // Ticking\n    tickAccumulator = 0; //\n    currentTick = 0;\n    timePerTick: number;\n    timerTriggerAccum: number;\n\n    // Animations\n    animAccumulator = 0;\n    currentAnim = 0;\n    timePerAnim: number;\n\n    // FPS tracking\n    lastTime = 0; // Initialized by the game at the start of a proper game loop.\n    fps = 0;\n    fpsInterval: number;\n    fpsLastTime = 0;\n\n    @others\n\n    getInterpolation(): number {\n        return this.tickAccumulator / this.timePerTick;\n    }\n\n    needCatchUp(timestamp: number): boolean {\n        const deltaTime = timestamp - this.lastTime;\n        if ((this.tickAccumulator + deltaTime) < this.timerTriggerAccum) {\n            return false;\n        }\n        return true;\n    }\n\n}\n\n",
    "felix.20250202135345.1": "constructor() {\n    // tickRate: number, animRate: number, fpsInterval: number\n    this.timePerTick = CONFIG.GAME.TIMING.GAME_SPEEDS[CONFIG.GAME.TIMING.DEFAULT_SPEED].value;\n    this.timePerAnim = CONFIG.GAME.TIMING.CONSTANT_TIME_PER_ANIM;\n    this.fpsInterval = CONFIG.GAME.TIMING.FPS_UPDATE_INTERVAL;\n    this.timerTriggerAccum = this.timePerTick * 3; // 3 ticks behind\n}\n\n",
    "felix.20250215190948.1": "setGameSpeed(speed: number): void {\n    this.timePerTick = speed;\n    this.timerTriggerAccum = this.timePerTick * 3; // 3 ticks behind\n}\n\n",
    "felix.20250202135338.1": "update(timestamp: number) {\n    // Check for the very first frame,\n    const deltaTime = timestamp - this.lastTime;\n    this.lastTime = timestamp;\n    this.tickAccumulator += deltaTime;\n    this.animAccumulator += deltaTime;\n    return deltaTime;\n}\n\n",
    "felix.20250202135334.1": "shouldAnimUpdate() {\n    if (this.animAccumulator >= this.timePerAnim) {\n        this.animAccumulator -= this.timePerAnim;\n        this.currentAnim++;\n        return true;\n    }\n    return false;\n}\n\n",
    "felix.20250202135329.1": "shouldTickUpdate() {\n    if (this.tickAccumulator >= this.timePerTick) {\n        this.tickAccumulator -= this.timePerTick;\n        this.currentTick++;\n        return true;\n    }\n    return false;\n}\n\n",
    "felix.20250202135324.1": "updateFps(timestamp: number, deltaTime: number) {\n    this.fps = Math.round(1000 / deltaTime);\n    if (timestamp - this.fpsLastTime > this.fpsInterval) {\n        this.fpsLastTime = timestamp;\n        // console.log('RAF FPS ', this.fps);\n    }\n}\n",
    "felix.20250131210755.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211133.1": "import { TEntity } from \"./types\";\n\n",
    "felix.20250105212000.1": "/**\n * Singleton Entities Object Pool\n */\nexport class Entities {\n\n    total: number;\n    active: number = 0;\n    pool: Array<TEntity> = [];\n\n    private lastId = 0;\n\n    @others\n\n}\n\n",
    "felix.20250105212000.2": "constructor(initialPoolSize: number) {\n    this.total = initialPoolSize;\n    for (let i = 0; i < initialPoolSize; i++) {\n        this.pool.push({\n            id: 0,\n            type: 0,\n            hitPoints: 0,\n            state: 0,\n            x: 0,\n            y: 0,\n            oldX: 0,\n            oldY: 0,\n            size: 0,\n            orderQty: 0,\n            orderIndex: 0,\n            orderPool: [\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },\n            ],\n            orientation: 0,\n            frameIndex: 0,\n            active: false,\n        });\n    }\n\n}\n\n",
    "felix.20250105212000.3": "spawn(): TEntity {\n    if (this.active === this.total) {\n        throw new Error(\"Pool Full\");\n    }\n    const entity = this.pool.find(e => !e.active);\n    if (entity) {\n        entity.active = true;\n        entity.id = ++this.lastId;\n        this.active++;\n        return entity;\n    } else {\n        throw new Error(\"Pool Full\");\n    }\n}\n\n",
    "felix.20250105212000.4": "remove(entity: TEntity): void {\n    this.active--;\n    entity.active = false;\n}\n\n",
    "felix.20250131210816.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211212.1": "import { EntityType, TEntity } from \"./types\";\nimport { Game } from \"./game\";\n\n",
    "felix.20250105212047.1": "export class Behaviors {\n\n    game: Game;\n\n    @others\n}\n\n",
    "felix.20250105212047.2": "constructor(game: Game) {\n    this.game = game;\n}\n\n",
    "felix.20250105212047.3": "process(entity: TEntity): void {\n    switch (entity.type) {\n        case EntityType.ALIEN:\n            this.alien(entity);\n            break;\n\n        default:\n            break;\n    }\n}\n\n",
    "felix.20250327233801.1": "public preview(entity: TEntity): void {\n    // if size is 256 this is an animation preview so set its frame index accordingly\n\n    if (entity.size > 128) {\n        const animation = this.game.animations[this.game.editorManager.currentAnimIndex];\n        if (this.game.editorManager.isAnimationPreviewPlaying) {\n            this.game.editorManager.previewAnimationFrame = (this.game.editorManager.previewAnimationFrame + 1) % animation.frames.length;\n        }\n        entity.frameIndex = animation.frames[this.game.editorManager.previewAnimationFrame];\n    } else {\n\n        // Regular game mode for this entity\n        this.alien(entity);\n    }\n}\n\n",
    "felix.20250105212047.4": "private alien(entity: TEntity): void {\n\n    // TODO : Add real behaviors \n    // for now, test by just incrementing forward in animations.\n    // (249 is the number of frames in the sprite sheet)\n    entity.frameIndex = (entity.frameIndex + 1) % 249;\n\n}\n",
    "felix.20250131210828.1": "<< imports >>\n@others\n@nowrap\n",
    "felix.20250131211216.1": "import { TEntity, GLResources, ShaderType, TRectangle, TSelectAnim } from \"./types\";\nimport { CONFIG } from './config';\nimport { SHADERS } from './shaders';\nimport { CameraManager } from \"./camera-manager\";\n\n",
    "felix.20250126174340.1": "abstract class BaseRenderer {\n\n    program: WebGLProgram;\n\n    protected gl: WebGL2RenderingContext;\n    protected vao: WebGLVertexArrayObject;\n    protected dirtyTransforms: boolean; // Flag to update bufferData from transformData in the render method.\n    protected resources: GLResources = {\n        buffers: [],\n        textures: [],\n        shaders: []\n    };\n\n    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {\n        this.gl = gl;\n        this.program = this.createProgram(vertexShader, fragmentShader);\n        this.gl.useProgram(this.program);\n        this.vao = this.gl.createVertexArray()!;\n        this.dirtyTransforms = false;\n    }\n\n    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {\n        const program = this.gl.createProgram()!;\n        let errorLog = '';\n\n        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);\n        if (!vertexShader || !fragmentShader) {\n            errorLog += '\\nFailed to create shaders';\n        }\n\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n\n        // Error checking\n        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {\n            errorLog += `\\nProgram linking failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n        this.gl.validateProgram(program);\n        if (!this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)) {\n            errorLog += `\\nProgram validation failed: ${this.gl.getProgramInfoLog(program)}`;\n        }\n        const activeAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);\n        const activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\n        if (activeAttributes === 0 && activeUniforms === 0) {\n            errorLog += '\\nWarning: Program has no active attributes or uniforms';\n        }\n        if (errorLog) {\n            throw new Error(`WebGL Program creation failed: ${errorLog}`);\n        }\n\n        return program;\n    }\n\n    protected createShader(type: ShaderType, source: string): WebGLShader {\n        const shader = this.gl.createShader(type);\n        if (!shader) {\n            throw new Error('Failed to create shader');\n        }\n        this.resources.shaders.push(shader);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error(this.gl.getShaderInfoLog(shader));\n            throw new Error('Shader compilation failed');\n        }\n        return shader;\n    }\n\n    protected setupBufferWithAttributes(\n        buffer: WebGLBuffer,\n        data: BufferSource,\n        usage: number,\n        attributes: Array<[number, number, number, number, number?]>\n    ): void {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, data, usage);\n        attributes.forEach(([location, size, stride, offset, divisor = 0]) => {\n            this.setupAttribute(location, size, stride, offset, divisor);\n        });\n    }\n\n    protected createBuffer(): WebGLBuffer {\n        const buffer = this.gl.createBuffer()!;\n        this.resources.buffers.push(buffer);\n        return buffer;\n    }\n\n    protected createTexture(): WebGLTexture {\n        const texture = this.gl.createTexture()!;\n        this.resources.textures.push(texture);\n        return texture;\n    }\n\n    protected setupAttribute(\n        location: number,\n        size: number,\n        stride: number,\n        offset: number,\n        divisor: number = 0\n    ): void {\n        this.gl.vertexAttribPointer(location, size, this.gl.FLOAT, false, stride, offset);\n        this.gl.enableVertexAttribArray(location);\n        this.gl.vertexAttribDivisor(location, divisor);\n    }\n\n    abstract updateTransformData(data: any[], camera?: CameraManager): void; // This will also set dirtyTransforms to true.\n\n    abstract render(): void; // Before rendering, update bufferData from transformData if dirtyTransforms is true.\n\n    dispose(): void {\n        // Delete all resources in reverse order\n        this.resources.textures.forEach(texture => this.gl.deleteTexture(texture));\n        this.resources.buffers.forEach(buffer => this.gl.deleteBuffer(buffer));\n        this.resources.shaders.forEach(shader => this.gl.deleteShader(shader));\n        this.gl.deleteProgram(this.program);\n        this.gl.deleteVertexArray(this.vao);\n\n        // Clear arrays\n        this.resources.textures = [];\n        this.resources.buffers = [];\n        this.resources.shaders = [];\n    }\n}\n\n",
    "felix.20250126193731.1": "export class TileRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.TILE_VERTEX_SHADER, SHADERS.TILE_FRAGMENT_SHADER);\n\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n        this.transformData = new Float32Array(size * 7); // Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.GAME.TILE.SIZE, CONFIG.GAME.TILE.SIZE, CONFIG.GAME.TILE.DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 28, 0, 1],\n            [3, 1, 28, 8, 1],\n            [4, 3, 28, 12, 1],\n            [5, 1, 28, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: [number, number, number][] = []): void {\n        // data is Array of X, Y and Tile Index triplets\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i][0];\n            this.transformData[offset + 1] = data[i][1];\n            this.transformData[offset + 2] = CONFIG.GAME.TILE.SIZE;\n            this.transformData[offset + 3] = 1;\n            this.transformData[offset + 4] = 1;\n            this.transformData[offset + 5] = 1;\n            this.transformData[offset + 6] = data[i][2];\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    updateTransformDataForMinimap(data: [number, number, number][], tileSize: number): void {\n        // data is Array of X, Y and Tile Index triplets\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i][0];        // x position\n            this.transformData[offset + 1] = data[i][1];    // y position\n            this.transformData[offset + 2] = tileSize;      // Use provided tile size instead of CONFIG.GAME.TILE.SIZE\n            this.transformData[offset + 3] = 1;             // r\n            this.transformData[offset + 4] = 1;             // g\n            this.transformData[offset + 5] = 1;             // b\n            this.transformData[offset + 6] = data[i][2];    // tile index\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 7 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250315211404.1": "export class FontRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.FONT_VERTEX_SHADER, SHADERS.FONT_FRAGMENT_SHADER);\n\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n        this.transformData = new Float32Array(size * 7); // Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        // Change from RGBA to R8 (8-bit grayscale)\n        this.gl.texImage3D(\n            this.gl.TEXTURE_2D_ARRAY,\n            0,\n            this.gl.R8,\n            CONFIG.GAME.FONT.SIZE,\n            CONFIG.GAME.FONT.SIZE,\n            CONFIG.GAME.FONT.DEPTH,\n            0,\n            this.gl.RED,\n            this.gl.UNSIGNED_BYTE,\n            this.image\n        );\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // adds thin line if touches\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // adds thin line if touches\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 28, 0, 1],\n            [3, 1, 28, 8, 1],\n            [4, 3, 28, 12, 1],\n            [5, 1, 28, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: [number, number, number, number][] = []): void {\n        // data is Array of X, Y and Tile Index triplets\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i][0];\n            this.transformData[offset + 1] = data[i][1];\n            this.transformData[offset + 2] = data[i][3]; // Scalable\n            this.transformData[offset + 3] = 0;\n            this.transformData[offset + 4] = 1;\n            this.transformData[offset + 5] = 0;\n            this.transformData[offset + 6] = data[i][2];\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 7 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250207201240.1": "export class WidgetRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.TILE_VERTEX_SHADER, SHADERS.TILE_FRAGMENT_SHADER);\n\n        this.image = image;\n        this.texture = this.createTexture();\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n\n        // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.\n        this.transformData = new Float32Array(size * 7); // Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.GAME.WIDGETS.SIZE, CONFIG.GAME.WIDGETS.SIZE, CONFIG.GAME.WIDGETS.DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 28, 0, 1],\n            [3, 1, 28, 8, 1],\n            [4, 3, 28, 12, 1],\n            [5, 1, 28, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: [number, number, number, number][] = []): void {\n        // data is Array of X, Y and Tile Index triplets\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 7;\n            this.transformData[offset] = data[i][0];\n            this.transformData[offset + 1] = data[i][1];\n            this.transformData[offset + 2] = data[i][3]; // Scalable\n            this.transformData[offset + 3] = 1;\n            this.transformData[offset + 4] = 1;\n            this.transformData[offset + 5] = 1;\n            this.transformData[offset + 6] = data[i][2];\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 7 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250127234240.1": "export class SpriteRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private image: HTMLImageElement\n    private texture: WebGLTexture;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number) {\n        super(gl, SHADERS.SPRITE_VERTEX_SHADER, SHADERS.SPRITE_FRAGMENT_SHADER);\n        this.image = image;\n        this.texture = this.createTexture()!;\n        this.modelBuffer = this.createBuffer()!; // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(size * 8); // 8 floats per sprite, Init with 0s\n        this.setupVAO();\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, CONFIG.GAME.SPRITES.BITMAP_SIZE, CONFIG.GAME.SPRITES.BITMAP_SIZE, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS ?\n        this.gl.generateMipmap(this.gl.TEXTURE_2D);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 32, 0, 1],\n            [3, 1, 32, 8, 1],\n            [4, 3, 32, 12, 1],\n            [5, 2, 32, 24, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    updateTransformData(data: Array<TEntity>, camera: CameraManager): void {\n        const scrollX = camera.scrollX;\n        const scrollY = camera.scrollY;\n        const screenWidth = camera.gameScreenWidth;\n        const screenHeight = camera.gameScreenHeight;\n        let index = 0;\n\n        // Inline u and v functions to avoid repeated function calls\n        for (let i = 0, len = data.length; i < len; i++) {\n            const item = data[i];\n            if (!item.active) {\n                continue;\n            };\n            const x = item.x;\n            const y = item.y;\n\n            // Early exclusion using precomputed camera bounds\n            if ((x + 128) < scrollX || x > (scrollX + screenWidth) ||\n                (y + 128) < scrollY || y > (scrollY + screenHeight)) {\n                continue;\n            }\n\n            const offset = index * 8;\n            // Pre-calculate sprite and orientation values\n            const sprite = item.frameIndex;\n            const orientation = item.orientation;\n            const u = ((sprite % 16) * 0.015625) + ((orientation % 4) * 0.25);\n            const v = (Math.floor(sprite / 16) * 0.015625) + (Math.floor(orientation / 4) * 0.25);\n\n            // Adjust position with camera scroll (addition order adjusted)\n            this.transformData[offset] = x - scrollX;\n            this.transformData[offset + 1] = y - scrollY;\n            this.transformData[offset + 2] = item.size; // Scalable\n            this.transformData[offset + 3] = 1;   // default color\n            this.transformData[offset + 4] = 1;   // default color\n            this.transformData[offset + 5] = 1;   // default color\n            this.transformData[offset + 6] = u;\n            this.transformData[offset + 7] = v;\n            index++;\n        }\n        this.renderMax = index;\n        this.dirtyTransforms = true;\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 8 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);\n    }\n\n}\n\n",
    "felix.20250128200945.1": "export class RectangleRenderer extends BaseRenderer {\n    private transformBuffer: WebGLBuffer;\n    private modelBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private renderMax: number = 0;\n\n    constructor(gl: WebGL2RenderingContext, size: number) {\n        super(gl, SHADERS.RECTANGLE_VERTEX_SHADER, SHADERS.RECTANGLE_FRAGMENT_SHADER);\n        this.modelBuffer = this.createBuffer(); // Create a buffer\n        this.transformBuffer = this.createBuffer()!;\n        this.transformData = new Float32Array(size * 8); // Init with 0s\n        this.setupVAO();\n    }\n\n    updateTransformData(data: TRectangle[]): void {\n        for (let i = 0; i < data.length; i++) {\n            const offset = i * 8;\n            this.transformData[offset] = data[i].x;\n            this.transformData[offset + 1] = data[i].y;\n            this.transformData[offset + 2] = data[i].width;\n            this.transformData[offset + 3] = data[i].height;\n            this.transformData[offset + 4] = data[i].r;\n            this.transformData[offset + 5] = data[i].g;\n            this.transformData[offset + 6] = data[i].b;\n            this.transformData[offset + 7] = data[i].a;\n        }\n        this.renderMax = data.length;\n        this.dirtyTransforms = true;\n    }\n\n    private setupVAO() {\n        this.gl.bindVertexArray(this.vao);\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.RECTANGLE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 8, 0]\n        ]);\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [1, 2, 32, 0, 1],\n            [2, 1, 32, 8, 1],\n            [3, 1, 32, 12, 1],\n            [4, 4, 32, 16, 1]\n        ]);\n        this.gl.bindVertexArray(null); // All done, unbind the VAO\n    }\n\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindVertexArray(this.vao);\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, 8 * this.renderMax);\n            this.dirtyTransforms = false;\n        }\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax); // Draw the model of 6 vertex that form 2 triangles, 3 times\n    }\n\n}\n\n",
    "felix.20250318233413.1": "export class MinimapRenderer extends BaseRenderer {\n    private fbo: WebGLFramebuffer;\n    private minimapTexture: WebGLTexture;\n    private modelBuffer: WebGLBuffer;\n    private transformBuffer: WebGLBuffer;\n    private transformData: Float32Array;\n    private minimapSize: number;\n\n    constructor(gl: WebGL2RenderingContext, size: number) {\n        super(gl, SHADERS.MINIMAP_VERTEX_SHADER, SHADERS.MINIMAP_FRAGMENT_SHADER);\n\n        this.minimapSize = size;\n\n        // Create transform buffer for minimap position\n        this.minimapTexture = this.createTexture();\n        this.modelBuffer = this.createBuffer();\n        this.transformBuffer = this.createBuffer();\n        this.transformData = new Float32Array(7); // position (2), scale (1), color (3), texture index (1)\n\n        // Create FBO for off-screen rendering\n        this.fbo = this.createFBO();\n\n        this.setupVAO();\n    }\n\n    private createFBO(): WebGLFramebuffer {\n        const fbo = this.gl.createFramebuffer();\n        if (!fbo) throw new Error('Failed to create framebuffer');\n\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, fbo);\n\n        // Attach texture\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.minimapTexture);\n        this.gl.texImage2D(\n            this.gl.TEXTURE_2D,\n            0,\n            this.gl.RGBA,\n            this.minimapSize,\n            this.minimapSize,\n            0,\n            this.gl.RGBA,\n            this.gl.UNSIGNED_BYTE,\n            null\n        );\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n\n        // Attach texture to framebuffer\n        this.gl.framebufferTexture2D(\n            this.gl.FRAMEBUFFER,\n            this.gl.COLOR_ATTACHMENT0,\n            this.gl.TEXTURE_2D,\n            this.minimapTexture,\n            0\n        );\n\n        // Check if framebuffer is complete\n        if (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) !== this.gl.FRAMEBUFFER_COMPLETE) {\n            throw new Error('Framebuffer is not complete');\n        }\n\n        // Unbind FBO and texture\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n\n        return fbo;\n    }\n\n    private setupVAO(): void {\n        this.gl.bindVertexArray(this.vao);\n\n        // Setup model buffer (quad vertices)\n        this.setupBufferWithAttributes(this.modelBuffer, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW, [\n            [0, 2, 16, 0],\n            [1, 2, 16, 8]\n        ]);\n\n        // Setup transform buffer\n        this.setupBufferWithAttributes(this.transformBuffer, this.transformData, this.gl.DYNAMIC_DRAW, [\n            [2, 2, 28, 0, 1],\n            [3, 1, 28, 8, 1],\n            [4, 3, 28, 12, 1],\n            [5, 1, 28, 24, 1]\n        ]);\n\n        this.gl.bindVertexArray(null);\n    }\n\n    renderMapToTexture(tileRenderer: TileRenderer, gamemap: number[], terrainVisible: boolean): void {\n        // Save current WebGL state\n        const viewport = this.gl.getParameter(this.gl.VIEWPORT);\n\n        // Bind framebuffer and set viewport to minimap size\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.fbo);\n        this.gl.viewport(0, 0, this.minimapSize, this.minimapSize);\n\n        // Clear the buffer\n        this.gl.clearColor(0, 0, 0, 1);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n\n        // Leave a black buffer if the terrainVisible flag is false\n        if (terrainVisible) {\n            // Prepare tile data for rendering at minimap scale\n            const mapWidth = CONFIG.GAME.MAP.WIDTH;\n            const mapHeight = CONFIG.GAME.MAP.HEIGHT;\n            const minimapTileSize = this.minimapSize / Math.max(mapWidth, mapHeight);\n            const minimapTiles: [number, number, number][] = [];\n\n            for (let y = 0; y < mapHeight; y++) {\n                for (let x = 0; x < mapWidth; x++) {\n                    const tileIndex = gamemap[x + y * mapWidth];\n                    minimapTiles.push([\n                        x * minimapTileSize,\n                        // Fix the upside-down issue by flipping y-coordinates\n                        // (mapHeight - 1 - y) * minimapTileSize, // THis only flips each tile's position, not the whole map\n                        y * minimapTileSize,\n                        tileIndex\n                    ]);\n                }\n            }\n\n            // Render tiles to minimap texture\n            tileRenderer.updateTransformDataForMinimap(minimapTiles, minimapTileSize);\n            tileRenderer.render();\n        }\n\n        // Unbind framebuffer and restore viewport\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n        this.gl.viewport(viewport[0], viewport[1], viewport[2], viewport[3]);\n\n        // Explicitly make sure we're not messing with texture binding state\n        this.gl.bindTexture(this.gl.TEXTURE_2D, null);\n    }\n\n    updateTransformData(p_unused: any[], camera: CameraManager): void {\n        const minimapPadding = 10 / camera.zoom;\n        const minimapDisplaySize = Math.min(camera.gameScreenWidth, camera.gameScreenHeight) / CONFIG.UI.MINIMAP_RATIO;\n        this.transformData[0] = minimapPadding;           // x constant position\n        this.transformData[1] = camera.gameScreenHeight - minimapDisplaySize - minimapPadding;\n        this.transformData[2] = minimapDisplaySize;        // constant scale\n        this.transformData[3] = 1;  // r\n        this.transformData[4] = 1;  // g\n        this.transformData[5] = 1;  // b\n        this.transformData[6] = 0;  // texture index\n\n        this.dirtyTransforms = true;\n    }\n\n    // Render minimap to screen\n    render(): void {\n        this.gl.useProgram(this.program);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.minimapTexture);\n        this.gl.bindVertexArray(this.vao);\n\n        if (this.dirtyTransforms) {\n            this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer);\n            this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData); // This gives WebGL: INVALID_VALUE: bufferSubData: buffer overflow\n            this.dirtyTransforms = false;\n        }\n\n        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, 1);\n    }\n\n    // Add markers for units on minimap (simplified version)\n    renderUnitMarkers(entitiesPool: TEntity[]): void {\n        // Using rectangleRenderer to draw dots\n        // Implementation depends on your specific needs\n    }\n\n    dispose(): void {\n        super.dispose();\n        this.gl.deleteFramebuffer(this.fbo);\n    }\n}\n",
    "felix.20241220002054.1": "@others\n",
    "felix.20241220002054.3": "export type Settings = {\n    resolutionIndex: number;\n    gameSpeedIndex: number;\n    keyboardSpeedIndex: number;\n    scrollSpeedIndex: number;\n    dragSpeedIndex: number;\n    invertDrag: boolean;\n    musicEnabled: boolean;\n    musicVolume: number;\n    soundEnabled: boolean;\n    soundVolume: number;\n}\n\nexport type Vec2 = { x: number, y: number };\n\nexport type TCommand = {\n    order: number;\n    x: number;\n    y: number;\n    entityId: number;\n}\n\nexport type TEntity = {\n    id: number;\n    // states\n    type: number;\n    hitPoints: number;\n    state: number;\n    x: number;\n    y: number;\n    oldX: number; // For interpolation. Meaning that the entity is moving from oldX, oldY to x, y\n    oldY: number;\n    size: number;\n    orientation: number;\n    frameIndex: number;\n    // Ten queuable commands\n    orderQty: number;\n    orderIndex: number;\n    orderPool: [\n        TCommand, TCommand, TCommand, TCommand, TCommand,\n        TCommand, TCommand, TCommand, TCommand, TCommand\n    ];\n    active: boolean;\n}\n\nexport type TSelectAnim = {\n    x: number;\n    y: number;\n    orientation: number;\n    frameIndex: number;\n    active: boolean;\n}\n\nexport type TRectangle = {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n}\n\nexport type TParameters =\n    | {\n        uniform: true;\n        location: WebGLUniformLocation;\n        type: number;\n    }\n    | {\n        uniform: false;\n        location: number;\n        type: number;\n    };\n\n\nexport interface GLResources {\n    buffers: WebGLBuffer[];\n    textures: WebGLTexture[];\n    shaders: WebGLShader[];\n}\n\nexport enum ShaderType {\n    VERTEX = WebGL2RenderingContext.VERTEX_SHADER,\n    FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER\n}\n\nexport type WebGLError = {\n    type: 'shader' | 'program' | 'buffer' | 'texture';\n    message: string;\n    details?: string;\n}\n\nexport enum EntityType {\n    ALIEN = 1,\n    // ...\n}\n\nexport type EntityAnimation = {\n    label: string;\n    frames: number[];\n}\n",
    "felix.20241224183015.1": "<< imports >>\n@others\n",
    "felix.20250122233854.1": "import { Vec2 } from \"./types\";\n\n",
    "felix.20241224183525.1": "/**\n * Tries to put browser into fullscreen mode.\n * @param element The element to put into fullscreen mode.\n * @returns A promise that resolves when the browser is in fullscreen mode.\n */\nexport function fullScreen(element: Element): Promise<void> {\n    if (document.fullscreenElement !== null) {\n        return Promise.resolve();  // already fullscreen\n    }\n    if (element.requestFullscreen) {\n        const requestFullscreen = element.requestFullscreen || (element as any).webkitRequestFullscreen || (element as any).mozRequestFullScreen || (element as any).msRequestFullscreen;\n        if (requestFullscreen) {\n            return requestFullscreen.call(element).catch((err) => {\n                console.error(\n                    `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`,\n                );\n            });\n        } else {\n            return Promise.resolve();\n        }\n    } else {\n        return Promise.resolve();\n    }\n}\n\n",
    "felix.20250120234029.1": "export function interpolate(min: Vec2, max: Vec2, fract: number): Vec2 {\n    return { x: max.x + (min.x - max.x) * fract, y: max.y + (min.y - max.y) * fract };\n}\n\n",
    "felix.20241228192145.1": "export function loadImage(src: string): Promise<HTMLImageElement> {\n    return new Promise((resolve, reject) => {\n        const image = new Image();\n        image.onload = () => resolve(image);\n        image.src = src;\n    });\n}\n\n",
    "felix.20250202200500.1": "export function getDisplaySize(entry: ResizeObserverEntry): { width: number, height: number } {\n    let width: number, height: number;\n    let dpr = window.devicePixelRatio;\n    if (entry.devicePixelContentBoxSize) {\n        // NOTE: Only this path gives the correct answer\n        // The other 2 paths are an imperfect fallback\n        // for browsers that don't provide anyway to do this\n        [width, height] = [entry.devicePixelContentBoxSize[0].inlineSize, entry.devicePixelContentBoxSize[0].blockSize];\n        dpr = 1; // Already in device pixels\n    } else if (entry.contentBoxSize) {\n        if (entry.contentBoxSize[0]) {\n            [width, height] = [entry.contentBoxSize[0].inlineSize, entry.contentBoxSize[0].blockSize];\n        } else {\n            // @ts-expect-error legacy API\n            [width, height] = [entry.contentBoxSize.inlineSize, entry.contentBoxSize.blockSize];\n        }\n    } else {\n        // Legacy API\n        [width, height] = [entry.contentRect.width, entry.contentRect.height];\n    }\n    return { width: Math.round(width * dpr), height: Math.round(height * dpr) };\n}\n\n",
    "felix.20250202202711.1": "export function debounce<T extends (...args: any[]) => void>(func: T, delay: number): T {\n    let timer: number;\n    return ((...args: any[]) => {\n        if (timer) clearTimeout(timer);\n        timer = window.setTimeout(() => func(...args), delay);\n    }) as T;\n}\n",
    "felix.20250107011547.1": "const DISPLAY = {\n    DEFAULT_RESOLUTION: 0, // index for RESOLUTIONS\n    RESOLUTIONS: [\n        {\n            label: \"16:9\",\n            width: 1920,\n            height: 1080\n        },\n        {\n            label: \"16:10\",\n            width: 1920,\n            height: 1200\n        },\n        {\n            label: \"4:3\",\n            width: 1440,\n            height: 1080\n        },\n    ]\n} as const;\n\nconst GAME = {\n    ACTIONS: {\n        DEFAULT: 1,\n        RELEASESEL: 2\n    },\n    TILE: {\n        SIZE: 128, // size of an individual square TILE \n        DEPTH: 64, // Total number of tiles in the bitmap\n    },\n    FONT: {\n        SIZE: 32, // size of an individual square TILE \n        DEPTH: 95, // Total number of tiles in the bitmap\n        MAX: 256 // Maximum number of characters\n    },\n    WIDGETS: {\n        SIZE: 128, // size of an individual square TILE \n        DEPTH: 5, // Total number of tiles in the bitmap\n        MAX: 100 // Maximum number of widgets\n    },\n    RECTANGLES: {\n        MAX: 256 // Maximum number of rectangles\n    },\n    SPRITES: {\n        BITMAP_SIZE: 4096, // size of the square bitmap of alien sprites\n        SIZE: 64, // size of an individual square alien sprite \n    },\n    MAP: {\n        WIDTH: 64, // game map width in TILES \n        HEIGHT: 64 // game map height in TILES \n    },\n    TIMING: {\n        FPS_UPDATE_INTERVAL: 1000, // Update FPS display every second\n        CHECK_UPDATE_INTERVAL: 250, // For needed ticks to be computed if game is minimized\n        // Cursor, Hud, and other animations\n        CONSTANT_TIME_PER_ANIM: 67, // 1000ms/s ÷ 67ms/frame = 14.93 FPS\n        DEFAULT_SPEED: 3, // index for GAME_SPEEDS\n        GAME_SPEEDS: [\n            // Game logic timing (Variable in single player, fixed in multiplayer)\n            { label: \"Slowest\", value: 167 }, // 0 \n            { label: \"Slower\", value: 111 }, // 1\n            { label: \"Slow\", value: 83 }, // 2\n            { label: \"Normal\", value: 67 }, // 3\n            { label: \"Fast\", value: 56 }, // 4\n            { label: \"Faster\", value: 48 }, // 5\n            { label: \"Fastest\", value: 42 }, // 6\n        ],\n    },\n    ENTITY: {\n        INITIAL_POOL_SIZE: 100\n    }\n} as const;\n\nconst CAMERA = {\n    ZOOM: {\n        MIN: 0.5,\n        MAX: 2.0,\n        STEPS: 4, // Steps to double zoom\n        FACTOR: Math.pow(2, 1 / 4)\n    },\n    SCROLL: {\n        BORDER: 12, // pixels from screen to trigger scrolling\n        DEFAULT_KEYBOARD_SPEED: 3, // speed index for KEYBOARD_SPEEDS\n        KEYBOARD_SPEEDS: [\n            // Keyboard scroll speed in game-pixels for moving the map with arrow keys\n            { label: \"Slowest\", value: 25 }, // 0 \n            { label: \"Slower\", value: 45 }, // 1\n            { label: \"Slow\", value: 65 }, // 2\n            { label: \"Normal\", value: 85 }, // 3\n            { label: \"Fast\", value: 115 }, // 4\n            { label: \"Faster\", value: 145 }, // 5\n            { label: \"Fastest\", value: 175 }, // 6  \n        ],\n        DEFAULT_SCROLL_SPEED: 3, // speed index for SCROLL_SPEEDS\n        SCROLL_SPEEDS: [\n            // Mouse scroll speed in game-pixels for being near the edge of the screen\n            { label: \"Slowest\", value: 25 }, // 0 \n            { label: \"Slower\", value: 45 }, // 1\n            { label: \"Slow\", value: 65 }, // 2\n            { label: \"Normal\", value: 85 }, // 3\n            { label: \"Fast\", value: 115 }, // 4\n            { label: \"Faster\", value: 145 }, // 5\n            { label: \"Fastest\", value: 175 }, // 6   \n        ],\n        DEFAULT_DRAG_INVERT: false,\n        DEFAULT_DRAG_SPEED: 3, // speed index for DRAG_SPEEDS\n        DRAG_SPEEDS: [\n            // Mouse drag speed multipliers for moving the map with middle mouse button\n            { label: \"Slowest\", value: 1 }, // 0 \n            { label: \"Slower\", value: 2 }, // 1\n            { label: \"Slow\", value: 4 }, // 2\n            { label: \"Normal\", value: 8 }, // 3\n            { label: \"Fast\", value: 16 }, // 4\n            { label: \"Faster\", value: 32 }, // 5\n            { label: \"Fastest\", value: 64 }, // 6  \n        ]\n    }\n} as const;\n\nconst AUDIO = {\n    DEFAULT_MUSIC_ENABLED: true,\n    DEFAULT_SOUND_ENABLED: true,\n    DEFAULT_MUSIC_VOLUME: 50,\n    DEFAULT_SOUND_VOLUME: 50,\n}\n\nconst UI = {\n    MINIMAP_RATIO: 3.75,\n    WIDGET: {\n        TOTAL_FRAMES: 6,\n        ANIMATION_FRAMES: [0, 2, 4, 3, 2, 1] // Widget animation has 6 frames\n    }\n} as const;\n\nconst TEXTURE_MODEL_DATA = new Float32Array([\n    // XY Coords, UV Offset \n    1, 0, 1, 0,\n    0, 1, 0, 1,\n    1, 1, 1, 1,\n    1, 0, 1, 0,\n    0, 0, 0, 0,\n    0, 1, 0, 1,\n]);\n\nconst RECTANGLE_MODEL_DATA = new Float32Array([\n    // XY Coords\n    1, 0,\n    0, 1,\n    1, 1,\n    1, 0,\n    0, 0,\n    0, 1,\n]);\n\nconst SHORTCUT_KEYS = [\n    {\n        key: \"F1\",\n        action: \"Help menu\"\n    },\n    {\n        key: \"F6\",\n        action: \"Reset zoom\"\n    },\n    {\n        key: \"F10\",\n        action: \"Options menu\"\n    },\n    {\n        key: \"Ctrl+Alt+F\",\n        action: \"Toggle FPS display\"\n    },\n    {\n        key: \"Ctrl+M\",\n        action: \"Toggle music\"\n    },\n    {\n        key: \"Ctrl+S\",\n        action: \"Toggle sound\"\n    },\n    {\n        key: \"Tab\",\n        action: \"Toggle minimap terrain\"\n    },\n    {\n        key: \"+ or -\",\n        action: \"Change game speed\"\n    }\n] as const;\n\nconst EDITOR_KEYS = [\n    {\n        key: \"F9\",\n        action: \"Toggle editor-mode\"\n    },\n    {\n        key: \"+ or -\",\n        action: \"Change map tile\"\n    },\n    {\n        key: \"Spacebar\",\n        action: \"Play / Pause animation\"\n    },\n    {\n        key: \"A or D\",\n        action: \"Change orientation\"\n    },\n    {\n        key: \"← or →\",\n        action: \"Change selected frame\"\n    },\n    {\n        key: \"↑ or ↓\",\n        action: \"Change current sprite\"\n    }\n] as const;\n\nconst FONT_SIZES = [\n    10,\n    10.625,\n    12.84375,\n    23.28125,\n    17.46875,\n    31.25,\n    21.5625,\n    6.75,\n    12.25,\n    12.25,\n    17.46875,\n    23.28125,\n    9.6875,\n    11.625,\n    9.6875,\n    12.234375,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    17.46875,\n    11.3125,\n    11.3125,\n    23.28125,\n    23.28125,\n    23.28125,\n    15.15625,\n    29.09375,\n    19.1875,\n    18.859375,\n    19.21875,\n    21.703125,\n    17.953125,\n    16.6875,\n    21.359375,\n    21.609375,\n    11.9375,\n    13.328125,\n    18.8125,\n    15.921875,\n    24.65625,\n    21.359375,\n    22.640625,\n    17.640625,\n    22.640625,\n    19.859375,\n    17.828125,\n    18.6875,\n    20.984375,\n    19.09375,\n    28.859375,\n    18.578125,\n    18.4375,\n    17.890625,\n    12.25,\n    12.234375,\n    12.25,\n    23.28125,\n    17.46875,\n    17.46875,\n    16.796875,\n    17.6875,\n    14.765625,\n    17.6875,\n    16.84375,\n    10.1875,\n    17.6875,\n    17.84375,\n    7.3125,\n    9.015625,\n    15.9375,\n    7.3125,\n    26.875,\n    17.84375,\n    17.375,\n    17.6875,\n    17.6875,\n    11.53125,\n    14.28125,\n    10.703125,\n    17.84375,\n    15.9375,\n    23.75,\n    15.84375,\n    15.9375,\n    14.21875,\n    15.375,\n    12.234375,\n    15.375,\n    23.28125\n] as const;\n\n// Export all configs from a single point\nexport const CONFIG = {\n    AUDIO,\n    SHORTCUT_KEYS,\n    EDITOR_KEYS,\n    TEXTURE_MODEL_DATA,\n    RECTANGLE_MODEL_DATA,\n    DISPLAY,\n    GAME,\n    CAMERA,\n    UI,\n    FONT_SIZES\n} as const;\n\n",
    "felix.20250125002553.1": "// TEXT VERTEX SHADER\nconst FONT_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    \n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// TEXT  FRAGMENT SHADER\nconst FONT_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    // Sample the texture to get the red channel (grayscale value)\n    float alpha = texture(uSampler, vec3(vTexCoord, vDepth)).r;\n    \n    // Use vColor for the RGB and the texture's red channel as alpha\n    fragColor = vec4(vColor.rgb, alpha);\n}`;\n\n\n// BACKGROUND MAP VERTEX SHADER\nconst TILE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\nout float vDepth;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = aTexCoord;\n    vDepth = aDepth;\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n    \n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// BACKGROUND MAP FRAGMENT SHADER\nconst TILE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2DArray uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nin float vDepth;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vec3(vTexCoord, vDepth));\n}`;\n\n// ALIEN CREATURE SPRITE VERTEX SHADER\nconst SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in vec2 aUV;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;\n\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// ALIEN CREATURE SPRITE FRAGMENT SHADER\nconst SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nuniform mediump sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\n// SELECTION LINE VERTEX SHADER\nconst RECTANGLE_VERTEX_SHADER = /*glsl*/ `#version 300 es\n\n// The next two are the repeated geometry and UV for each instance of the model\nlayout(location=0) in vec4 aPosition;\n\n// Those next four use vertexAttribDivisor and are updated every instance\nlayout(location=1) in vec3 aOffset;\nlayout(location=2) in float aScaleX;\nlayout(location=3) in float aScaleY;\nlayout(location=4) in vec4 aColor;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\n\nvoid main()\n{\n    vColor = aColor;\n    vec3 pos = aPosition.xyz * vec3(aScaleX, aScaleY, 1.0) + aOffset;\n    \n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n\n}`;\n\n// SELECTION LINE SPRITE FRAGMENT SHADER\nconst RECTANGLE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\n\nprecision mediump float;\n\nin vec4 vColor;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor;\n}`;\n\n// MINIMAP VERTEX SHADER\nconst MINIMAP_VERTEX_SHADER = /*glsl*/ `#version 300 es\nlayout(location=0) in vec4 aPosition;\nlayout(location=1) in vec2 aTexCoord;\nlayout(location=2) in vec3 aOffset;\nlayout(location=3) in float aScale;\nlayout(location=4) in vec4 aColor;\nlayout(location=5) in float aDepth;\n\nlayout(std140) uniform World {\n    float uWorldX;\n    float uWorldY;\n};\n\nout vec4 vColor;\nout vec2 vTexCoord;\n\nvoid main()\n{\n    vColor = aColor;\n    vTexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y); // Flip Y coordinate\n    vec3 pos = aPosition.xyz * aScale + aOffset;\n\n    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.\n    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);\n}`;\n\n// MINIMAP FRAGMENT SHADER\nconst MINIMAP_FRAGMENT_SHADER = /*glsl*/ `#version 300 es\nprecision mediump float;\n\nuniform sampler2D uSampler;\n\nin vec4 vColor;\nin vec2 vTexCoord;\nout vec4 fragColor;\n\nvoid main()\n{\n    fragColor = vColor * texture(uSampler, vTexCoord);\n}`;\n\n// Export all configs from a single point\nexport const SHADERS = {\n    FONT_VERTEX_SHADER,\n    FONT_FRAGMENT_SHADER,\n    TILE_VERTEX_SHADER,\n    TILE_FRAGMENT_SHADER,\n    SPRITE_VERTEX_SHADER,\n    SPRITE_FRAGMENT_SHADER,\n    RECTANGLE_VERTEX_SHADER,\n    RECTANGLE_FRAGMENT_SHADER,\n    MINIMAP_VERTEX_SHADER,\n    MINIMAP_FRAGMENT_SHADER\n} as const;\n"
  }
}