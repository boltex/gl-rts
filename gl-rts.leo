<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="felix.20241217200720.1"><vh>introduction</vh></v>
<v t="felix.20250125002444.1"><vh>deprecated</vh>
<v t="felix.20241217201352.1"><vh>@@clean src/main.ts</vh>
<v t="felix.20241220001536.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241217225754.1"><vh>shaders</vh></v>
<v t="felix.20241217225604.1"><vh>loadImage</vh></v>
<v t="felix.20241217225540.1"><vh>Asynchronous IIFE</vh>
<v t="felix.20241217230346.1"><vh>Startup</vh></v>
</v>
<v t="felix.20241217230454.1"><vh>class Game</vh>
<v t="felix.20241220000920.1"><vh>constructor</vh></v>
<v t="felix.20241217230518.1"><vh>resize</vh></v>
<v t="felix.20241220001712.1"><vh>toggleGameMenu</vh></v>
<v t="felix.20241220001715.1"><vh>setCursor</vh></v>
<v t="felix.20241224223317.1"><vh>checkKeys</vh></v>
<v t="felix.20241220001738.1"><vh>mouseDown</vh></v>
<v t="felix.20241220001741.1"><vh>mouseUp</vh></v>
<v t="felix.20241220001745.1"><vh>mouseMove</vh></v>
<v t="felix.20241220001755.1"><vh>setCursorPos</vh></v>
<v t="felix.20241224222932.1"><vh>procGame</vh></v>
<v t="felix.20241217230522.1"><vh>update</vh></v>
<v t="felix.20241220001814.1"><vh>checkUpdate</vh></v>
<v t="felix.20241224222952.1"><vh>tick</vh></v>
<v t="felix.20241224223038.1"><vh>animateCursor</vh></v>
<v t="felix.20241224223235.1"><vh>trydefault</vh></v>
<v t="felix.20241224223239.1"><vh>tryselect</vh></v>
</v>
<v t="felix.20241220001453.1"><vh>class Entities</vh>
<v t="felix.20241220001453.2"><vh>constructor</vh></v>
<v t="felix.20241220001453.3"><vh>spawn</vh></v>
<v t="felix.20241220001453.4"><vh>remove</vh></v>
</v>
</v>
<v t="felix.20250106224739.1"><vh>MAYBE class ShaderProgram</vh>
<v t="felix.20250106224739.2"><vh>constructor</vh></v>
<v t="felix.20250106224739.3"><vh>getShader</vh></v>
<v t="felix.20250106224739.4"><vh>gatherParameters</vh></v>
<v t="felix.20250106224739.5"><vh>setParam &amp; helpers</vh>
<v t="felix.20250106224739.6"><vh>setUniform</vh></v>
<v t="felix.20250106224739.7"><vh>setAttribute</vh></v>
</v>
</v>
<v t="felix.20250108220449.1"><vh>MAYBE class GLContext</vh>
<v t="felix.20250108220555.1"><vh>constructor</vh></v>
<v t="felix.20250108220630.1"><vh>setupGL</vh></v>
<v t="felix.20250108220609.1"><vh>createBuffer</vh></v>
<v t="felix.20250108220643.1"><vh>createTexture</vh></v>
<v t="felix.20250108220648.1"><vh>useProgram</vh></v>
<v t="felix.20250108220655.1"><vh>clear</vh></v>
<v t="felix.20250108220715.1"><vh>setViewport</vh></v>
<v t="felix.20250108220720.1"><vh>bindVAO</vh></v>
<v t="felix.20250108221254.1"><vh>setAttribute</vh></v>
<v t="felix.20250108221302.1"><vh>draw</vh></v>
<v t="felix.20250108221307.1"><vh>drawElements</vh></v>
<v t="felix.20250108221318.1"><vh>checkError</vh></v>
</v>
</v>
<v t="felix.20241227202430.1"><vh>@clean src/main.ts</vh>
<v t="felix.20241227202519.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241227213048.1"><vh>Create Game</vh></v>
<v t="felix.20241227213056.1"><vh>class Game</vh>
<v t="felix.20241227213841.1"><vh>constructor</vh></v>
<v t="felix.20241227213217.1"><vh>handleCanvasResize</vh></v>
<v t="felix.20250101222813.1"><vh>setDimensionsVars</vh></v>
<v t="felix.20241228191055.1"><vh>resizeCanvasToDisplaySize</vh></v>
<v t="felix.20241227213236.1"><vh>update</vh></v>
<v t="felix.20250101211507.1"><vh>setCursor</vh></v>
<v t="felix.20241231225835.1"><vh>animateCursor</vh></v>
<v t="felix.20241231221007.1"><vh>render</vh></v>
<v t="felix.20241228193009.1"><vh>mainMenu</vh></v>
<v t="felix.20241229230016.1"><vh>startGame</vh></v>
<v t="felix.20250105213621.1"><vh>initGameStates</vh></v>
<v t="felix.20241229162002.1"><vh>toggleGameMenu</vh></v>
<v t="felix.20241230215224.1"><vh>procGame</vh></v>
<v t="felix.20241229162229.1"><vh>checkUpdate</vh></v>
<v t="felix.20241230215229.1"><vh>tick</vh></v>
<v t="felix.20241229214656.1"><vh>loop</vh></v>
<v t="felix.20241230215401.1"><vh>trydefault</vh></v>
<v t="felix.20241230215406.1"><vh>tryselect</vh></v>
</v>
<v t="felix.20250107221804.1"><vh>class InputManager</vh>
<v t="felix.20250107221855.1"><vh>constructor</vh></v>
<v t="felix.20250107232140.1"><vh>getters</vh></v>
<v t="felix.20250107230733.1"><vh>init</vh></v>
<v t="felix.20250107230755.1"><vh>handleKeyDown</vh></v>
<v t="felix.20250107230802.1"><vh>handleKeyUp</vh></v>
<v t="felix.20250107230806.1"><vh>handleMouseMove</vh></v>
<v t="felix.20250107230811.1"><vh>handleMouseDown</vh></v>
<v t="felix.20250107230817.1"><vh>handleMouseUp</vh></v>
<v t="felix.20250107230822.1"><vh>handleMouseWheel</vh></v>
<v t="felix.20250107230828.1"><vh>setCursorPos</vh></v>
<v t="felix.20250107230906.1"><vh>processInputs</vh></v>
<v t="felix.20250107230918.1"><vh>updateScroll</vh></v>
<v t="felix.20250107230936.1"><vh>isSelecting</vh></v>
</v>
<v t="felix.20250105212000.1"><vh>class Entities</vh>
<v t="felix.20250105212000.2"><vh>constructor</vh></v>
<v t="felix.20250105212000.3"><vh>spawn</vh></v>
<v t="felix.20250105212000.4"><vh>remove</vh></v>
</v>
<v t="felix.20250105212047.1"><vh>class EntityBehavior</vh>
<v t="felix.20250105212047.2"><vh>constructor</vh></v>
<v t="felix.20250105212047.3"><vh>process</vh></v>
<v t="felix.20250105212047.4"><vh>alien</vh></v>
</v>
<v t="felix.20250126174340.1"><vh>BaseRenderer</vh></v>
<v t="felix.20250126193731.1"><vh>TileRenderer</vh></v>
</v>
<v t="felix.20241220002054.1"><vh>@clean src/type.ts</vh>
<v t="felix.20241220002054.3"><vh>types</vh></v>
</v>
<v t="felix.20241224183015.1"><vh>@clean src/utils.ts</vh>
<v t="felix.20250122233854.1"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="felix.20241224183525.1"><vh>fullScreen</vh></v>
<v t="felix.20250120234029.1"><vh>interpolate</vh></v>
<v t="felix.20241228192145.1"><vh>loadImage</vh></v>
</v>
<v t="felix.20250107011547.1"><vh>@clean src/config.ts</vh></v>
<v t="felix.20250125002553.1"><vh>@clean src/shaders.ts</vh></v>
</vnodes>
<tnodes>
<t tx="felix.20241217200720.1">Basic WebGL RTS game engine

Based on the following tutorials:

- Main features use WebGL concepts such as VAO (Vertex Array Objects), UBO (Uniform Buffer Objects), draw instances, and shaders from the Andrew Adamson WebGL tutorials at https://www.youtube.com/watch?v=-T6EbWCq99c&amp;list=PLPbmjY2NVO_X1U1JzLxLDdRn4NmtxyQQo

- Window resize detection and handling for canvas from https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html

- Game class setup inspired by [James Byrde](https://github.com/jamesrehabstudio) tutorials at [https://www.youtube.com/@jamesbyrde3798](https://www.youtube.com/@jamesbyrde3798)

- Timing inspired from the [Glenn Fiedler](https://github.com/gafferongames) tutorial at [https://gafferongames.com/post/fix_your_timestep/](https://gafferongames.com/post/fix_your_timestep/)

</t>
<t tx="felix.20241217201352.1">@language typescript
&lt;&lt; imports &gt;&gt;
@others

</t>
<t tx="felix.20241217225540.1">(async () =&gt; {

    console.log('Hello World!');

    const canvas = document.querySelector('canvas')!;
    const gl = canvas.getContext('webgl2')!;

    const program = gl.createProgram()!;

    const vertexShader = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vertexShader, vertexShaderSource);
    gl.compileShader(vertexShader);
    gl.attachShader(program, vertexShader);

    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(fragmentShader, fragmentShaderSource);
    gl.compileShader(fragmentShader);
    gl.attachShader(program, fragmentShader);

    gl.linkProgram(program);

    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.log(gl.getShaderInfoLog(vertexShader));
        console.log(gl.getShaderInfoLog(fragmentShader));
        console.log(gl.getProgramInfoLog(program));
    }

    gl.useProgram(program);

    // * Start Program *

    const image = await loadImage('images/alien.png');

    let lastDisplayWidth = 0;
    let lastDisplayHeight = 0;

    const resizeObserver = new ResizeObserver(onResize);
    resizeObserver.observe(canvas, { box: 'content-box' });

    /**
     * Call before rendering in draw loop to resize canvas to display size. (in case of changing window size)
     * @param canvas 
     */
    function resizeCanvasToDisplaySize(canvas: HTMLCanvasElement) {
        // Get the size the browser is displaying the canvas in device pixels.
        const [displayWidth, displayHeight] = [lastDisplayWidth, lastDisplayHeight];

        // Check if the canvas is not the same size.
        const needResize = canvas.width !== displayWidth ||
            canvas.height !== displayHeight;

        if (needResize) {
            // Make the canvas the same size
            canvas.width = displayWidth;
            canvas.height = displayHeight;
        }

        return needResize;
    }

    function onResize(entries: any) {

        for (const entry of entries) {
            let width;
            let height;
            let dpr = window.devicePixelRatio;
            if (entry.devicePixelContentBoxSize) {
                // NOTE: Only this path gives the correct answer
                // The other 2 paths are an imperfect fallback
                // for browsers that don't provide anyway to do this
                width = entry.devicePixelContentBoxSize[0].inlineSize;
                height = entry.devicePixelContentBoxSize[0].blockSize;
                dpr = 1; // it's already in width and height
            } else if (entry.contentBoxSize) {
                if (entry.contentBoxSize[0]) {
                    width = entry.contentBoxSize[0].inlineSize;
                    height = entry.contentBoxSize[0].blockSize;
                } else {
                    // legacy
                    width = entry.contentBoxSize.inlineSize;
                    height = entry.contentBoxSize.blockSize;
                }
            } else {
                // legacy
                width = entry.contentRect.width;
                height = entry.contentRect.height;
            }
            const displayWidth = Math.round(width * dpr);
            const displayHeight = Math.round(height * dpr);
            [lastDisplayWidth, lastDisplayHeight] = [displayWidth, displayHeight];
        }
        console.log(lastDisplayWidth, lastDisplayHeight);
    }

    @others

})();

</t>
<t tx="felix.20241217225604.1">function loadImage(src: string): Promise&lt;HTMLImageElement&gt; {
    return new Promise((resolve, reject) =&gt; {
        const image = new Image();
        image.onload = () =&gt; resolve(image);
        image.src = src;
    });
}

</t>
<t tx="felix.20241217225754.1">// VERTEX SHADER
const vertexShaderSource = /*glsl*/ `#version 300 es

layout(location=0) in vec4 aPosition;
layout(location=1) in vec2 aTexCoord;
layout(location=2) in vec3 aOffset;
layout(location=3) in float aScale;
layout(location=4) in vec2 aUV;

out vec2 vTexCoord;

void main()
{
    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;
    gl_Position = vec4(aPosition.xyz * aScale + aOffset, 1.0);
}`;

// FRAGMENT SHADER
const fragmentShaderSource = /*glsl*/ `#version 300 es

precision mediump float;

uniform mediump sampler2D uSampler;

in vec2 vTexCoord;

out vec4 fragColor;

void main()
{
    fragColor = texture(uSampler, vTexCoord);
}`;

</t>
<t tx="felix.20241217230346.1">document.addEventListener('DOMContentLoaded', (event) =&gt; {
    if (!window.game) {
        window.game = new Game();
        window.game.resize(
            window.innerWidth,
            window.innerHeight,
            true // First resize not debounced.
        );
    } else {
        console.log('Game instance already started');
    }
});

window.addEventListener('resize', (event) =&gt; {
    if (window.game) {
        window.game.resize(
            window.innerWidth,
            window.innerHeight
        );
    }
});

function loop(timestamp: number): void {
    window.game.update(timestamp);
    requestAnimationFrame(loop);
}

</t>
<t tx="felix.20241217230454.1">export class Game {

    public started = false;
    public canvasRect: DOMRect;
    public optionsVisible = false;
    public menu: HTMLElement;


    public canvasElement: HTMLCanvasElement;
    public gl!: WebGL2RenderingContext;

    public worldSpaceMatrix: M3x3;

    // Game States
    public entities!: Entities;

    // Key press state
    public keysPressed: Record&lt;string, any&gt; = {};

    // Game Map
    public gamemap: number[] = [];

    // Screen States
    public screenx = 1920;
    public screeny = 1080;

    public selecting: boolean = false;
    public selx = 0; // Started selection at specific coords
    public sely = 0;

    public scrollx = 0; // Current scroll position 
    public scrolly = 0;

    public SCROLLSPEED = 50;   // speed in pixels for scrolling
    public SCROLLBORDER = 10; // 5;   // pixels from screen to trigger scrolling
    public xscr_e = this.screenx - this.SCROLLBORDER; // constants for finding trigger zone
    public yscr_e = this.screeny - this.SCROLLBORDER;


    public tilebmpsize = 1024;  // size of a bitmap of tiles
    public tilesize = 128;      // size of an individual square TILE 
    public tileratio = this.tilebmpsize / this.tilesize;
    public initrangex = (this.screenx / this.tilesize) + 1;
    public initrangey = (this.screeny / this.tilesize) + 1;

    public gamemapw = 9; // game map width in TILES 
    public gamemaph = 9;
    public maxmapx = (this.gamemapw * this.tilesize) - 1;
    public maxmapy = (this.gamemaph * this.tilesize) - 1;
    public maxscrollx = 1 + this.maxmapx - this.screenx;
    public maxscrolly = 1 + this.maxmapy - this.screeny;

    public scrollnowx = 0; // Scroll amount to be applied to scroll when processing
    public scrollnowy = 0;



    public htmlClassList: DOMTokenList;
    public curClass = ""; //"cur-pointer", "cur-target", "cur-select" ...

    public curx = 0 // Current mouse position
    public cury = 0

    public gamestate = 0   // 0=SPLASH
    // 1=Lobby (main menu)
    // 2=game Lobby
    // 3=play Loop
    // 4=Game over/stats
    // 5=EDITION ANIMS
    // 6=EDITION MAP
    // 7=OPTIONS

    public gameaction = 0    // 0=none
    public DEFAULTACTION = 1 // game actions CONSTANTS, zero means none
    public RELEASESEL = 2

    public gamecurx = 0
    public gamecury = 0
    public gameselx = 0
    public gamesely = 0

    // Test Cursor vatiables
    public curanim = 0
    public curanimtotal = 6
    public curanimx = 0
    public curanimy = 0

    // Test Orientation vatiable
    public testSpriteOrientation = 0;

    // FPS counter
    public lastTime = 0;
    public fps = 0;
    public fpsInterval = 1000; // Update FPS every 1 second
    public fpsLastTime = 0;

    // GAME-STATE TICKS AT 8 FPS
    public tickAccumulator = 0; // What remained in deltaTime after last update 
    public currentTick = 0;
    public timePerTick = 125; // dt in ms (125 is 8 per second)
    public timerTriggerAccum = this.timePerTick * 3; // 3 times the timePerTick

    // ANIMATIONS AT 15 FPS
    public animAccumulator = 0; // What remained in deltaTime after last update 
    public currentAnim = 0;
    public timePerAnim = 67; // dt in ms (66.66 is 15 per second)



    @others

}

</t>
<t tx="felix.20241217230518.1">resize(w: number, h: number, noDebounce?: boolean): void {
    // if (noDebounce) {
    //     this.calculateResize(w, h);
    // } else {
    //     if (this._resizeTimer) {
    //         clearTimeout(this._resizeTimer);
    //     }
    //     this._resizeTimer = setTimeout(() =&gt; {
    //         this.calculateResize(w, h); // Debounced
    //     }, 100);
    // }
}

</t>
<t tx="felix.20241217230522.1">update(timestamp: number, skipRender?: boolean): void {
    // 
}

</t>
<t tx="felix.20241220000920.1">constructor() {
    console.log('Init WebGL2 Game !');
    console.log('initrangex', this.initrangex);
    console.log('initrangey', this.initrangey);
    console.log('tileratio', this.tileratio);

    this.menu = document.getElementById('game-menu')!;

    this.htmlClassList = document.documentElement.classList;
    this.setCursor("cur-pointer");
    // this.canvasElement = document.createElement("canvas");

    this.canvasElement = document.querySelector('canvas')!;
    this.canvasElement.width = this.screenx;
    this.canvasElement.height = this.screeny;
    this.canvasRect = this.canvasElement.getBoundingClientRect();

    this.worldSpaceMatrix = new M3x3();

    this.gl = this.canvasElement.getContext('webgl2', {
        // antialias: false,
        // alpha: false,
        // depth: false,
    })!;
    // this.gl.enable(this.gl.BLEND);  // TODO: Check if needed

    // document.body.appendChild(this.canvasElement);

    // Prevent right-click context menu
    this.canvasElement.addEventListener('contextmenu', (event) =&gt; {
        event.preventDefault();
    });


    console.log('Starting the game!');

    document.addEventListener('keydown', (e) =&gt; {
        this.keysPressed[e.key] = true;
        if (e.key === 'F10') {
            e.preventDefault();  // Prevent default F10 behavior
            this.toggleGameMenu();
        }
        if (e.ctrlKey &amp;&amp; (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '_')) {
            e.preventDefault();
        }
        // 107 Num Key  +
        // 109 Num Key  -
        // 173 Min Key  hyphen/underscore key
        // 61 Plus key  +/= key

    });
    document.addEventListener('keyup', (e) =&gt; {
        this.keysPressed[e.key] = false;
    });

    const resumeButton = document.getElementById('resume-btn');

    resumeButton!.addEventListener('click', () =&gt; {
        this.toggleGameMenu();  // Close the menu and resume the game
    });

    window.addEventListener("mousemove", (event) =&gt; {
        this.mouseMove(event);
    });
    window.addEventListener("mousedown", (event) =&gt; {
        this.mouseDown(event);
    });
    window.addEventListener("mouseup", (event) =&gt; {
        this.mouseUp(event);
    });

    window.addEventListener("wheel DOMMouseScroll", (event: any) =&gt; {
        if (event.ctrlKey) {
            event.preventDefault(); // Prevents the default zoom behavior
            // Use the event's deltaY property to detect scroll direction
            // if (event.deltaY &lt; 0) {
            //     console.log("CTRL+Scroll Up"); // You could trigger a specific game action here
            // } else if (event.deltaY &gt; 0) {
            //     console.log("CTRL+Scroll Down");
            // }
        }
    }, { passive: false });

    // startButton.style.display = 'none';
    // resolutionSelect.style.display = 'none';
    // document.body.style.cursor = 'none'; // ! HIDE NATIVE CURSOR !
    this.started = true;
    // Setup timer in case RAF Skipped when not in foreground or minimized.
    setInterval(() =&gt; { this.checkUpdate(); }, 500);

    // TODO START ! 
    // loop(0); 

}

</t>
<t tx="felix.20241220001453.1">/**
 * Singleton Entities Object Pool
 */
export class Entities {

    public total: number;
    public active: number = 0;
    public pool: Array&lt;TEntity&gt; = [];
    private lastId = 0;

    @others

}
</t>
<t tx="felix.20241220001453.2">constructor(initialPoolSize: number) {
    this.total = initialPoolSize;
    for (let i = 0; i &lt; initialPoolSize; i++) {
        this.pool.push({
            id: 0,
            type: 0,
            hitPoints: 0,
            state: 0,
            x: 0,
            y: 0,
            orderQty: 0,
            orderIndex: 0,
            orderPool: [
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
            ],
            orientation: 0,
            frameIndex: 0,
            active: false,
        });
    }

}

</t>
<t tx="felix.20241220001453.3">spawn(): TEntity {
    if (this.active === this.total) {
        throw new Error("Pool Full");
    }
    const entity = this.pool.find(e =&gt; !e.active);
    if (entity) {
        entity.active = true;
        entity.id = ++this.lastId;
        this.active++;
        return entity;
    } else {
        throw new Error("Pool Full");
    }
}

</t>
<t tx="felix.20241220001453.4">remove(entity: TEntity): void {
    this.active--;
    entity.active = false;
}

</t>
<t tx="felix.20241220001536.1">// import * as Constants from "./constants";
// import * as utils from "./utils";
import { Point, M3x3 } from "./maths";
import { TEntity, } from "./type";

</t>
<t tx="felix.20241220001712.1">public toggleGameMenu(): void {

    if (this.menu.style.display === 'none') {
        this.menu.style.display = 'flex';  // Show the menu
        // Pause game logic here (if needed)
    } else {
        this.menu.style.display = 'none';  // Hide the menu
        // Resume game logic here (if needed)
    }
}

</t>
<t tx="felix.20241220001715.1">setCursor(newClass: string) {
    if (this.curClass !== newClass) {
        if (this.curClass) {
            this.htmlClassList.remove(this.curClass); // Remove from html
        }
        this.htmlClassList.add(newClass); // Add to html
        this.curClass = newClass; // Update the tracked cursor class
    }
}
</t>
<t tx="felix.20241220001738.1">public mouseDown(event: MouseEvent): void {
    this.setCursorPos(event);
    this.gamecurx = this.curx + this.scrollx;
    this.gamecury = this.cury + this.scrolly;
    if (!this.selecting) {
        if (event.button == 0) {
            this.selecting = true;
            this.setCursor("cur-target");
            this.selx = this.curx;
            this.sely = this.cury;
        }
        if (event.button == 2) {
            this.gameaction = this.DEFAULTACTION;
        }
    }
}

</t>
<t tx="felix.20241220001741.1">public mouseUp(event: MouseEvent): void {
    this.setCursorPos(event);
    this.gameselx = this.selx + this.scrollx;
    this.gamesely = this.sely + this.scrolly;
    this.gamecurx = this.curx + this.scrollx;
    this.gamecury = this.cury + this.scrolly;
    if (event.button == 0) {
        this.selecting = false;
        this.setCursor("cur-pointer");
        this.gameaction = this.RELEASESEL;
    }
}

</t>
<t tx="felix.20241220001745.1">public mouseMove(event: MouseEvent): void {
    this.setCursorPos(event);
    this.scrollnowx = 0;
    this.scrollnowy = 0;
    if (this.curx &gt; this.xscr_e) {
        this.scrollnowx = this.SCROLLSPEED;
    }
    if (this.cury &gt; this.yscr_e) {
        this.scrollnowy = this.SCROLLSPEED;
    }
    if (this.curx &lt; this.SCROLLBORDER) {
        this.scrollnowx = -this.SCROLLSPEED;
    }
    if (this.cury &lt; this.SCROLLBORDER) {
        this.scrollnowy = -this.SCROLLSPEED;
    }
}

</t>
<t tx="felix.20241220001755.1">public setCursorPos(event: MouseEvent): void {
    this.curx = (event.clientX - this.canvasRect.left) * (this.screenx / this.canvasRect.width);
    this.cury = (event.clientY - this.canvasRect.top) * (this.screeny / this.canvasRect.height);
}

</t>
<t tx="felix.20241220001814.1">public checkUpdate(): void {
    // Checks for needed ticks to be computed if game is minimized
    const timestamp = performance.now();
    const deltaTime = timestamp - this.lastTime;
    if ((this.tickAccumulator + deltaTime) &lt; this.timerTriggerAccum) {
        return;
    }
    // It's been a while, game is minimized: update without rendering.
    this.update(timestamp, true);
}

</t>
<t tx="felix.20241220002054.1">@others
</t>
<t tx="felix.20241220002054.3">export type Vec2 = { x: number, y: number };

export type TCommand = {
    order: number;
    x: number;
    y: number;
    entityId: number;
}

export type TEntity = {
    id: number;
    // states
    type: number;
    hitPoints: number;
    state: number;
    x: number;
    y: number;
    oldX: number; // For interpolation. Meaning that the entity is moving from oldX, oldY to x, y
    oldY: number;
    orientation: number;
    frameIndex: number;
    // Ten queuable commands
    orderQty: number;
    orderIndex: number;
    orderPool: [
        TCommand, TCommand, TCommand, TCommand, TCommand,
        TCommand, TCommand, TCommand, TCommand, TCommand
    ];
    active: boolean;
}

export type TParameters =
    | {
        uniform: true;
        location: WebGLUniformLocation;
        type: number;
    }
    | {
        uniform: false;
        location: number;
        type: number;
    };


export interface GLResources {
    buffers: WebGLBuffer[];
    textures: WebGLTexture[];
    shaders: WebGLShader[];
}

export type Color = {
    r: number;
    g: number;
    b: number;
};

export interface RenderableSprite {
    position: Vec2;
    scale: number;
    color: Color;
    frame: number;
    orientation: number;
}

export type SpriteUpdate = {
    index: number;
    properties: Partial&lt;RenderableSprite&gt;;
};

export enum ShaderType {
    VERTEX = WebGL2RenderingContext.VERTEX_SHADER,
    FRAGMENT = WebGL2RenderingContext.FRAGMENT_SHADER
}

export type WebGLError = {
    type: 'shader' | 'program' | 'buffer' | 'texture';
    message: string;
    details?: string;
}

export interface TileBufferData {
    posX: number;
    posY: number;
    scale: number;
    colorR: number;
    colorG: number;
    colorB: number;
    depth: number;
}
</t>
<t tx="felix.20241224183015.1">&lt;&lt; imports &gt;&gt;
@others
</t>
<t tx="felix.20241224183525.1">/**
 * Tries to put browser into fullscreen mode.
 * @param element The element to put into fullscreen mode.
 * @returns A promise that resolves when the browser is in fullscreen mode.
 */
export function fullScreen(element: Element): Promise&lt;void&gt; {
    if (document.fullscreenElement !== null) {
        return Promise.resolve();  // already fullscreen
    }
    if (element.requestFullscreen) {
        const requestFullscreen = element.requestFullscreen || (element as any).webkitRequestFullscreen || (element as any).mozRequestFullScreen || (element as any).msRequestFullscreen;
        if (requestFullscreen) {
            return requestFullscreen.call(element).catch((err) =&gt; {
                console.error(
                    `Error attempting to enable fullscreen mode: ${err.message} (${err.name})`,
                );
            });
        } else {
            return Promise.resolve();
        }
    } else {
        return Promise.resolve();
    }
}

</t>
<t tx="felix.20241224222932.1">public procGame(): void {

    // procgame processes a game frame, animating each RAF.
    // Note: This is not a game-states tick, at timePerTick intervals.

    if (this.gameaction) {

        switch (this.gameaction) {
            case this.DEFAULTACTION:
                this.trydefault()
                break;
            case this.RELEASESEL:
                this.tryselect()
                break;

            default:
                break;
        }

    }

    this.gameaction = 0 // -------------- no more game actions to do

    // Scroll if not selected    
    if (!this.selecting) {
        this.scrollx += this.scrollnowx;
        this.scrolly += this.scrollnowy;
        if (this.scrollx &gt; this.maxscrollx) {
            this.scrollx = this.maxscrollx;
        }
        if (this.scrollx &lt; 0) {
            this.scrollx = 0;
        }
        if (this.scrolly &gt; this.maxscrolly) {
            this.scrolly = this.maxscrolly;
        }
        if (this.scrolly &lt; 0) {
            this.scrolly = 0;
        }
    }
}

</t>
<t tx="felix.20241224222952.1">tick(): void {


    // Advance game states in pool:
    // meaning, from currentTick count, to the next one.

    // #########################################

    let processed = 0;
    let entity;
    for (let i = 0; processed &lt; this.entities.active || i &lt; this.entities.total; i++) {
        entity = this.entities.pool[i];
        if (entity.active) {
            processed += 1;
            // EXPERIMENT this.ai.process(entity);
        }
    }

    this.checkKeys();

    // Update currentTick count
    this.currentTick += 1;
}

</t>
<t tx="felix.20241224223038.1">public animateCursor(): void {
    // Animate at 15 FPS

    // Cursor
    if (this.curanim) {
        this.curanim += 1;
        if (this.curanim &gt; this.curanimtotal)
            this.curanim = 0
    }

}

</t>
<t tx="felix.20241224223235.1">public trydefault(): void {
    // TODO : Replace with real default action
    // TEST CURSOR ANIMATION ON DEFAULT ACTION
    this.curanim = 1;
    this.curanimx = this.gamecurx - 32;
    this.curanimy = this.gamecury - 32;
}

</t>
<t tx="felix.20241224223239.1">public tryselect(): void {
    // Called from procGame
}

</t>
<t tx="felix.20241224223317.1">checkKeys(): void {
    if (this.keysPressed['ArrowUp'] || this.keysPressed['w']) {
        // playerY -= playerSpeed * deltaTime;
        // EXPERIMENT  this.setCursor("cur-pointer");
    }
    if (this.keysPressed['ArrowDown'] || this.keysPressed['s']) {
        // playerY += playerSpeed * deltaTime;
        // EXPERIMENT  this.setCursor("cur-target");
    }
    if (this.keysPressed['ArrowLeft'] || this.keysPressed['a']) {
        // playerX -= playerSpeed * deltaTime;
        // EXPERIMENT  this.changeOrientation(false);
    }
    if (this.keysPressed['ArrowRight'] || this.keysPressed['d']) {
        // playerX += playerSpeed * deltaTime;
        // EXPERIMENT  this.changeOrientation(true);
    }
}

</t>
<t tx="felix.20241227202430.1">&lt;&lt; imports &gt;&gt;
@others
</t>
<t tx="felix.20241227202519.1">import * as utils from "./utils";
import { Vec2, TEntity, TParameters, GLResources, ShaderType, TileBufferData } from "./type";
import { CONFIG } from './config';
import { SHADERS } from './shaders';

</t>
<t tx="felix.20241227213048.1">document.addEventListener('DOMContentLoaded', (event) =&gt; {
    if (!window.game) {
        window.game = new Game();
    } else {
        console.log('Game instance already started');
    }
});

</t>
<t tx="felix.20241227213056.1">export class Game {

    inputManager: InputManager;

    // HTML Elements
    startButtonElement: HTMLButtonElement = document.createElement("button");
    resolutionSelectElement: HTMLSelectElement = document.createElement("select");

    // Canvas Properties
    lastDisplayWidth = 0;
    lastDisplayHeight = 0;
    canvasElement: HTMLCanvasElement;
    canvasBoundingRect: DOMRect;
    gl: WebGL2RenderingContext;

    // Game Screen Properties
    aspectRatio = 1; // set in startGame, this is display aspect ratio
    gameScreenWidth = 0; // set in startGame, this is game screen size, used as uWorldX.
    gameScreenHeight = 0; // Used as uWorldY.
    gameWidthRatio = 0; // set in startGame, this is game screen ratio to the canvas size
    gameHeightRatio = 0;
    scrollEdgeX = 0; // set in startGame, constants for finding trigger zone
    scrollEdgeY = 0;

    // Map Tile Properties
    tileRatio = CONFIG.GAME.TILE.BITMAP_SIZE / CONFIG.GAME.TILE.SIZE;
    initRangeX = (this.gameScreenWidth / CONFIG.GAME.TILE.SIZE) + 1; // set in startGame
    initRangeY = (this.gameScreenHeight / CONFIG.GAME.TILE.SIZE) + 1;
    maxMapX = (CONFIG.GAME.MAP.WIDTH * CONFIG.GAME.TILE.SIZE) - 1;
    maxMapY = (CONFIG.GAME.MAP.HEIGHT * CONFIG.GAME.TILE.SIZE) - 1;
    maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;
    maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;
    tileRenderer: TileRenderer | null = null;
    mapChanged = false;

    // Game state Properties
    gamemap: number[] = [];
    started = false;
    gameAction = 0;    // 0 = none
    entities!: Entities;
    entityBehaviors!: EntityBehavior;

    // Mouse Cursor Properties
    documentElementClassList: DOMTokenList; // Css rules rely on this to change cursor.
    currentCursorClass = ""; // "cur-pointer", "cur-target", "cur-select" ...

    // Command Acknowledged Widget Animation Properties
    widgetAnim = 0;
    widgetAnimTotal = 6;
    widgetAnimX = 0;
    widgetAnimY = 0;

    // Scroll Properties
    scrollX = 0; // Current scroll position 
    scrollY = 0;

    // Image Assets
    creaturesImage!: HTMLImageElement;
    tilesImage!: HTMLImageElement;

    // Game-State Ticks (at 8 fps)
    tickAccumulator = 0; // What remained in deltaTime after last update 
    currentTick = 0;
    timePerTick = 1000 / CONFIG.GAME.TIMING.TICK_RATE; // dt in ms (125 is 8 per second)
    timerTriggerAccum = this.timePerTick * 3; // 3 times the timePerTick

    // Graphic Animations (at 15 fps)
    animAccumulator = 0; // What remained in deltaTime after last update 
    currentAnim = 0;
    timePerAnim = 1000 / CONFIG.GAME.TIMING.ANIM_RATE; // dt in ms (66.66 is 15 per second)

    // FPS counter
    lastTime = 0;
    fps = 0;
    fpsInterval = CONFIG.GAME.TIMING.FPS_UPDATE_INTERVAL; // Update FPS every 1 second
    fpsLastTime = 0;

    @others

}

</t>
<t tx="felix.20241227213217.1">handleCanvasResize(entries: ResizeObserverEntry[]): void {
    // Canvas has style width: 100vw; and style height: 100vh;
    // So we need to handle a window resize which changes the canvas size.
    for (const entry of entries) {
        let width;
        let height;
        let dpr = window.devicePixelRatio;
        if (entry.devicePixelContentBoxSize) {
            // NOTE: Only this path gives the correct answer
            // The other 2 paths are an imperfect fallback
            // for browsers that don't provide anyway to do this
            width = entry.devicePixelContentBoxSize[0].inlineSize;
            height = entry.devicePixelContentBoxSize[0].blockSize;
            dpr = 1; // it's already in width and height
        } else if (entry.contentBoxSize) {
            if (entry.contentBoxSize[0]) {
                width = entry.contentBoxSize[0].inlineSize;
                height = entry.contentBoxSize[0].blockSize;
            } else {
                // legacy mozilla impl using only contentBox
                // @ts-expect-error
                width = entry.contentBoxSize.inlineSize;
                // @ts-expect-error
                height = entry.contentBoxSize.blockSize;
            }
        } else {
            // legacy
            width = entry.contentRect.width;
            height = entry.contentRect.height;
        }
        const displayWidth = Math.round(width * dpr);
        const displayHeight = Math.round(height * dpr);
        [this.lastDisplayWidth, this.lastDisplayHeight] = [displayWidth, displayHeight];

        this.setDimensionsVars();
    }
}

</t>
<t tx="felix.20241227213236.1">update(timestamp: number, skipRender?: boolean): void {
    const deltaTime = timestamp - this.lastTime;
    this.lastTime = timestamp;

    this.tickAccumulator += deltaTime;
    this.animAccumulator += deltaTime;

    this.procGame();

    while (this.animAccumulator &gt;= this.timePerAnim) {
        this.animateCursor();
        this.animAccumulator -= this.timePerAnim;
    }

    while (this.tickAccumulator &gt;= this.timePerTick) {
        this.tick();
        this.tickAccumulator -= this.timePerTick;
    }

    if (!skipRender) {
        // Gather renderable data and interpolate
        this.render(this.tickAccumulator / this.timePerTick);
    }

    // Calculate FPS
    if (timestamp - this.fpsLastTime &gt; this.fpsInterval) {
        this.fps = Math.round(1000 / deltaTime);
        this.fpsLastTime = timestamp;
        // console.log('RAF FPS ', this.fps); // 30
    }

}

</t>
<t tx="felix.20241227213841.1">constructor() {
    console.log("constructing game");

    this.documentElementClassList = document.documentElement.classList;

    this.canvasElement = document.createElement('canvas');
    document.body.appendChild(this.canvasElement);

    this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();

    this.gl = this.canvasElement.getContext('webgl2')!;
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
    this.gl.clearColor(0.0, 0.0, 0.0, 0.0); // transparent black

    // Prevent right-click context menu
    this.canvasElement.addEventListener('contextmenu', (event) =&gt; {
        event.preventDefault();
    });

    // Canvas has style width: 100vw; and style height: 100vh;
    const resizeObserver = new ResizeObserver(this.handleCanvasResize.bind(this));
    resizeObserver.observe(this.canvasElement, { box: 'content-box' });

    // Create a 'loading...' text element centered on screen
    const loadingText = document.createElement('div');
    loadingText.classList.add("loading-text");
    loadingText.textContent = 'Loading...';

    document.body.appendChild(loadingText);

    // Using promises, after both image assets have loaded, call mainMenu
    const creaturesPromise = utils.loadImage('images/alien.png');
    const tilesPromise = utils.loadImage('images/plancher-vertical.png');
    Promise.all([creaturesPromise, tilesPromise]).then((images) =&gt; {
        document.body.removeChild(loadingText);
        this.creaturesImage = images[0];
        this.tilesImage = images[1];
        this.resizeCanvasToDisplaySize(this.canvasElement);
        this.mainMenu();
    });

    this.inputManager = new InputManager(this);

}

</t>
<t tx="felix.20241228191055.1">resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {
    // Get the size the browser is displaying the canvas in device pixels.
    const [displayWidth, displayHeight] = [this.lastDisplayWidth, this.lastDisplayHeight];

    // Check if the canvas is not the same size.
    const needResize = canvas.width !== displayWidth ||
        canvas.height !== displayHeight;

    if (needResize) {
        // Make the canvas the same size
        canvas.width = displayWidth;
        canvas.height = displayHeight;

        // Set the viewport to fill the canvas
        this.gl.viewport(0, 0, canvas.width, canvas.height); // This will also clear the canvas  
    }

    return needResize;
}

</t>
<t tx="felix.20241228192145.1">export function loadImage(src: string): Promise&lt;HTMLImageElement&gt; {
    return new Promise((resolve, reject) =&gt; {
        const image = new Image();
        image.onload = () =&gt; resolve(image);
        image.src = src;
    });
}

</t>
<t tx="felix.20241228193009.1">mainMenu(): void {
    // The images have loaded, so it's time to show the pre-game menu

    // Create the start button
    this.startButtonElement.textContent = "Start Game";
    this.startButtonElement.classList.add("btn-start");

    document.body.appendChild(this.startButtonElement);

    // Create the dropdown for screen resolution
    this.resolutionSelectElement.classList.add("resolution-select");


    // Populate the dropdown with options
    for (const { label, width, height } of CONFIG.DISPLAY.RESOLUTIONS) {
        const option = document.createElement("option");
        option.value = `${width}x${height}`;
        option.textContent = label;
        this.resolutionSelectElement.appendChild(option);
    }
    document.body.appendChild(this.resolutionSelectElement);

    // Use resolutionSelect.selectedIndex to get the selected resolution

    this.startButtonElement.addEventListener("click", this.startGame.bind(this));

}

</t>
<t tx="felix.20241229162002.1">toggleGameMenu(): void {
    console.log('Toggle Game Menu'); // Todo: Implement Game Menu
}

</t>
<t tx="felix.20241229162229.1">checkUpdate(): void {
    // Checks for needed ticks to be computed if game is minimized
    const timestamp = performance.now();
    const deltaTime = timestamp - this.lastTime;
    if ((this.tickAccumulator + deltaTime) &lt; this.timerTriggerAccum) {
        return;
    }
    // It's been a while, game is minimized: update without rendering.
    this.update(timestamp, true);
}

</t>
<t tx="felix.20241229214656.1">loop(timestamp: number): void {
    this.update(timestamp);
    requestAnimationFrame(this.loop.bind(this));
}

</t>
<t tx="felix.20241229230016.1">startGame(): void {
    const resolution = CONFIG.DISPLAY.RESOLUTIONS[this.resolutionSelectElement.selectedIndex];
    this.aspectRatio = resolution.width / resolution.height;
    this.gameScreenWidth = resolution.width;
    this.gameScreenHeight = resolution.height;
    this.scrollEdgeX = this.gameScreenWidth - CONFIG.DISPLAY.SCROLL.BORDER; // constants for finding trigger zone
    this.scrollEdgeY = this.gameScreenHeight - CONFIG.DISPLAY.SCROLL.BORDER;

    // Re-set 
    this.initRangeX = (this.gameScreenWidth / CONFIG.GAME.TILE.SIZE) + 1;
    this.initRangeY = (this.gameScreenHeight / CONFIG.GAME.TILE.SIZE) + 1;
    this.maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;
    this.maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;

    console.log('Starting the game with aspect ratio', this.aspectRatio);

    this.setCursor("cur-pointer");

    this.inputManager.init();

    this.startButtonElement.style.display = 'none';
    this.resolutionSelectElement.style.display = 'none';

    // Start the game
    this.initGameStates();
    this.started = true;

    // Setup timer in case RAF Skipped when minimized or not in foreground.
    setInterval(() =&gt; { this.checkUpdate(); }, 500);
    this.loop(0);
}

</t>
<t tx="felix.20241230215224.1">procGame(): void {

    // procgame processes a game frame, animating each RAF.
    // Note: This is not a game-states tick, at timePerTick intervals.

    if (this.gameAction) {

        switch (this.gameAction) {
            case CONFIG.GAME.ACTIONS.DEFAULT:
                this.trydefault();
                break;
            case CONFIG.GAME.ACTIONS.RELEASESEL:
                this.tryselect();
                break;

            default:
                break;
        }

    }

    this.gameAction = 0; // -------------- no more game actions to do

    // Scroll if not currently dragging a selection.
    if (!this.inputManager.isSelecting) {
        const scrollVelocity = this.inputManager.scrollVelocity;
        this.scrollX += scrollVelocity.x;
        this.scrollY += scrollVelocity.y;
        if (this.scrollX &gt; this.maxScrollX) {
            this.scrollX = this.maxScrollX;
        }
        if (this.scrollX &lt; 0) {
            this.scrollX = 0;
        }
        if (this.scrollY &gt; this.maxScrollY) {
            this.scrollY = this.maxScrollY;
        }
        if (this.scrollY &lt; 0) {
            this.scrollY = 0;
        }
    }
}

</t>
<t tx="felix.20241230215229.1">/**
 * Advance game states in pool from currentTick count, to the next one.
 */
tick(): void {

    // Process Entities
    let processed = 0;
    let entity;
    for (let i = 0; processed &lt; this.entities.active || i &lt; this.entities.total; i++) {
        entity = this.entities.pool[i];
        if (entity.active) {
            processed += 1;
            this.entityBehaviors.process(entity);
        }
    }

    this.inputManager.processInputs();

    // Update currentTick count
    this.currentTick += 1;
}

</t>
<t tx="felix.20241230215401.1">trydefault(): void {
    const gamePosition = this.inputManager.gamePosition;
    console.log('default', gamePosition.x, gamePosition.y);
    // TODO : Replace with test cursor animation with the real default action
    // TEST START WIDGET ANIMATION ON DEFAULT ACTION
    this.widgetAnim = 1;
    this.widgetAnimX = gamePosition.x - 32;
    this.widgetAnimY = gamePosition.y - 32;

}

</t>
<t tx="felix.20241230215406.1">tryselect(): void {
    // Called from procGame
    const selectionStart = this.inputManager.selectionStart;
    const selectionEnd = this.inputManager.selectionEnd;
    console.log('select', selectionStart.x, selectionStart.y, selectionEnd.x, selectionEnd.y);
}

</t>
<t tx="felix.20241231221007.1">render(interpolation: number): void {



    // Set clear color to black
    this.gl.clearColor(0.0, 0.0, 0.0, 1.0);

    // Before rendering, resize canvas to display size. (in case of changing window size)
    if (!this.resizeCanvasToDisplaySize(this.canvasElement)) {
        // If it did not resize and call gl.viewport which clears the canvas, we need to clear it again.
        this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    }

    // Render the game

    // 1 Render the game map. Map states are in this.gamemap and rarely change.
    if (this.tileRenderer) {
        if (this.mapChanged) {
            this.tileRenderer.updateTransformData(this.gamemap);
            this.mapChanged = false;
        }
        this.tileRenderer.render();
    }

    // TODO: 2 Render the game entities. Entity states are in this.entities.pool and change often.

    // TODO: 3 Render Selection lines, if user is selecting.

    // Finished
    this.gl.flush();
}

</t>
<t tx="felix.20241231225835.1">animateCursor(): void {
    // Animate at 15 FPS

    // Cursor
    if (this.widgetAnim) {
        this.widgetAnim += 1;
        if (this.widgetAnim &gt; this.widgetAnimTotal)
            this.widgetAnim = 0;
    }

}

</t>
<t tx="felix.20250101211507.1">setCursor(newClass: string) {
    if (this.currentCursorClass !== newClass) {
        if (this.currentCursorClass) {
            this.documentElementClassList.remove(this.currentCursorClass); // Remove from html
        }
        this.documentElementClassList.add(newClass); // Add to html
        this.currentCursorClass = newClass; // Update the tracked cursor class
    }
}

</t>
<t tx="felix.20250101222813.1">setDimensionsVars(): DOMRect {
    this.canvasBoundingRect = this.canvasElement.getBoundingClientRect();
    this.gameWidthRatio = (this.gameScreenWidth / this.canvasBoundingRect.width);
    this.gameHeightRatio = (this.gameScreenHeight / this.canvasBoundingRect.height)
    this.maxScrollX = 1 + this.maxMapX - this.gameScreenWidth;
    this.maxScrollY = 1 + this.maxMapY - this.gameScreenHeight;

    return this.canvasBoundingRect;
}

</t>
<t tx="felix.20250105212000.1">/**
 * Singleton Entities Object Pool
 */
export class Entities {

    public total: number;
    public active: number = 0;
    public pool: Array&lt;TEntity&gt; = [];
    private lastId = 0;

    @others

}

</t>
<t tx="felix.20250105212000.2">constructor(initialPoolSize: number) {
    this.total = initialPoolSize;
    for (let i = 0; i &lt; initialPoolSize; i++) {
        this.pool.push({
            id: 0,
            type: 0,
            hitPoints: 0,
            state: 0,
            x: 0,
            y: 0,
            oldX: 0,
            oldY: 0,
            orderQty: 0,
            orderIndex: 0,
            orderPool: [
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
                { order: 0, x: 0, y: 0, entityId: 0 }, { order: 0, x: 0, y: 0, entityId: 0 },
            ],
            orientation: 0,
            frameIndex: 0,
            active: false,
        });
    }

}

</t>
<t tx="felix.20250105212000.3">spawn(): TEntity {
    if (this.active === this.total) {
        throw new Error("Pool Full");
    }
    const entity = this.pool.find(e =&gt; !e.active);
    if (entity) {
        entity.active = true;
        entity.id = ++this.lastId;
        this.active++;
        return entity;
    } else {
        throw new Error("Pool Full");
    }
}

</t>
<t tx="felix.20250105212000.4">remove(entity: TEntity): void {
    this.active--;
    entity.active = false;
}

</t>
<t tx="felix.20250105212047.1">export class EntityBehavior {

    public game: Game;

    @others

}

</t>
<t tx="felix.20250105212047.2">constructor(game: Game) {
    this.game = game;
}

</t>
<t tx="felix.20250105212047.3">public process(entity: TEntity): void {
    switch (entity.type) {
        case 1:
            this.alien(entity);
            break;

        default:
            break;
    }
}

</t>
<t tx="felix.20250105212047.4">private alien(entity: TEntity): void {
    // test by just incrementing forward in animations
    // 249 is the number of frames in the sprite sheet
    entity.frameIndex = (entity.frameIndex + 1) % 249;
    // TODO : Add real behaviors!
}

</t>
<t tx="felix.20250105213621.1">initGameStates(): void {

    // For now, we will just create a TileRenderer
    console.log(this.gameScreenWidth, this.gameScreenHeight);
    this.tileRenderer = new TileRenderer(this.gl, this.tilesImage, this.initRangeX * this.initRangeY, this.gameScreenWidth, this.gameScreenHeight);
    // const spriteRenderer = new SpriteRenderer(gl, spriteImage); // TODO: Implement SpriteRenderer
    // const lineRenderer = new RectangleRenderer(gl); // TODO: Implement RectangleRenderer

    // Create a uniform buffer
    const worldBuffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.UNIFORM_BUFFER, worldBuffer);
    this.gl.bufferData(this.gl.UNIFORM_BUFFER, 2 * Float32Array.BYTES_PER_ELEMENT, this.gl.DYNAMIC_DRAW);

    // Bind the buffer to binding point 0
    this.gl.bindBufferBase(this.gl.UNIFORM_BUFFER, 0, worldBuffer);

    // Set the uniform block binding for both programs
    const tileProgram = this.tileRenderer.program;
    // const spriteProgram = spriteRenderer.program;
    // const lineProgram = lineRenderer.program;

    const worldIndex = 0; // Binding point 0

    const tileBlockIndex = this.gl.getUniformBlockIndex(tileProgram, 'World');
    this.gl.uniformBlockBinding(tileProgram, tileBlockIndex, worldIndex);

    // const spriteBlockIndex = this.gl.getUniformBlockIndex(spriteProgram, 'World');
    // this.gl.uniformBlockBinding(spriteProgram, spriteBlockIndex, worldIndex);

    // const lineBlockIndex = this.gl.getUniformBlockIndex(lineProgram, 'World');
    // this.gl.uniformBlockBinding(lineProgram, lineBlockIndex, worldIndex);

    window.addEventListener('unload', () =&gt; {
        this.tileRenderer?.dispose();
        // spriteRenderer?.dispose();
        // lineRenderer?.dispose();
    });

    // Build entities pool
    this.entities = new Entities(100);
    this.entityBehaviors = new EntityBehavior(this);

    // Fill Entities pool
    // EXPERIMENTAL TEST: Create 3 test Aliens
    const alien1 = this.entities.spawn();
    alien1.type = 1;
    alien1.hitPoints = 100;
    alien1.x = 515;
    alien1.y = 100;
    const alien2 = this.entities.spawn();
    alien2.type = 1;
    alien2.hitPoints = 100;
    alien2.x = 0;
    alien2.y = 0;
    const alien3 = this.entities.spawn();
    alien3.type = 1;
    alien3.hitPoints = 100;
    alien3.x = 64;
    alien3.y = 64;

    // Build Map (Will later be bigger maps loaded from file)
    // EXPERIMENTAL TEST: temp map 9 by 9 tiles 
    for (let temp1 = 0; temp1 &lt; 8; temp1++) { // start with 8 ROWS 
        this.gamemap.push(temp1 * 8); // added row total 1 width COLUMN
        for (let temp2 = 0; temp2 &lt; 8; temp2++) {  // + 8 COLUMNS
            this.gamemap.push(temp2 + temp1 * 8); // here add for total of 9 width COLUMNS
        }
    }
    this.gamemap[21] = 3; // Proof CHANGE THOSE GAMEMAPS TO PROVE THEY ARE TILES
    for (let temp = 0; temp &lt; 9; temp++) { // add last row for total of 9 ROWS
        this.gamemap.push(temp + 56);
    }

    this.mapChanged = true;
}

</t>
<t tx="felix.20250106224739.1">export class ShaderProgram {

    public gl!: WebGL2RenderingContext;
    public program!: WebGLProgram;
    public parameters: Record&lt;string, TParameters&gt; = {};

    @others

}

</t>
<t tx="felix.20250106224739.2">constructor(gl: WebGL2RenderingContext, vs: string, fs: string) {
    this.gl = gl;

    const vsShader = this.getShader(vs, gl.VERTEX_SHADER);
    const fsShader = this.getShader(fs, gl.FRAGMENT_SHADER);

    if (vsShader &amp;&amp; fsShader) {
        this.program = gl.createProgram()!;
        gl.attachShader(this.program, vsShader);
        gl.attachShader(this.program, fsShader);
        gl.linkProgram(this.program);
        if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
            console.error("Cannot load shader \n" + gl.getProgramInfoLog(this.program));
        }

        this.gatherParameters();

        gl.detachShader(this.program, vsShader);
        gl.detachShader(this.program, fsShader);
        gl.deleteShader(vsShader);
        gl.deleteShader(fsShader);

        gl.useProgram(null);
    }
}

</t>
<t tx="felix.20250106224739.3">getShader(script: string, type: number): WebGLShader | null {
    const gl = this.gl;
    const output = gl.createShader(type);
    if (output) {
        gl.shaderSource(output, script);
        gl.compileShader(output);
        if (!gl.getShaderParameter(output, gl.COMPILE_STATUS)) {
            console.error("Shader Error: \n" + gl.getShaderInfoLog(output));
            return null;
        }
    }
    return output;
}

</t>
<t tx="felix.20250106224739.4">gatherParameters(): void {
    const gl = this.gl;
    let isUniform = 0;

    this.parameters = {};
    while (isUniform &lt; 2) {
        let paramType = isUniform ? gl.ACTIVE_UNIFORMS : gl.ACTIVE_ATTRIBUTES;
        let count = gl.getProgramParameter(this.program, paramType);

        for (let i = 0; i &lt; count; i++) {
            let details;
            let location;
            if (isUniform) {
                details = gl.getActiveUniform(this.program, i);
                location = gl.getUniformLocation(this.program, details!.name);
                this.parameters[details!.name] = {
                    location: location as WebGLUniformLocation,
                    uniform: true,
                    type: details!.type
                };
            } else {
                details = gl.getActiveAttrib(this.program, i);
                location = gl.getAttribLocation(this.program, details!.name);
                this.parameters[details!.name] = {
                    location: location as number,
                    uniform: false,
                    type: details!.type
                };
            }

        }
        isUniform++;
    }

}

</t>
<t tx="felix.20250106224739.5">setParam(w_name: string, a?: any, b?: any, c?: any, d?: any) {

    if (!(w_name in this.parameters)) {
        return;
    }

    const gl = this.gl;
    const param = this.parameters[w_name];

    if (param.uniform) {
        this.setUniform(param, a, b, c, d);
    } else {
        this.setAttribute(param, a, b, c, d);
    }

}

</t>
<t tx="felix.20250106224739.6">private setUniform(param: TParameters &amp; { uniform: true }, a?: any, b?: any, c?: any, d?: any) {
    const gl = this.gl;

    switch (param.type) {
        case gl.FLOAT:
            gl.uniform1f(param.location, a);
            break;
        case gl.FLOAT_VEC2:
            gl.uniform2f(param.location, a, b);
            break;
        case gl.FLOAT_VEC3:
            gl.uniform3f(param.location, a, b, c);
            break;
        case gl.FLOAT_VEC4:
            gl.uniform4f(param.location, a, b, c, d);
            break;
        case gl.FLOAT_MAT3:
            gl.uniformMatrix3fv(param.location, false, a);
            break;
        case gl.FLOAT_MAT4:
            gl.uniformMatrix4fv(param.location, false, a);
            break;
        case gl.SAMPLER_2D:
            gl.uniform1i(param.location, a);
            break;
        default:
            console.warn(`Unsupported uniform type: ${param.type}`);
    }
}

</t>
<t tx="felix.20250106224739.7">private setAttribute(param: TParameters &amp; { uniform: false }, a?: any, b?: any, c?: any, d?: any) {
    const gl = this.gl;

    gl.enableVertexAttribArray(param.location);
    const type = a ?? gl.FLOAT;
    const normalized = b ?? false;
    const stride = c ?? 0;
    const offset = d ?? 0;

    switch (param.type) {
        case gl.FLOAT:
            gl.vertexAttribPointer(param.location, 1, type, normalized, stride, offset);
            break;
        case gl.FLOAT_VEC2:
            gl.vertexAttribPointer(param.location, 2, type, normalized, stride, offset);
            break;
        case gl.FLOAT_VEC3:
            gl.vertexAttribPointer(param.location, 3, type, normalized, stride, offset);
            break;
        case gl.FLOAT_VEC4:
            gl.vertexAttribPointer(param.location, 4, type, normalized, stride, offset);
            break;
        default:
            console.warn(`Unsupported attribute type: ${param.type}`);
    }
}
</t>
<t tx="felix.20250107011547.1">const DISPLAY = {
    RESOLUTIONS: [
        {
            label: "16:9 (1920x1080)",
            width: 1920,
            height: 1080
        },
        {
            label: "16:10 (1920x1200)",
            width: 1920,
            height: 1200
        },
        {
            label: "4:3 (1440x1080)",
            width: 1440,
            height: 1080
        },
    ],
    SCROLL: {
        SPEED: 50, // speed in pixels for scrolling
        BORDER: 10 // pixels from screen to trigger scrolling
    }
} as const;

const GAME = {
    ACTIONS: {
        DEFAULT: 1,
        RELEASESEL: 2
    },
    TILE: {
        BITMAP_SIZE: 1024, // size of a square bitmap of tiles
        SIZE: 128, // size of an individual square TILE 
        DEPTH: 64
    },
    MAP: {
        WIDTH: 9, // game map width in TILES 
        HEIGHT: 9 // game map height in TILES 
    },
    TIMING: {
        TICK_RATE: 8, // 8 fps for game logic
        ANIM_RATE: 15, // 15 fps for animations
        FPS_UPDATE_INTERVAL: 1000 // Update FPS display every second
    },
    ENTITY: {
        INITIAL_POOL_SIZE: 100
    }
} as const;

const TEXTURE_MODEL_DATA = new Float32Array([
    // XY Coords, UV Offset 
    1, 0, 1, 0,
    0, 1, 0, 1,
    1, 1, 1, 1,
    1, 0, 1, 0,
    0, 0, 0, 0,
    0, 1, 0, 1,
]);

const RECTANGLE_MODEL_DATA = new Float32Array([
    // XY Coords
    1, 0,
    0, 1,
    1, 1,
    1, 0,
    0, 0,
    0, 1,
]);

// Export all configs from a single point
export const CONFIG = {
    TEXTURE_MODEL_DATA,
    RECTANGLE_MODEL_DATA,
    DISPLAY,
    GAME
} as const;
</t>
<t tx="felix.20250107221804.1">export class InputManager {
    private game: Game;
    private keysPressed: Record&lt;string, boolean&gt; = {};
    private selecting: boolean = false;
    private mouseX = 0;
    private mouseY = 0;
    private gameMouseX = 0;
    private gameMouseY = 0;
    private selX = 0;
    private selY = 0;
    private gameSelStartX = 0;
    private gameSelStartY = 0;
    private gameSelEndX = 0;
    private gameSelEndY = 0;
    private scrollNowX = 0;
    private scrollNowY = 0;

    @others

}

</t>
<t tx="felix.20250107221855.1">constructor(game: Game) {
    this.game = game;
}

</t>
<t tx="felix.20250107230733.1">public init(): void {
    window.addEventListener("keydown", this.handleKeyDown.bind(this));
    window.addEventListener("keyup", this.handleKeyUp.bind(this));
    window.addEventListener("mousemove", this.handleMouseMove.bind(this));
    window.addEventListener("mousedown", this.handleMouseDown.bind(this));
    window.addEventListener("mouseup", this.handleMouseUp.bind(this));
    window.addEventListener("wheel", this.handleMouseWheel.bind(this), { passive: false });
}
</t>
<t tx="felix.20250107230755.1">private handleKeyDown(e: KeyboardEvent): void {
    this.keysPressed[e.key] = true;
    if (e.key === 'F10') {
        e.preventDefault();
        this.game.toggleGameMenu();
    }
    if (e.ctrlKey &amp;&amp; (e.key === '+' || e.key === '-' || e.key === '=' || e.key === '_')) {
        e.preventDefault();
    }
}

</t>
<t tx="felix.20250107230802.1">private handleKeyUp(e: KeyboardEvent): void {
    this.keysPressed[e.key] = false;
}

</t>
<t tx="felix.20250107230806.1">private handleMouseMove(event: MouseEvent): void {
    this.setCursorPos(event);
    this.scrollNowX = 0;
    this.scrollNowY = 0;

    if (this.mouseX &gt; this.game.scrollEdgeX) {
        this.scrollNowX = CONFIG.DISPLAY.SCROLL.SPEED;
    }
    if (this.mouseY &gt; this.game.scrollEdgeY) {
        this.scrollNowY = CONFIG.DISPLAY.SCROLL.SPEED;
    }
    if (this.mouseX &lt; CONFIG.DISPLAY.SCROLL.BORDER) {
        this.scrollNowX = -CONFIG.DISPLAY.SCROLL.SPEED;
    }
    if (this.mouseY &lt; CONFIG.DISPLAY.SCROLL.BORDER) {
        this.scrollNowY = -CONFIG.DISPLAY.SCROLL.SPEED;
    }
}

</t>
<t tx="felix.20250107230811.1">private handleMouseDown(event: MouseEvent): void {
    this.setCursorPos(event);
    if (!this.selecting) {
        if (event.button === 0) {
            this.selecting = true;
            this.game.setCursor('cur-target');
            this.selX = this.mouseX;
            this.selY = this.mouseY;
            this.gameSelStartX = this.selX + this.game.scrollX;
            this.gameSelStartY = this.selY + this.game.scrollY;
        }
        if (event.button === 2) {
            this.game.gameAction = CONFIG.GAME.ACTIONS.DEFAULT;
        }
    }
}

</t>
<t tx="felix.20250107230817.1">private handleMouseUp(event: MouseEvent): void {
    this.setCursorPos(event);
    if (event.button === 0) {
        this.gameSelEndX = this.mouseX + this.game.scrollX;
        this.gameSelEndY = this.mouseY + this.game.scrollY;
        this.selecting = false;
        this.game.setCursor('cur-pointer');
        this.game.gameAction = CONFIG.GAME.ACTIONS.RELEASESEL;
    }
}

</t>
<t tx="felix.20250107230822.1">private handleMouseWheel(event: WheelEvent): void {
    if (event.ctrlKey) {
        event.preventDefault();
    }
    if (event.deltaY &lt; 0) {
        // Todo: Zoom in
        console.log("CTRL+Scroll Up"); // You could trigger a specific game action here
    } else if (event.deltaY &gt; 0) {
        // Todo: Zoom out
        console.log("CTRL+Scroll Down");
    }
}

</t>
<t tx="felix.20250107230828.1">private setCursorPos(event: MouseEvent): void {
    this.mouseX = event.clientX * (this.game.gameScreenWidth / this.game.canvasBoundingRect.width);
    this.mouseY = event.clientY * (this.game.gameScreenHeight / this.game.canvasBoundingRect.height);
    this.gameMouseX = this.mouseX + this.game.scrollX;
    this.gameMouseY = this.mouseY + this.game.scrollY;
}

</t>
<t tx="felix.20250107230906.1">public processInputs(): void {
    if (this.keysPressed['ArrowUp'] || this.keysPressed['w']) {
        //
    }
    if (this.keysPressed['ArrowDown'] || this.keysPressed['s']) {
        //
    }
    if (this.keysPressed['ArrowLeft'] || this.keysPressed['a']) {
        // 
    }
    if (this.keysPressed['ArrowRight'] || this.keysPressed['d']) {
        //
    }
    if (!this.selecting) {
        this.updateScroll();
    }
}

</t>
<t tx="felix.20250107230918.1">private updateScroll(): void {
    this.game.scrollX += this.scrollNowX;
    this.game.scrollY += this.scrollNowY;

    // Clamp scroll values
    this.game.scrollX = Math.max(0, Math.min(this.game.scrollX, this.game.maxScrollX));
    this.game.scrollY = Math.max(0, Math.min(this.game.scrollY, this.game.maxScrollY));
}

</t>
<t tx="felix.20250107230936.1">public get isSelecting(): boolean {
    return this.selecting;
}

</t>
<t tx="felix.20250107232140.1">public get mousePosition(): { x: number, y: number } {
    return { x: this.mouseX, y: this.mouseY };
}

public get gamePosition(): { x: number, y: number } {
    return { x: this.gameMouseX, y: this.gameMouseY };
}

public get selectionStart(): { x: number, y: number } {
    return { x: this.gameSelStartX, y: this.gameSelStartY };
}

public get selectionEnd(): { x: number, y: number } {
    return { x: this.gameSelEndX, y: this.gameSelEndY };
}

public get scrollVelocity(): { x: number, y: number } {
    return { x: this.scrollNowX, y: this.scrollNowY };
}


</t>
<t tx="felix.20250108220449.1">export class GLContext {
    private gl: WebGL2RenderingContext;
    private boundBuffers: Map&lt;string, WebGLBuffer&gt; = new Map();
    private boundTextures: Map&lt;string, WebGLTexture&gt; = new Map();
    private activeShader: WebGLProgram | null = null;

    @others

}

</t>
<t tx="felix.20250108220555.1">constructor(canvas: HTMLCanvasElement) {
    const gl = canvas.getContext('webgl2');
    if (!gl) {
        throw new Error('WebGL 2 not supported');
    }
    this.gl = gl;
    this.setupGL();
}
</t>
<t tx="felix.20250108220609.1">public createBuffer(data: Float32Array | Uint16Array, target: number = this.gl.ARRAY_BUFFER): WebGLBuffer {
    const buffer = this.gl.createBuffer();
    if (!buffer) throw new Error('Failed to create buffer');

    this.gl.bindBuffer(target, buffer);
    this.gl.bufferData(target, data, this.gl.STATIC_DRAW);
    return buffer;
}

</t>
<t tx="felix.20250108220630.1">private setupGL(): void {
    this.gl.enable(this.gl.BLEND);
    this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
    this.gl.enable(this.gl.DEPTH_TEST);
    this.gl.depthFunc(this.gl.LEQUAL);
}

</t>
<t tx="felix.20250108220643.1">public createTexture(image: HTMLImageElement, options = {
    wrap: this.gl.CLAMP_TO_EDGE,
    filter: this.gl.NEAREST
}): WebGLTexture {
    const texture = this.gl.createTexture();
    if (!texture) throw new Error('Failed to create texture');

    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);
    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA,
        this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);

    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, options.wrap);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, options.wrap);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, options.filter);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, options.filter);

    return texture;
}

</t>
<t tx="felix.20250108220648.1">public useProgram(program: WebGLProgram): void {
    if (this.activeShader !== program) {
        this.gl.useProgram(program);
        this.activeShader = program;
    }
}

</t>
<t tx="felix.20250108220655.1">public clear(r: number = 0, g: number = 0, b: number = 0, a: number = 1): void {
    this.gl.clearColor(r, g, b, a);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
}

</t>
<t tx="felix.20250108220715.1">public setViewport(width: number, height: number): void {
    this.gl.viewport(0, 0, width, height);
}

</t>
<t tx="felix.20250108220720.1">public bindVAO(vao: WebGLVertexArrayObject | null): void {
    this.gl.bindVertexArray(vao);
}

</t>
<t tx="felix.20250108221254.1">public setAttribute(location: number, size: number, type: number,
    normalized: boolean, stride: number, offset: number): void {
    this.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
    this.gl.enableVertexAttribArray(location);
}

</t>
<t tx="felix.20250108221302.1">public draw(mode: number, count: number, offset: number = 0): void {
    this.gl.drawArrays(mode, offset, count);
}

</t>
<t tx="felix.20250108221307.1">public drawElements(mode: number, count: number, type: number, offset: number = 0): void {
    this.gl.drawElements(mode, count, type, offset);
}

</t>
<t tx="felix.20250108221318.1">public checkError(operation: string): void {
    const error = this.gl.getError();
    if (error !== this.gl.NO_ERROR) {
        throw new Error(`WebGL Error after ${operation}: ${error}`);
    }
}

</t>
<t tx="felix.20250120234029.1">export function interpolate(min: Vec2, max: Vec2, fract: number): Vec2 {
    return { x: max.x + (min.x - max.x) * fract, y: max.y + (min.y - max.y) * fract };
}

</t>
<t tx="felix.20250122233854.1">import { Vec2 } from "./type";

</t>
<t tx="felix.20250125002444.1">Archives of old stuff/unused stuff
</t>
<t tx="felix.20250125002553.1">
// BACKGROUND MAP VERTEX SHADER
const TILE_VERTEX_SHADER = /*glsl*/ `#version 300 es

// The next two are the repeated geometry and UV for each instance of the model
layout(location=0) in vec4 aPosition;
layout(location=1) in vec2 aTexCoord;

// Those next four use vertexAttribDivisor and are updated every instance
layout(location=2) in vec3 aOffset;
layout(location=3) in float aScale;
layout(location=4) in vec4 aColor;
layout(location=5) in float aDepth;

layout(std140) uniform World {
    float uWorldX;
    float uWorldY;
};

out vec4 vColor;
out vec2 vTexCoord;
out float vDepth;

void main()
{
    vColor = aColor;
    vTexCoord = aTexCoord;
    vDepth = aDepth;
    vec3 pos = aPosition.xyz * aScale + aOffset;
    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.
    // gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);
    gl_Position = vec4( vec3(aPosition.xyz + aOffset), 1.0);

}`;

// BACKGROUND MAP FRAGMENT SHADER
const TILE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es

precision mediump float;

uniform mediump sampler2DArray uSampler;

in vec4 vColor;
in vec2 vTexCoord;
in float vDepth;
out vec4 fragColor;

void main()
{
    fragColor = vColor * texture(uSampler, vec3(vTexCoord, vDepth));
}`;

// ALIEN CREATURE SPRITE VERTEX SHADER
const SPRITE_VERTEX_SHADER = /*glsl*/ `#version 300 es

// The next two are the repeated geometry and UV for each instance of the model
layout(location=0) in vec4 aPosition;
layout(location=1) in vec2 aTexCoord;

// Those next four use vertexAttribDivisor and are updated every instance
layout(location=2) in vec3 aOffset;
layout(location=3) in float aScale;
layout(location=4) in vec4 aColor;
layout(location=5) in vec2 aUV;

layout(std140) uniform World {
    float uWorldX;
    float uWorldY;
};

out vec4 vColor;
out vec2 vTexCoord;

void main()
{
    vColor = aColor;
    vTexCoord = vec2(aTexCoord * 0.015625) + aUV;

    vec3 pos = aPosition.xyz * aScale + aOffset;

    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.
    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);

}`;

// ALIEN CREATURE SPRITE FRAGMENT SHADER
const SPRITE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es

precision mediump float;

uniform mediump sampler2D uSampler;

in vec4 vColor;
in vec2 vTexCoord;
out vec4 fragColor;

void main()
{
    fragColor = vColor * texture(uSampler, vTexCoord);
}`;

// SELECTION LINE VERTEX SHADER
const RECTANGLE_VERTEX_SHADER = /*glsl*/ `#version 300 es

// The next two are the repeated geometry and UV for each instance of the model
layout(location=0) in vec4 aPosition;

// Those next four use vertexAttribDivisor and are updated every instance
layout(location=1) in vec3 aOffset;
layout(location=2) in float aScaleX;
layout(location=3) in float aScaleY;
layout(location=4) in vec4 aColor;

layout(std140) uniform World {
    float uWorldX;
    float uWorldY;
};

out vec4 vColor;

void main()
{
    vColor = aColor;
    vec3 pos = aPosition.xyz * vec3(aScaleX, aScaleY, 1.0) + aOffset;
    
    // This brings it in the range 0-2. So it also needs a -1 to 1 conversion.
    gl_Position = vec4((pos.x * uWorldX) - 1.0, (pos.y * uWorldY) + 1.0, pos.z, 1.0);

}`;

// SELECTION LINE SPRITE FRAGMENT SHADER
const RECTANGLE_FRAGMENT_SHADER = /*glsl*/ `#version 300 es

precision mediump float;

in vec4 vColor;
out vec4 fragColor;

void main()
{
    fragColor = vColor;
}`;

// Export all configs from a single point
export const SHADERS = {
    TILE_VERTEX_SHADER,
    TILE_FRAGMENT_SHADER,
    SPRITE_VERTEX_SHADER,
    SPRITE_FRAGMENT_SHADER,
    RECTANGLE_VERTEX_SHADER,
    RECTANGLE_FRAGMENT_SHADER,
} as const;
</t>
<t tx="felix.20250126174340.1">abstract class BaseRenderer {
    protected gl: WebGL2RenderingContext;
    public program: WebGLProgram;
    protected vao: WebGLVertexArrayObject;
    protected dirtyTransforms: boolean; // Flag to update bufferData from transformData in the render method.
    protected resources: GLResources = {
        buffers: [],
        textures: [],
        shaders: []
    };

    constructor(gl: WebGL2RenderingContext, vertexShader: string, fragmentShader: string) {
        this.gl = gl;
        this.program = this.createProgram(vertexShader, fragmentShader);
        this.gl.useProgram(this.program);
        this.vao = this.gl.createVertexArray()!;
        this.dirtyTransforms = false;
    }

    protected createProgram(vertexSource: string, fragmentSource: string): WebGLProgram {
        const program = this.gl.createProgram()!;
        let errorLog = '';
        const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource)!;
        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource)!;

        this.gl.attachShader(program, vertexShader);
        this.gl.attachShader(program, fragmentShader);
        this.gl.linkProgram(program);

        // Error checking
        if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
            errorLog += `\nProgram linking failed: ${this.gl.getProgramInfoLog(program)}`;
        }
        this.gl.validateProgram(program);
        if (!this.gl.getProgramParameter(program, this.gl.VALIDATE_STATUS)) {
            errorLog += `\nProgram validation failed: ${this.gl.getProgramInfoLog(program)}`;
        }
        const activeAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);
        const activeUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);
        if (activeAttributes === 0 &amp;&amp; activeUniforms === 0) {
            errorLog += '\nWarning: Program has no active attributes or uniforms';
        }
        if (errorLog) {
            throw new Error(`WebGL Program creation failed: ${errorLog}`);
        }

        return program;
    }

    protected createShader(type: ShaderType, source: string): WebGLShader {
        const shader = this.gl.createShader(type)!;
        this.resources.shaders.push(shader);
        this.gl.shaderSource(shader, source);
        this.gl.compileShader(shader);
        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
            console.error(this.gl.getShaderInfoLog(shader));
            throw new Error('Shader compilation failed');
        }
        return shader;
    }

    protected createBuffer(): WebGLBuffer {
        const buffer = this.gl.createBuffer()!;
        this.resources.buffers.push(buffer);
        return buffer;
    }

    protected createTexture(): WebGLTexture {
        const texture = this.gl.createTexture()!;
        this.resources.textures.push(texture);
        return texture;
    }

    protected setupAttribute(
        location: number,
        size: number,
        stride: number,
        offset: number,
        divisor: number = 0
    ): void {
        this.gl.vertexAttribPointer(location, size, this.gl.FLOAT, false, stride, offset);
        this.gl.enableVertexAttribArray(location);
        this.gl.vertexAttribDivisor(location, divisor);
    }

    abstract updateTransformData(data: any[]): void; // This will also set dirtyTransforms to true.

    abstract render(): void; // Before rendering, update bufferData from transformData if dirtyTransforms is true.

    dispose(): void {
        // Delete all resources in reverse order
        this.resources.textures.forEach(texture =&gt; this.gl.deleteTexture(texture));
        this.resources.buffers.forEach(buffer =&gt; this.gl.deleteBuffer(buffer));
        this.resources.shaders.forEach(shader =&gt; this.gl.deleteShader(shader));
        this.gl.deleteProgram(this.program);
        this.gl.deleteVertexArray(this.vao);

        // Clear arrays
        this.resources.textures = [];
        this.resources.buffers = [];
        this.resources.shaders = [];
    }
}

</t>
<t tx="felix.20250126193731.1">class TileRenderer extends BaseRenderer {
    private transformBuffer: WebGLBuffer;
    private modelBuffer: WebGLBuffer;
    private transformData: Float32Array;
    private image: HTMLImageElement
    private texture: WebGLTexture;
    private renderMax: number = 0;
    public gameWidth: number = 0;
    public gameHeight: number = 0;

    constructor(gl: WebGL2RenderingContext, image: HTMLImageElement, size: number, gameWidth: number, gameHeight: number) {
        super(gl, SHADERS.TILE_VERTEX_SHADER, SHADERS.TILE_FRAGMENT_SHADER);
        console.log('constructor: ', gameWidth, gameHeight);

        this.gameWidth = gameWidth;
        this.gameHeight = gameHeight;

        // Move existing shader setup &amp; buffer creation here
        this.image = image;
        this.texture = this.createTexture();
        this.modelBuffer = this.createBuffer(); // Create a buffer
        this.transformBuffer = this.createBuffer()!;

        // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.
        // this.transformData = new Float32Array(size * 7); // Init with 0s
        // this.transformData = new Float32Array(3 * 7); // Init with 0s

        this.transformData = new Float32Array([
            // posX, posY, scale, colorR, colorG, colorB, depth
            // 100, 100, 64, 1, 1, 1, 0,     // White tile at 100,100
            // 300, 200, 64, 0, 1, 0, 1,     // Green tile at 300,200 
            // 500, 300, 64, 0, 0, 1, 2,     // Blue tile at 500,300


            0.1, 0.1, 64, 1, 1, 1, 0,     // White tile at 100,100
            0.3, -0.2, 64, 0, 1, 0, 1,     // Green tile at 0.3,200 
            -0.4, 0.3, 64, 0, 0, 1, 2,     // Blue tile at 500,300
        ]);

        this.setupVAO();

    }

    private setupVAO() {
        this.gl.bindVertexArray(this.vao);

        this.gl.bindTexture(this.gl.TEXTURE_2D_ARRAY, this.texture);
        this.gl.texImage3D(this.gl.TEXTURE_2D_ARRAY, 0, this.gl.RGBA, CONFIG.GAME.TILE.SIZE, CONFIG.GAME.TILE.SIZE, CONFIG.GAME.TILE.DEPTH, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.image); // 64 textures of 128x128 pixels
        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR_MIPMAP_LINEAR); // TODO : TRY MORE FILTERS
        this.gl.texParameteri(this.gl.TEXTURE_2D_ARRAY, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR); // TODO : TRY MORE FILTERS
        this.gl.generateMipmap(this.gl.TEXTURE_2D_ARRAY);

        console.log('Texture loaded and bound', this.gameWidth, this.gameHeight);

        const uWorldXLoc = this.gl.getUniformLocation(this.program, 'uWorldX')!;
        this.gl.uniform1f(uWorldXLoc, 2 / this.gameWidth);

        const uWorldYLoc = this.gl.getUniformLocation(this.program, 'uWorldY')!;
        this.gl.uniform1f(uWorldYLoc, 2 / -this.gameHeight);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.modelBuffer); // Bind the buffer (meaning "use this buffer" for the following operations)
        this.gl.bufferData(this.gl.ARRAY_BUFFER, CONFIG.TEXTURE_MODEL_DATA, this.gl.STATIC_DRAW); // Put data in the buffer
        this.setupAttribute(0, 2, 16, 0);
        this.setupAttribute(1, 2, 16, 8);

        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning "use this buffer for the following operations")
        this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW); // Change to DYNAMIC_DRAW to allow updates);
        this.setupAttribute(2, 2, 28, 0, 1);
        this.setupAttribute(3, 1, 28, 8, 1);
        this.setupAttribute(4, 3, 28, 12, 1);
        this.setupAttribute(5, 1, 28, 24, 1);

        this.gl.bindVertexArray(null); // All done, unbind the VAO

    }

    updateTransformData(data: number[]): void {
        console.log('Updating TileRenderer with new data');
        const bufferData: TileBufferData[] = []
        for (let i = 0; i &lt; data.length; i++) {
            bufferData.push({
                posX: (i % 9) * CONFIG.GAME.TILE.SIZE,
                posY: Math.floor(i / 9) * CONFIG.GAME.TILE.SIZE,
                scale: CONFIG.GAME.TILE.SIZE,
                colorR: 1,
                colorG: 1,
                colorB: 1,
                depth: data[i]
            });
        }

        // TileBufferData
        // for (let i = 0; i &lt; bufferData.length; i++) {
        //     const offset = i * 7;
        //     const d = bufferData[i];
        //     this.transformData[offset] = d.posX;
        //     this.transformData[offset + 1] = d.posY;
        //     this.transformData[offset + 2] = d.scale;
        //     this.transformData[offset + 3] = d.colorR;
        //     this.transformData[offset + 4] = d.colorG;
        //     this.transformData[offset + 5] = d.colorB;
        //     this.transformData[offset + 6] = d.depth;
        // }
        this.renderMax = 3; //  data.length;

        // this.transformData = new Float32Array([
        //     // posX, posY, scale, colorR, colorG, colorB, depth. A stride of 28 bytes.
        //     0, 0, 64, 0, 1.5, 0, 0,      // Green Test at origin
        //     200, 150, 128, 0, 0, 1, 1,    // Blue Test at center
        //     380, 280, 32, 1, 0, 1, 22,   // Purple Test at bottom right
        // ]);

        // this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.transformBuffer); // Bind the buffer (meaning "use this buffer for the following operations")
        // this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.DYNAMIC_DRAW);
        // this.gl.bufferSubData(this.gl.ARRAY_BUFFER, 0, this.transformData, 0, data.length); // Change to DYNAMIC_DRAW to allow updates);

    }

    render(): void {
        this.gl.useProgram(this.program);
        this.gl.bindVertexArray(this.vao);

        // Update the buffer with the new transform data and draw the sprites
        // this.gl.bufferData(this.gl.ARRAY_BUFFER, this.transformData, this.gl.STATIC_DRAW);
        this.gl.drawArraysInstanced(this.gl.TRIANGLES, 0, 6, this.renderMax);

    }

}

</t>
</tnodes>
</leo_file>
